"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const networks_1 = require("../../networks");
const getters_1 = require("../../networks/getters");
const networks_2 = require("../../networks/networks");
describe('Deployments', () => {
    describe('getNetwork', () => {
        it('should return the correct value', () => {
            const inputs = Object.values(networks_1.SupportedNetworks).map(network => {
                return {
                    network,
                    expected: networks_2.networks[network],
                };
            });
            inputs.push({
                network: 'otherNetwork',
                expected: null,
            });
            inputs.map(({ network, expected }) => {
                if (!expected) {
                    expect((0, getters_1.getNetwork)(network)).toBeNull();
                    return;
                }
                expect((0, getters_1.getNetwork)(network)).toMatchObject(expected);
            });
        });
    });
    describe('getNetworkByNameOrAlias', () => {
        it('should return a network given a name', () => {
            const inputs = Object.values(networks_1.SupportedNetworks).map(network => {
                return {
                    network,
                    expected: networks_2.networks[network],
                };
            });
            inputs.map(({ network, expected }) => {
                expect((0, getters_1.getNetworkByNameOrAlias)(network)).toMatchObject(expected);
            });
        });
        it('should return a network given an alias', () => {
            const inputs = Object.values(networks_1.SupportedNetworks)
                .flatMap(nw => {
                return Object.values(networks_1.SupportedAliases).map(alias => {
                    return {
                        network: networks_2.networks[nw].aliases[alias],
                        expected: networks_2.networks[nw],
                    };
                });
            })
                .filter(({ network }) => network !== undefined);
            inputs.map(({ network, expected }) => {
                expect((0, getters_1.getNetworkByNameOrAlias)(network)).toMatchObject(expected);
            });
        });
    });
    describe('getNetworkByAlias', () => {
        it('should return the correct value', () => {
            const inputs = Object.values(networks_1.SupportedNetworks)
                .flatMap(nw => {
                return Object.values(networks_1.SupportedAliases).map(alias => {
                    return {
                        network: networks_2.networks[nw].aliases[alias],
                        expected: networks_2.networks[nw],
                    };
                });
            })
                .filter(({ network }) => network !== undefined);
            inputs.map(({ network, expected }) => {
                if (!expected) {
                    expect((0, getters_1.getNetworkByAlias)(network)).toBeNull();
                    return;
                }
                expect((0, getters_1.getNetworkByAlias)(network)).toMatchObject(expected);
            });
        });
    });
    describe('getNetworkNameByAlias', () => {
        it('should return the correct value', () => {
            const inputs = Object.values(networks_1.SupportedNetworks)
                .flatMap(nw => {
                return Object.values(networks_1.SupportedAliases).map(alias => {
                    return {
                        network: networks_2.networks[nw].aliases[alias],
                        expected: nw,
                    };
                });
            })
                .filter(({ network }) => network !== undefined);
            inputs.map(({ network, expected }) => {
                expect((0, getters_1.getNetworkNameByAlias)(network)).toBe(expected);
            });
        });
    });
    describe('getNetworkAlias', () => {
        it('should return the correct value', () => {
            const inputs = Object.values(networks_1.SupportedNetworks).flatMap(nw => {
                return Object.values(networks_1.SupportedAliases).map(alias => {
                    return {
                        aliasName: alias,
                        network: nw,
                        expected: networks_2.networks[nw].aliases[alias] || nw,
                    };
                });
            });
            inputs.map(({ aliasName, network, expected }) => {
                expect((0, getters_1.getNetworkAlias)(aliasName, network)).toBe(expected);
            });
        });
    });
    describe('getNetworkByChainId', () => {
        it('should get the network given the chainId', () => {
            const inputs = Object.values(networks_1.SupportedNetworks).map(network => {
                return {
                    network: networks_2.networks[network].chainId,
                    expected: networks_2.networks[network],
                };
            });
            inputs.map(({ network, expected }) => {
                expect((0, getters_1.getNetworkByChainId)(network)).toBe(expected);
            });
        });
    });
    describe('addRpcUrlToNetwork', () => {
        it('should add the rpc url to the networks', () => {
            const apiKey = 'TEST_API_KEY';
            (0, networks_2.addRpcUrlToNetwork)(apiKey, networks_2.networksAlchemyRpcUrl);
            Object.values(networks_1.SupportedNetworks).map(network => {
                if (network === networks_1.SupportedNetworks.LOCAL) {
                    expect(networks_2.networks[network].url).toBe(networks_2.networksAlchemyRpcUrl[networks_1.SupportedNetworks.LOCAL]);
                }
                else if (network === networks_1.SupportedNetworks.BASE_GOERLI) {
                    expect(networks_2.networks[network].url).toBe(networks_2.networksAlchemyRpcUrl[networks_1.SupportedNetworks.BASE_GOERLI]);
                }
                else {
                    expect(networks_2.networks[network].url).toBe(`${networks_2.networksAlchemyRpcUrl[network]}${apiKey}`);
                }
            });
        });
    });
});
//# sourceMappingURL=networks.test.js.map