import { AssetBalance, CreateDaoParams, DaoBalancesQueryParams, DaoCreationStepValue, DaoDepositStepValue, DaoDetails, DaoListItem, DaoMetadata, DaoQueryParams, DaoUpdateProposalValidity, DepositParams, HasPermissionParams, PluginPreparationListItem, PluginPreparationQueryParams, PluginQueryParams, PluginRepo, PluginRepoListItem, PluginUpdateProposalValidity, SetAllowanceParams, SetAllowanceStepValue, Transfer, TransferQueryParams } from "../../types";
import { IClientMethods } from "../interfaces";
import { ClientCore, PrepareInstallationParams, PrepareInstallationStepValue, PrepareUninstallationParams, PrepareUninstallationStepValue, PrepareUpdateParams, PrepareUpdateStepValue } from "@aragon/sdk-client-common";
import { SupportedVersions } from "@aragon/osx-commons-configs";
/**
 * Methods module the SDK Generic Client
 */
export declare class ClientMethods extends ClientCore implements IClientMethods {
    prepareInstallation(params: PrepareInstallationParams): AsyncGenerator<PrepareInstallationStepValue>;
    /**
     * Creates a DAO with the given settings and plugins
  
     * @param {CreateDaoParams} params
     * @return {AsyncGenerator<DaoCreationStepValue>}
     * @memberof ClientMethods
     */
    createDao(params: CreateDaoParams): AsyncGenerator<DaoCreationStepValue>;
    /**
     * Pins a metadata object into IPFS and retruns the generated hash
     *
     * @param {DaoMetadata} params
     * @return {Promise<string>}
     * @memberof ClientMethods
     */
    pinMetadata(params: DaoMetadata): Promise<string>;
    /**
     * Deposits ether or an ERC20 token into the DAO
     *
     * @param {DepositParams} params
     * @return {AsyncGenerator<DaoDepositStepValue>}
     * @memberof ClientMethods
     */
    deposit(params: DepositParams): AsyncGenerator<DaoDepositStepValue>;
    private depositNative;
    private depositErc20;
    private depositErc721;
    private depositErc1155;
    /**
     * Checks if the allowance is enough and updates it
     *
     * @param {SetAllowanceParams} params
     * @return {AsyncGenerator<SetAllowanceStepValue>}
     * @memberof ClientMethods
     */
    setAllowance(params: SetAllowanceParams): AsyncGenerator<SetAllowanceStepValue>;
    /**
     * Prepare uninstallation of a plugin
     *
     * @param {PrepareUninstallationParams} params
     * @return {AsyncGenerator<PrepareUninstallationStepValue>}
     * @memberof ClientMethods
     */
    prepareUninstallation(params: PrepareUninstallationParams): AsyncGenerator<PrepareUninstallationStepValue>;
    /**
     * Prepare update of a plugin
     *
     * @param {PrepareUpdateParams} params
     * @return {AsyncGenerator<PrepareUpdateStepValue>}
     * @memberof ClientMethods
     */
    prepareUpdate(params: PrepareUpdateParams): AsyncGenerator<PrepareUpdateStepValue>;
    /**
     * Checks whether a role is granted by the current DAO's ACL settings
     *
     * @param {HasPermissionParams} params
     * @return {Promise<boolean>}
     * @memberof ClientMethods
     */
    hasPermission(params: HasPermissionParams): Promise<boolean>;
    /**
     * Retrieves metadata for DAO with given identifier (address or ens domain)
     *
     * @param {string} daoAddressOrEns
     * @return {(Promise<DaoDetails | null>)}
     * @memberof ClientMethods
     */
    getDao(daoAddressOrEns: string): Promise<DaoDetails | null>;
    /**
     * Retrieves metadata for DAO with given identifier (address or ens domain)
     *
     * @param {DaoQueryParams} params
     *     - limit = 10
     *     - skip = 0
     *     - direction = SortDirection.ASC
     *     - sortBy = DaoSortBy.CREATED_AT
     * @return {Promise<DaoListItem[]>}
     * @memberof ClientMethods
     */
    getDaos({ limit, skip, direction, sortBy, }: DaoQueryParams): Promise<DaoListItem[]>;
    /**
     * Retrieves the asset balances of the given DAO, by default, ETH, DAI, USDC and USDT on Mainnet
     *
     * @param {DaoBalancesQueryParams} params
     *     - daoAddressOrEns
     *     - limit = 10
     *     - skip = 0
     *     - direction = SortDirection.ASC
     *     - sortBy = AssetBalanceSortBy.LAST_UPDATED
     * @return {(Promise<AssetBalance[] | null>)}
     * @memberof ClientMethods
     */
    getDaoBalances({ daoAddressOrEns, limit, skip, direction, sortBy, }: DaoBalancesQueryParams): Promise<AssetBalance[] | null>;
    /**
     * Retrieves the list of asset transfers to and from the given DAO (by default, from ETH, DAI, USDC and USDT, on Mainnet)
     *
     * @param {TransferQueryParams} params
     *     - daoAddressOrEns
     *     - type
     *     - limit = 10
     *     - skip = 0
     *     - direction = SortDirection.ASC
     *     - sortBy = TransferSortBy.CREATED_AT
     * @return {(Promise<Transfer[] | null>)}
     * @memberof ClientMethods
     */
    getDaoTransfers({ daoAddressOrEns, type, limit, skip, direction, sortBy, }: TransferQueryParams): Promise<Transfer[] | null>;
    private getMetadata;
    private getPluginRepo;
    /**
     * Retrieves the list of plugins available on the PluginRegistry
     *
     * @param {PluginQueryParams} params
     *     - limit = 10
     *     - skip = 0
     *     - direction = SortDirection.ASC
     *     - sortBy = PluginSortBy.SUBDOMAIN
     *     - subdomain
     * @param {boolean} [includeMetadata=true]
     * @return {(Promise<PluginRepo[] | null>)}
     * @memberof ClientMethods
     */
    getPlugins({ limit, skip, direction, sortBy, subdomain, includeMetadata, }?: PluginQueryParams): Promise<PluginRepoListItem[]>;
    /**
     * Get plugin details given an address, release and build
     *
     * @param {string} pluginAddress
     * @param {boolean} [includeMetadata=true]
     * @return {Promise<PluginRepo>}
     * @memberof ClientMethods
     */
    getPlugin(pluginAddress: string, includeMetadata?: boolean): Promise<PluginRepo>;
    /**
     * Returns the protocol version of a contract
     * if the transaction fails returns [1,0,0]
     *
     * @param {string} contractAddress
     * @return {Promise<number[]>}
     * @memberof ClientMethods
     */
    getProtocolVersion(contractAddress: string): Promise<[number, number, number]>;
    /**
     * Given a proposal id returns if that proposal is a dao update proposal
     *
     * @param {string} proposalId
     * @return {Promise<boolean>}
     * @memberof ClientMethods
     */
    isDaoUpdateProposal(proposalId: string): Promise<boolean>;
    /**
     * Given a proposal id returns if that proposal is a plugin update proposal
     *
     * @param {string} proposalId
     * @return {Promise<boolean>}
     * @memberof ClientMethods
     */
    isPluginUpdateProposal(proposalId: string): Promise<boolean>;
    /**
     * Check if the specified proposal id is valid for updating a plugin
     *
     * @param {string} proposalId
     * @return {Promise<PluginUpdateProposalValidity>}
     * @memberof ClientMethods
     */
    isPluginUpdateProposalValid(proposalId: string): Promise<PluginUpdateProposalValidity>;
    /**
     * Check if the specified proposalId actions are valid for updating a dao
     *
     * @param {string} proposalId
     * @param {SupportedVersion} [version]
     * @return {Promise<DaoUpdateProposalValidity>}
     * @memberof ClientMethods
     */
    isDaoUpdateProposalValid(proposalId: string, version?: SupportedVersions): Promise<DaoUpdateProposalValidity>;
    /**
     *  Return the implementation address for the specified dao factory
     *
     * @param {string} daoFactoryAddress
     * @return {Promise<string>}
     * @memberof ClientMethods
     */
    getDaoImplementation(daoFactoryAddress: string): Promise<string>;
    getPluginPreparations({ type, pluginAddress, pluginRepoAddress, daoAddressOrEns, limit, skip, direction, sortBy, }: PluginPreparationQueryParams): Promise<PluginPreparationListItem[]>;
}
