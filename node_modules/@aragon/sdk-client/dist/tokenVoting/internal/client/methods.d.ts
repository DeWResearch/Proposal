import { CanVoteParams, CreateMajorityVotingProposalParams, ExecuteProposalStepValue, ProposalCreationStepValue, ProposalQueryParams, VoteProposalParams, VoteProposalStepValue, VotingSettings } from "../../../client-common";
import { DelegateTokensParams, DelegateTokensStepValue, Erc20TokenDetails, Erc20WrapperTokenDetails, Erc721TokenDetails, TokenVotingMember, TokenVotingPluginPrepareInstallationParams, TokenVotingPluginPrepareUpdateParams, TokenVotingProposal, TokenVotingProposalListItem, UndelegateTokensStepValue, UnwrapTokensParams, UnwrapTokensStepValue, WrapTokensParams, WrapTokensStepValue } from "../../types";
import { TokenVotingMembersQueryParams, TokenVotingTokenCompatibility } from "../types";
import { ITokenVotingClientMethods } from "../interfaces";
import { ClientCore, IsMemberParams, PrepareInstallationStepValue, PrepareUpdateStepValue, ProposalMetadata } from "@aragon/sdk-client-common";
/**
 * Methods module the SDK TokenVoting Client
 */
export declare class TokenVotingClientMethods extends ClientCore implements ITokenVotingClientMethods {
    /**
     * Creates a new proposal on the given TokenVoting plugin contract
     *
     * @param {CreateMajorityVotingProposalParams} params
     * @return {AsyncGenerator<ProposalCreationStepValue>}
     * @memberof TokenVotingClient
     */
    createProposal(params: CreateMajorityVotingProposalParams): AsyncGenerator<ProposalCreationStepValue>;
    /**
     * Pins a metadata object into IPFS and retruns the generated hash
     *
     * @param {ProposalMetadata} params
     * @return {Promise<string>}
     * @memberof ClientMethods
     */
    pinMetadata(params: ProposalMetadata): Promise<string>;
    /**
     * Cast a vote on the given proposal using the client's wallet. Depending on the proposal settings, an affirmative vote may execute the proposal's actions on the DAO.
     *
     * @param {VoteProposalParams} params
     * @param {VoteValues} vote
     * @return {AsyncGenerator<VoteProposalStepValue>}
     * @memberof TokenVotingClient
     */
    voteProposal(params: VoteProposalParams): AsyncGenerator<VoteProposalStepValue>;
    /**
     * Executes the given proposal, provided that it has already passed
     *
     * @param {string} proposalId
     * @return {AsyncGenerator<ExecuteProposalStepValue>}
     * @memberof TokenVotingClient
     */
    executeProposal(proposalId: string): AsyncGenerator<ExecuteProposalStepValue>;
    /**
     * Prepares the installation of a token voting plugin in a given dao
     *
     * @param {TokenVotingPluginPrepareInstallationParams} params
     * @return {AsyncGenerator<PrepareInstallationStepValue>}
     * @memberof TokenVotingClientMethods
     */
    prepareInstallation(params: TokenVotingPluginPrepareInstallationParams): AsyncGenerator<PrepareInstallationStepValue>;
    /**
     * Prepares the update of a token voting plugin in a given dao
     *
     * @param {TokenVotingPluginPrepareUpdateParams} params
     * @return {AsyncGenerator<PrepareUpdateStepValue>}
     * @memberof TokenVotingClientMethods
     */
    prepareUpdate(params: TokenVotingPluginPrepareUpdateParams): AsyncGenerator<PrepareUpdateStepValue>;
    wrapTokens(params: WrapTokensParams): AsyncGenerator<WrapTokensStepValue>;
    unwrapTokens(params: UnwrapTokensParams): AsyncGenerator<UnwrapTokensStepValue>;
    /**
     * Delegates all the signer's voting power to a delegatee
     *
     * @param {DelegateTokensParams} params
     * @return {AsyncGenerator<DelegateTokensStepValue>}
     * @memberof TokenVotingClientMethods
     */
    delegateTokens(params: DelegateTokensParams): AsyncGenerator<DelegateTokensStepValue>;
    /**
     * Delegates all the signer's tokens back to itself
     *
     * @param {string} tokenAddress
     * @return {AsyncGenerator<UndelegateTokensStepValue>}
     * @memberof TokenVotingClientMethods
     */
    undelegateTokens(tokenAddress: string): AsyncGenerator<UndelegateTokensStepValue>;
    /**
     * Retrieves the current signer's delegatee for the given token
     *
     * @param {string} tokenAddress
     * @return {Promise<string | null>}
     * @memberof TokenVotingClientMethods
     */
    getDelegatee(tokenAddress: string): Promise<string | null>;
    /**
     * Checks if an user can vote in a proposal
     *
     * @param {CanVoteParams} params
     * @returns   {Promise<boolean>}
     */
    canVote(params: CanVoteParams): Promise<boolean>;
    /**
     * Checks whether the current proposal can be executed
     *
     * @param {string} proposalId
     * @return {Promise<boolean>}
     * @memberof TokenVotingClientMethods
     */
    canExecute(proposalId: string): Promise<boolean>;
    /**
     * Returns the list of wallet addresses holding tokens from the underlying Token contract used by the plugin
     *
     * @param {MembersQueryParams} params
     *     - pluginAddress
     *     - blockNumber
     *     - limit = 10
     *     - skip = 0
     *     - direction = SortDirection.ASC
     *     - sortBy = MembersSortBy.ADDRESS
     * @return {Promise<string[]>}
     * @memberof TokenVotingClientMethods
     */
    getMembers({ pluginAddress, blockNumber, limit, skip, direction, sortBy, }: TokenVotingMembersQueryParams): Promise<TokenVotingMember[]>;
    /**
     * Returns the details of the given proposal
     *
     * @param {string} proposalId
     * @return {Promise<TokenVotingProposal>}
     * @memberof TokenVotingClient
     */
    getProposal(proposalId: string): Promise<TokenVotingProposal | null>;
    /**
     * Returns a list of proposals on the Plugin, filtered by the given criteria
     *
     * @param {ProposalQueryParams} params
     * @return {Promise<TokenVotingProposalListItem[]>}
     * @memberof TokenVotingClient
     */
    getProposals({ daoAddressOrEns, limit, status, skip, direction, sortBy, }: ProposalQueryParams): Promise<TokenVotingProposalListItem[]>;
    /**
     * Returns the settings of a plugin given the address of the plugin instance
     *
     * @param {string} pluginAddress
     * @param {number} blockNumber
     * @return {Promise<VotingSettings>}
     * @memberof TokenVotingClient
     */
    getVotingSettings(pluginAddress: string, blockNumber?: number): Promise<VotingSettings | null>;
    /**
     * Returns the details of the token used in a specific plugin instance
     *
     * @param {string} pluginAddress
     * @return {Promise<Erc20TokenDetails | null>}
     * @memberof TokenVotingClient
     */
    getToken(pluginAddress: string): Promise<Erc20TokenDetails | Erc721TokenDetails | Erc20WrapperTokenDetails | null>;
    /**
     * Checks if the given token is compatible with the TokenVoting plugin
     *
     * @param {string} tokenAddress
     * @return {Promise<TokenVotingTokenCompatibility>}
     * @memberof TokenVotingClientMethods
     */
    isTokenVotingCompatibleToken(tokenAddress: string): Promise<TokenVotingTokenCompatibility>;
    /**
     * Checks if a given address is a member of the tokenVoting contract.
     * @param params - The parameters for the isMember method.
     * @param params.pluginAddress - The address of the plugin.
     * @param params.address - The address to check.
     * @param params.blockNumber - The block number for specifying a specific block.
     * @returns {boolean} A boolean indicating whether the address is a member or not.
     */
    isMember(params: IsMemberParams): Promise<boolean>;
}
