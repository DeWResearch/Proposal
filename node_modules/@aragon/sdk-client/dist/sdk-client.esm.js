import { DAO__factory, PluginSetupProcessor__factory, DAORegistry__factory, PluginRepo__factory, DAOFactory__factory, IProtocolVersion__factory, Multisig__factory, MajorityVotingBase__factory, AddresslistVoting__factory, IERC20MintableUpgradeable__factory, IGovernanceWrappedERC20__factory, TokenVoting__factory, GovernanceWrappedERC20__factory, GovernanceERC20__factory } from '@aragon/osx-ethers';
import { defaultAbiCoder, Interface } from '@ethersproject/abi';
import { BigNumber } from '@ethersproject/bignumber';
import { AddressZero } from '@ethersproject/constants';
import { Contract } from '@ethersproject/contracts';
import { abi } from '@openzeppelin/contracts/build/contracts/ERC20.json';
import { abi as abi$1 } from '@openzeppelin/contracts/build/contracts/ERC721.json';
import { abi as abi$2 } from '@openzeppelin/contracts/build/contracts/ERC1155.json';
import { gql } from 'graphql-request';
import { keccak256 } from '@ethersproject/keccak256';
import { toUtf8Bytes, toUtf8String } from '@ethersproject/strings';
import { AddressOrEnsSchema, BigintSchema, SizeMismatchError, Uint8ArraySchema, IpfsUriSchema, SubdomainSchema, PluginInstallItemSchema, PaginationSchema, PermissionIds, TokenType, NotImplementedError, bytesToHex, getFunctionFragment, hexToBytes, InvalidParameter, InvalidPermissionOperationType, PermissionOperationType, Permissions, getNamedTypesFromMetadata, MultiUri, ClientCore, prepareGenericInstallation, PrepareInstallationSchema, DaoCreationError, MissingExecPermissionError, AmountMismatchError, findLog, FailedDepositError, UpdateAllowanceError, PrepareUninstallationSteps, PluginUninstallationPreparationError, InstallationNotFoundError, PrepareUninstallationSchema, prepareGenericUpdate, IpfsPinError, InvalidCidError, resolveIpfsCid, InvalidAddressOrEnsError, NoProviderError, getExtendedProposalId, promiseWithTimeout, MULTI_FETCH_TIMEOUT, SortDirection, EmptyMultiUriError, ApplyInstallationSchema, ApplyUninstallationSchema, InvalidAddressError, InvalidEnsError, prepareGenericInstallationEstimation, prepareGenericUpdateEstimation, InvalidActionError, IpfsError, InvalidVotingModeError, decodeRatio, encodeRatio, getCompactProposalId, ProposalStatus, InvalidProposalStatusError, encodeProposalId, ProposalCreationError, boolArrayToBitmap, decodeProposalId, UnsupportedNetworkError, isProposalId, InvalidProposalIdError, IsMemberSchema, UNAVAILABLE_PROPOSAL_METADATA, UNSUPPORTED_PROPOSAL_METADATA_LINK, EMPTY_PROPOSAL_METADATA_LINK, getNetwork, getInterfaceId, NotAContractError } from '@aragon/sdk-client-common';
export { Context, PermissionIds, Permissions, PrepareInstallationStep, PrepareUpdateStep } from '@aragon/sdk-client-common';
import { object, string, array, number, mixed } from 'yup';
import { isAddress } from '@ethersproject/address';
import { id } from '@ethersproject/hash';
import { FrameworkContractsNames, contracts, NonFrameworkContractsNames, getNetworkByAlias, getNetworkNameByAlias, SupportedVersions } from '@aragon/osx-commons-configs';
import { abi as abi$5 } from '@openzeppelin/contracts/build/contracts/IVotes.json';
import { abi as abi$4 } from '@openzeppelin/contracts-upgradeable/build/contracts/IVotesUpgradeable.json';
import { abi as abi$3 } from '@openzeppelin/contracts/build/contracts/ERC165.json';

function _AsyncGenerator(e) {
  var r, t;
  function resume(r, t) {
    try {
      var n = e[r](t),
        o = n.value,
        u = o instanceof _OverloadYield;
      Promise.resolve(u ? o.v : o).then(function (t) {
        if (u) {
          var i = "return" === r ? "return" : "next";
          if (!o.k || t.done) return resume(i, t);
          t = e[i](t).value;
        }
        settle(n.done ? "return" : "normal", t);
      }, function (e) {
        resume("throw", e);
      });
    } catch (e) {
      settle("throw", e);
    }
  }
  function settle(e, n) {
    switch (e) {
      case "return":
        r.resolve({
          value: n,
          done: !0
        });
        break;
      case "throw":
        r.reject(n);
        break;
      default:
        r.resolve({
          value: n,
          done: !1
        });
    }
    (r = r.next) ? resume(r.key, r.arg) : t = null;
  }
  this._invoke = function (e, n) {
    return new Promise(function (o, u) {
      var i = {
        key: e,
        arg: n,
        resolve: o,
        reject: u,
        next: null
      };
      t ? t = t.next = i : (r = t = i, resume(e, n));
    });
  }, "function" != typeof e.return && (this.return = void 0);
}
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () {
  return this;
}, _AsyncGenerator.prototype.next = function (e) {
  return this._invoke("next", e);
}, _AsyncGenerator.prototype.throw = function (e) {
  return this._invoke("throw", e);
}, _AsyncGenerator.prototype.return = function (e) {
  return this._invoke("return", e);
};
function _OverloadYield(t, e) {
  this.v = t, this.k = e;
}
function _asyncGeneratorDelegate(t) {
  var e = {},
    n = !1;
  function pump(e, r) {
    return n = !0, r = new Promise(function (n) {
      n(t[e](r));
    }), {
      done: !1,
      value: new _OverloadYield(r, 1)
    };
  }
  return e["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () {
    return this;
  }, e.next = function (t) {
    return n ? (n = !1, t) : pump("next", t);
  }, "function" == typeof t.throw && (e.throw = function (t) {
    if (n) throw n = !1, t;
    return pump("throw", t);
  }), "function" == typeof t.return && (e.return = function (t) {
    return n ? (n = !1, t) : pump("return", t);
  }), e;
}
function _asyncIterator(r) {
  var n,
    t,
    o,
    e = 2;
  for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {
    if (t && null != (n = r[t])) return n.call(r);
    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));
    t = "@@asyncIterator", o = "@@iterator";
  }
  throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(r) {
  function AsyncFromSyncIteratorContinuation(r) {
    if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
    var n = r.done;
    return Promise.resolve(r.value).then(function (r) {
      return {
        value: r,
        done: n
      };
    });
  }
  return AsyncFromSyncIterator = function (r) {
    this.s = r, this.n = r.next;
  }, AsyncFromSyncIterator.prototype = {
    s: null,
    n: null,
    next: function () {
      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
    },
    return: function (r) {
      var n = this.s.return;
      return void 0 === n ? Promise.resolve({
        value: r,
        done: !0
      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
    },
    throw: function (r) {
      var n = this.s.return;
      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));
    }
  }, new AsyncFromSyncIterator(r);
}
function _awaitAsyncGenerator(e) {
  return new _OverloadYield(e, 0);
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function (t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function (t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(typeof e + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function (e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function () {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function (e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function (t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function (t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    catch: function (t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function _wrapAsyncGenerator(fn) {
  return function () {
    return new _AsyncGenerator(fn.apply(this, arguments));
  };
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _taggedTemplateLiteralLoose(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  strings.raw = raw;
  return strings;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var _templateObject$e, _templateObject2$7;
var QueryDao = /*#__PURE__*/gql(_templateObject$e || (_templateObject$e = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  query Dao($address: ID!) {\n    dao(id: $address){\n      id\n      subdomain\n      metadata\n      createdAt\n      plugins{\n        appliedPreparation {\n          pluginAddress\n        }\n        appliedPluginRepo {\n          subdomain\n        }\n        appliedVersion{\n          build\n          release {\n            release\n          }\n        }\n      }\n    }\n  }\n"])));
var QueryDaos = /*#__PURE__*/gql(_templateObject2$7 || (_templateObject2$7 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  query Daos ($limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: Dao_orderBy!) {\n    daos(first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n      id\n      subdomain\n      metadata\n      plugins{\n        appliedPreparation {\n          pluginAddress\n        }\n        appliedPluginRepo {\n          subdomain\n        }\n        appliedVersion{\n          build\n          release {\n            release\n          }\n        }\n      }\n    }\n  }\n"])));

var _templateObject$d;
var QueryTokenBalances = /*#__PURE__*/gql(_templateObject$d || (_templateObject$d = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenBalances($where: TokenBalance_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: TokenBalance_orderBy!) {\n  tokenBalances (where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy) {\n    lastUpdated\n    __typename\n    ... on ERC20Balance {\n      balance\n      token {\n        name\n        decimals\n        symbol\n        id\n      }\n    }\n    ... on ERC721Balance {\n      token {\n        name\n        symbol\n        id\n      }\n      tokenIds\n    }\n    ... on NativeBalance {\n      balance\n    }\n    ... on ERC1155Balance {\n      metadataUri\n      token {\n        id\n      }\n      balances {\n        amount\n        id\n        tokenId\n      }\n    }\n  }\n}\n"])));

var _templateObject$c;
var QueryTokenTransfers = /*#__PURE__*/gql(_templateObject$c || (_templateObject$c = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenTransfers($where: TokenTransfer_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: TokenTransfer_orderBy!) {\n  tokenTransfers (where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy) {\n    from\n    to\n    type\n    createdAt\n    txHash\n    proposal{\n      id\n    }\n    __typename\n    ... on ERC20Transfer {\n      amount\n      token {\n        ...on ERC20Contract {\n          id\n          name\n          symbol\n          decimals\n        }\n      }\n    }\n    ... on ERC721Transfer {\n      token{\n      \tid\n        name\n        symbol\n      }\n      \n    }\n    ... on NativeTransfer {\n      amount\n    }\n    ...on ERC1155Transfer{\n      amount\n      tokenId\n      token {\n        id\n      }\n    }\n  }\n}\n"])));

var _templateObject$b, _templateObject2$6, _templateObject3, _templateObject4, _templateObject5, _templateObject6;
var QueryPlugins = /*#__PURE__*/gql(_templateObject$b || (_templateObject$b = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery Plugins($where: PluginRepo_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: PluginRepo_orderBy!) {\n  pluginRepos(where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n    id\n    subdomain\n    releases (orderBy: release, orderDirection: desc){\n      release\n      metadata\n      builds (orderBy: build, orderDirection: desc) {\n        build\n        metadata\n      }\n    }\n  }\n}\n"])));
var QueryPlugin = /*#__PURE__*/gql(_templateObject2$6 || (_templateObject2$6 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery Plugin($id: ID!) {\n  pluginRepo(id:$id){\n    id\n    subdomain\n    releases(orderBy: release, orderDirection: desc){\n      release\n      metadata\n      builds(orderBy: build, orderDirection: desc){\n        build\n        metadata\n      }\n    }\n  }\n}\n"])));
var QueryIPlugin = /*#__PURE__*/gql(_templateObject3 || (_templateObject3 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery IPlugin($address: ID!, $where: IPlugin_filter!) {\n\tiplugin(id:$address, where:$where){\n    installations(where:{state: Installed}) {\n      appliedPreparation{\n        helpers\n        pluginRepo {\n          id\n        }\n      }\n     \tappliedVersion {\n        metadata\n        build\n        release{\n          release\n        }\n      }\n    }   \n  }\n}\n"])));
var QueryPluginPreparations = /*#__PURE__*/gql(_templateObject4 || (_templateObject4 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery PluginPreparations($where: PluginPreparation_filter!) {\n  pluginPreparations(where: $where){\n    data\n  }\n}\n"])));
var QueryPluginPreparationsExtended = /*#__PURE__*/gql(_templateObject5 || (_templateObject5 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery PluginPreparations($where: PluginPreparation_filter!, $limit: Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: PluginPreparation_orderBy!) {\n  pluginPreparations(where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n    id\n    type\n    creator\n    dao {\n      id\n    }\n    pluginRepo {\n      id\n      subdomain\n    }\n    pluginVersion{\n      build\n      release{\n        release\n      }\n    }\n    pluginAddress\n    permissions {\n      id\n      operation\n      where\n      who\n      condition\n    }\n    helpers\n    data\n  }\n}\n"])));
var QueryPluginInstallations = /*#__PURE__*/gql(_templateObject6 || (_templateObject6 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\n  query PluginInstallations($where: PluginInstallation_filter!) {\n    pluginInstallations(where: $where) {\n      id\n    }\n  }"])));

var _templateObject$a;
var QueryIProposal = /*#__PURE__*/gql(_templateObject$a || (_templateObject$a = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery IProposal($id: String!) {\n    iproposal(id: $id) {\n        dao {\n            id\n        }\n        allowFailureMap\n        actions {\n            to\n            value\n            data\n        }\n    }\n}\n"])));

var DaoCreationSteps;
(function (DaoCreationSteps) {
  DaoCreationSteps["CREATING"] = "creating";
  DaoCreationSteps["DONE"] = "done";
})(DaoCreationSteps || (DaoCreationSteps = {}));
var DaoSortBy;
(function (DaoSortBy) {
  DaoSortBy["CREATED_AT"] = "createdAt";
  DaoSortBy["SUBDOMAIN"] = "subdomain";
  // POPULARITY = "totalProposals", // currently defined as number of proposals
})(DaoSortBy || (DaoSortBy = {}));
var PluginSortBy;
(function (PluginSortBy) {
  PluginSortBy["SUBDOMAIN"] = "subdomain";
})(PluginSortBy || (PluginSortBy = {}));
var DaoDepositSteps;
(function (DaoDepositSteps) {
  DaoDepositSteps["CHECKED_ALLOWANCE"] = "checkedAllowance";
  DaoDepositSteps["DEPOSITING"] = "depositing";
  DaoDepositSteps["DONE"] = "done";
})(DaoDepositSteps || (DaoDepositSteps = {}));
var AssetBalanceSortBy;
(function (AssetBalanceSortBy) {
  AssetBalanceSortBy["LAST_UPDATED"] = "lastUpdated";
})(AssetBalanceSortBy || (AssetBalanceSortBy = {}));
var TransferType;
(function (TransferType) {
  TransferType["DEPOSIT"] = "deposit";
  TransferType["WITHDRAW"] = "withdraw";
})(TransferType || (TransferType = {}));
var TransferSortBy;
(function (TransferSortBy) {
  TransferSortBy["CREATED_AT"] = "createdAt";
})(TransferSortBy || (TransferSortBy = {}));
var SetAllowanceSteps;
(function (SetAllowanceSteps) {
  SetAllowanceSteps["SETTING_ALLOWANCE"] = "settingAllowance";
  SetAllowanceSteps["ALLOWANCE_SET"] = "allowanceSet";
})(SetAllowanceSteps || (SetAllowanceSteps = {}));
var ProposalSettingsErrorCause;
(function (ProposalSettingsErrorCause) {
  ProposalSettingsErrorCause["NON_ZERO_ALLOW_FAILURE_MAP_VALUE"] = "nonZeroAllowFailureMapValue";
  ProposalSettingsErrorCause["INVALID_ACTIONS"] = "invalidActions";
  ProposalSettingsErrorCause["PROPOSAL_NOT_FOUND"] = "proposalNotFound";
})(ProposalSettingsErrorCause || (ProposalSettingsErrorCause = {}));
var PluginUpdateProposalInValidityCause;
(function (PluginUpdateProposalInValidityCause) {
  // Grant UPDATE_PLUGIN_PERMISSION action
  PluginUpdateProposalInValidityCause["INVALID_GRANT_UPGRADE_PLUGIN_PERMISSION_WHO_ADDRESS"] = "invalidGrantUpgradePluginPermissionWhoAddress";
  PluginUpdateProposalInValidityCause["INVALID_GRANT_UPGRADE_PLUGIN_PERMISSION_WHERE_ADDRESS"] = "invalidGrantUpgradePluginPermissionWhereAddress";
  PluginUpdateProposalInValidityCause["INVALID_GRANT_UPGRADE_PLUGIN_PERMISSION_PERMISSION_NAME"] = "invalidGrantUpgradePluginPermissionPermissionName";
  PluginUpdateProposalInValidityCause["NON_ZERO_GRANT_UPGRADE_PLUGIN_PERMISSION_CALL_VALUE"] = "nonZeroGrantUpgradePluginPermissionCallValue";
  PluginUpdateProposalInValidityCause["INVALID_GRANT_UPGRADE_PLUGIN_PERMISSION_PERMISSION_ID"] = "invalidGrantUpgradePluginPermissionPermissionId";
  PluginUpdateProposalInValidityCause["INVALID_GRANT_UPGRADE_PLUGIN_PERMISSION_TO_ADDRESS"] = "invalidGrantUpgradePluginPermissionToAddress";
  // Revoke UPDATE_PLUGIN_PERMISSION action
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_UPGRADE_PLUGIN_PERMISSION_WHO_ADDRESS"] = "invalidRevokeUpgradePluginPermissionWhoAddress";
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_UPGRADE_PLUGIN_PERMISSION_WHERE_ADDRESS"] = "invalidRevokeUpgradePluginPermissionWhereAddress";
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_UPGRADE_PLUGIN_PERMISSION_PERMISSION_NAME"] = "invalidRevokeUpgradePluginPermissionPermissionName";
  PluginUpdateProposalInValidityCause["NON_ZERO_REVOKE_UPGRADE_PLUGIN_PERMISSION_CALL_VALUE"] = "nonZeroRevokeUpgradePluginPermissionCallValue";
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_UPGRADE_PLUGIN_PERMISSION_PERMISSION_ID"] = "invalidRevokeUpgradePluginPermissionPermissionId";
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_UPGRADE_PLUGIN_PERMISSION_TO_ADDRESS"] = "invalidRevokeUpdatePluginPermissionToAddress";
  // Grant ROOT_PERMISSION action
  PluginUpdateProposalInValidityCause["INVALID_GRANT_ROOT_PERMISSION_WHO_ADDRESS"] = "invalidGrantRootPermissionWhoAddress";
  PluginUpdateProposalInValidityCause["INVALID_GRANT_ROOT_PERMISSION_WHERE_ADDRESS"] = "invalidGrantRootPermissionWhereAddress";
  PluginUpdateProposalInValidityCause["INVALID_GRANT_ROOT_PERMISSION_PERMISSION_NAME"] = "invalidGrantRootPermissionPermissionName";
  PluginUpdateProposalInValidityCause["NON_ZERO_GRANT_ROOT_PERMISSION_CALL_VALUE"] = "nonZeroGrantRootPermissionCallValue";
  PluginUpdateProposalInValidityCause["INVALID_GRANT_ROOT_PERMISSION_PERMISSION_ID"] = "invalidGrantRootPermissionPermissionId";
  PluginUpdateProposalInValidityCause["INVALID_GRANT_ROOT_PERMISSION_TO_ADDRESS"] = "invalidGrantRootPermissionToAddress";
  // Revoke ROOT_PERMISSION action
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_ROOT_PERMISSION_WHO_ADDRESS"] = "invalidRevokeRootPermissionWhoAddress";
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_ROOT_PERMISSION_WHERE_ADDRESS"] = "invalidRevokeRootPermissionWhereAddress";
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_ROOT_PERMISSION_PERMISSION_NAME"] = "invalidRevokeRootPermissionPermissionName";
  PluginUpdateProposalInValidityCause["NON_ZERO_REVOKE_ROOT_PERMISSION_CALL_VALUE"] = "nonZeroRevokeRootPermissionCallValue";
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_ROOT_PERMISSION_PERMISSION_ID"] = "invalidRevokeRootPermissionPermissionId";
  PluginUpdateProposalInValidityCause["INVALID_REVOKE_ROOT_PERMISSION_TO_ADDRESS"] = "invalidRevokeRootPermissionToAddress";
  // applyUpdate action
  PluginUpdateProposalInValidityCause["NON_ZERO_APPLY_UPDATE_CALL_VALUE"] = "nonZeroApplyUpdateCallValue";
  PluginUpdateProposalInValidityCause["PLUGIN_NOT_INSTALLED"] = "pluginNotInstalled";
  PluginUpdateProposalInValidityCause["NOT_ARAGON_PLUGIN_REPO"] = "notAragonPluginRepo";
  PluginUpdateProposalInValidityCause["MISSING_PLUGIN_REPO"] = "missingPluginRepo";
  PluginUpdateProposalInValidityCause["MISSING_PLUGIN_PREPARATION"] = "missingPluginPreparation";
  PluginUpdateProposalInValidityCause["UPDATE_TO_INCOMPATIBLE_RELEASE"] = "updateToIncompatibleRelease";
  PluginUpdateProposalInValidityCause["UPDATE_TO_OLDER_OR_SAME_BUILD"] = "updateToOlderOrSameBuild";
  PluginUpdateProposalInValidityCause["INVALID_DATA"] = "invalidData";
  PluginUpdateProposalInValidityCause["INVALID_PLUGIN_REPO_METADATA"] = "invalidPluginRepoMetadata";
})(PluginUpdateProposalInValidityCause || (PluginUpdateProposalInValidityCause = {}));
var DaoUpdateProposalInvalidityCause;
(function (DaoUpdateProposalInvalidityCause) {
  DaoUpdateProposalInvalidityCause["NON_ZERO_CALL_VALUE"] = "nonZeroCallValue";
  DaoUpdateProposalInvalidityCause["INVALID_TO_ADDRESS"] = "invalidToAddress";
  DaoUpdateProposalInvalidityCause["INVALID_UPGRADE_TO_IMPLEMENTATION_ADDRESS"] = "invalidUpgradeToImplementationAddress";
  DaoUpdateProposalInvalidityCause["INVALID_UPGRADE_TO_AND_CALL_DATA"] = "invalidUpgradeToAndCallData";
  DaoUpdateProposalInvalidityCause["INVALID_UPGRADE_TO_AND_CALL_IMPLEMENTATION_ADDRESS"] = "invalidUpgradeToAndCallImplementationAddress";
  DaoUpdateProposalInvalidityCause["INVALID_UPGRADE_TO_AND_CALL_VERSION"] = "invalidUpgradeToAndCallVersion";
})(DaoUpdateProposalInvalidityCause || (DaoUpdateProposalInvalidityCause = {}));
var PluginPreparationType;
(function (PluginPreparationType) {
  PluginPreparationType["INSTALLATION"] = "Installation";
  PluginPreparationType["UPDATE"] = "Update";
  PluginPreparationType["UNINSTALLATION"] = "Uninstallation";
})(PluginPreparationType || (PluginPreparationType = {}));
var PluginPreparationSortBy;
(function (PluginPreparationSortBy) {
  PluginPreparationSortBy["ID"] = "id";
})(PluginPreparationSortBy || (PluginPreparationSortBy = {}));

var SubgraphTransferType;
(function (SubgraphTransferType) {
  SubgraphTransferType["DEPOSIT"] = "Deposit";
  SubgraphTransferType["WITHDRAW"] = "Withdraw";
})(SubgraphTransferType || (SubgraphTransferType = {}));
var SubgraphTransferTypeMap = /*#__PURE__*/new Map([[TransferType.DEPOSIT, SubgraphTransferType.DEPOSIT], [TransferType.WITHDRAW, SubgraphTransferType.WITHDRAW]]);
var SubgraphPluginPermissionOperation;
(function (SubgraphPluginPermissionOperation) {
  SubgraphPluginPermissionOperation["GRANT"] = "Grant";
  SubgraphPluginPermissionOperation["REVOKE"] = "Revoke";
  SubgraphPluginPermissionOperation["GRANT_WITH_CONDITION"] = "GrantWithCondition";
})(SubgraphPluginPermissionOperation || (SubgraphPluginPermissionOperation = {}));
var ProposalActionTypes;
(function (ProposalActionTypes) {
  ProposalActionTypes["UPGRADE_TO"] = "upgradeTo";
  ProposalActionTypes["UPGRADE_TO_AND_CALL"] = "upgradeToAndCall";
  ProposalActionTypes["APPLY_UPDATE"] = "applyUpdate";
  ProposalActionTypes["GRANT_PLUGIN_UPGRADE_PERMISSION"] = "grantUpgradePluginPermission";
  ProposalActionTypes["REVOKE_PLUGIN_UPGRADE_PERMISSION"] = "revokeUpgradePluginPermission";
  ProposalActionTypes["GRANT_ROOT_PERMISSION"] = "grantRootPermission";
  ProposalActionTypes["REVOKE_ROOT_PERMISSION"] = "revokeRootPermission";
  ProposalActionTypes["ACTION_NOT_ALLOWED"] = "actionNotAllowed";
  ProposalActionTypes["UNKNOWN"] = "unknown";
})(ProposalActionTypes || (ProposalActionTypes = {}));

var AVAILABLE_FUNCTION_SIGNATURES$3 = [/*#__PURE__*/new Contract(AddressZero, abi)["interface"].getFunction("transfer").format("minimal"), /*#__PURE__*/new Contract(AddressZero, abi$1)["interface"].getFunction("safeTransferFrom(address,address,uint256)").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("grant").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("grantWithCondition").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("revoke").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("setMetadata").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("setDaoURI").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("registerStandardCallback").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("setSignatureValidator").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("upgradeTo").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("upgradeToAndCall").format("minimal")];
var UNSUPPORTED_DAO_METADATA_LINK = {
  name: "(unsupported metadata link)",
  description: "(the metadata link is not supported)",
  links: []
};
var EMPTY_DAO_METADATA_LINK = {
  name: "(the DAO has no metadata)",
  description: "(the DAO did not define any content)",
  links: []
};
var UNAVAILABLE_DAO_METADATA = {
  name: "(unavailable metadata)",
  description: "(the DAO metadata is not available)",
  links: []
};
var UNSUPPORTED_RELEASE_METADATA_LINK = {
  name: "(unsupported metadata link)",
  description: "(the metadata link is not supported)",
  images: {}
};
var EMPTY_RELEASE_METADATA_LINK = {
  name: "(the release has no metadata)",
  description: "(the release did not define any content)",
  images: {}
};
var UNAVAILABLE_RELEASE_METADATA = {
  name: "(unavailable metadata)",
  description: "(the release metadata is not available)",
  images: {}
};
var UNSUPPORTED_BUILD_METADATA_LINK = {
  ui: "",
  change: "(unsupported metadata link)",
  pluginSetup: {
    prepareInstallation: [],
    prepareUninstallation: [],
    prepareUpdate: []
  }
};
var EMPTY_BUILD_METADATA_LINK = {
  ui: "",
  change: "(the build has no metadata)",
  pluginSetup: {
    prepareInstallation: [],
    prepareUninstallation: [],
    prepareUpdate: []
  }
};
var UNAVAILABLE_BUILD_METADATA = {
  ui: "",
  change: "(unavailable metadata)",
  pluginSetup: {
    prepareInstallation: [],
    prepareUninstallation: [],
    prepareUpdate: []
  }
};
var SupportedPluginRepo;
(function (SupportedPluginRepo) {
  SupportedPluginRepo["ADMIN"] = "admin";
  SupportedPluginRepo["MULTISIG"] = "multisig";
  SupportedPluginRepo["TOKEN_VOTING"] = "token-voting";
  SupportedPluginRepo["ADDRESS_LIST_VOTING"] = "address-list-voting";
})(SupportedPluginRepo || (SupportedPluginRepo = {}));
var SupportedPluginRepoArray = /*#__PURE__*/Object.values(SupportedPluginRepo);
var PreparationType;
(function (PreparationType) {
  PreparationType[PreparationType["NONE"] = 0] = "NONE";
  PreparationType[PreparationType["INSTALLATION"] = 1] = "INSTALLATION";
  PreparationType[PreparationType["UPDATE"] = 2] = "UPDATE";
  PreparationType[PreparationType["UNINSTALLATION"] = 3] = "UNINSTALLATION";
})(PreparationType || (PreparationType = {}));
var UPDATE_PLUGIN_SIGNATURES = [/*#__PURE__*/DAO__factory.createInterface().getFunction("grant").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("revoke").format("minimal"), /*#__PURE__*/PluginSetupProcessor__factory.createInterface().getFunction("applyUpdate").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("upgradeTo").format("minimal"), /*#__PURE__*/DAO__factory.createInterface().getFunction("upgradeToAndCall").format("minimal")];
var PLUGIN_UPDATE_ACTION_PATTERN = [ProposalActionTypes.GRANT_PLUGIN_UPGRADE_PERMISSION, ProposalActionTypes.APPLY_UPDATE, ProposalActionTypes.REVOKE_PLUGIN_UPGRADE_PERMISSION];
var PLUGIN_UPDATE_WITH_ROOT_ACTION_PATTERN = [ProposalActionTypes.GRANT_PLUGIN_UPGRADE_PERMISSION, ProposalActionTypes.GRANT_ROOT_PERMISSION, ProposalActionTypes.APPLY_UPDATE, ProposalActionTypes.REVOKE_ROOT_PERMISSION, ProposalActionTypes.REVOKE_PLUGIN_UPGRADE_PERMISSION];

var CreateDaoSchema = /*#__PURE__*/object({
  metadataUri: /*#__PURE__*/IpfsUriSchema.required(),
  daoUri: /*#__PURE__*/string().url().notRequired(),
  ensSubdomain: /*#__PURE__*/SubdomainSchema.notRequired(),
  trustedForwarder: /*#__PURE__*/AddressOrEnsSchema.notRequired(),
  plugins: /*#__PURE__*/array(PluginInstallItemSchema).min(1).required()
});
var DaoMetadataSchema = /*#__PURE__*/object({
  name: /*#__PURE__*/string().required(),
  description: /*#__PURE__*/string().required(),
  avatar: /*#__PURE__*/mixed().test(function (item) {
    return [IpfsUriSchema, string().url()].some(function (schema) {
      return schema.strict().isValidSync(item);
    });
  }).notRequired(),
  links: /*#__PURE__*/array(object({
    name: string().required(),
    url: string().required()
  })).required()
});
var DepositEthSchema = /*#__PURE__*/object({
  type: /*#__PURE__*/string().required().oneOf(["native"]),
  daoAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.required(),
  amount: /*#__PURE__*/BigintSchema.required()
});
var DepositErc20Schema = /*#__PURE__*/object({
  type: /*#__PURE__*/string().required().oneOf(["erc20"]),
  daoAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.required(),
  tokenAddress: /*#__PURE__*/AddressOrEnsSchema.required(),
  amount: /*#__PURE__*/BigintSchema.required()
});
var DepositErc721Schema = /*#__PURE__*/object({
  type: /*#__PURE__*/string().required().oneOf(["erc721"]),
  daoAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.required(),
  tokenAddress: /*#__PURE__*/AddressOrEnsSchema.required(),
  tokenId: /*#__PURE__*/BigintSchema.required()
});
var DepositErc1155Schema = /*#__PURE__*/object({
  type: string().required().oneOf(["erc1155"]),
  daoAddressOrEns: AddressOrEnsSchema.required(),
  tokenAddress: AddressOrEnsSchema.required(),
  tokenIds: array(BigintSchema).required().min(1),
  amounts: array(BigintSchema).required().min(1)
}).test("isSameLength", new SizeMismatchError("tokenIds", "amounts").message, function (value) {
  var v = value;
  return v.tokenIds && v.amounts ? v.tokenIds.length === v.amounts.length : true;
});
var SetAllowanceSchema = /*#__PURE__*/object({
  tokenAddress: /*#__PURE__*/AddressOrEnsSchema.required(),
  amount: /*#__PURE__*/BigintSchema.required(),
  spender: /*#__PURE__*/AddressOrEnsSchema.required()
});
var HasPermissionSchema = /*#__PURE__*/object({
  who: /*#__PURE__*/AddressOrEnsSchema.required(),
  where: /*#__PURE__*/AddressOrEnsSchema.required(),
  permission: /*#__PURE__*/string().required(),
  daoAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.required(),
  data: /*#__PURE__*/Uint8ArraySchema.notRequired()
});
var DaoQuerySchema = /*#__PURE__*/PaginationSchema.concat( /*#__PURE__*/object({
  sortBy: /*#__PURE__*/string().notRequired().oneOf(["createdAt", "subdomain"])
}));
var DaoBalancesQuerySchema = /*#__PURE__*/PaginationSchema.concat( /*#__PURE__*/object({
  sortBy: /*#__PURE__*/string().notRequired().oneOf(["lastUpdated"]),
  daoAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.notRequired()
}));
var PluginQuerySchema = /*#__PURE__*/PaginationSchema.concat( /*#__PURE__*/object({
  sortBy: /*#__PURE__*/string().notRequired().oneOf(["subdomain"]),
  subdomain: /*#__PURE__*/SubdomainSchema.notRequired()
}));
var PermissionBaseSchema = /*#__PURE__*/object({
  who: /*#__PURE__*/AddressOrEnsSchema.required(),
  where: /*#__PURE__*/AddressOrEnsSchema.required(),
  permission: /*#__PURE__*/string().required()
});
var PermissionWithConditionSchema = /*#__PURE__*/PermissionBaseSchema.concat( /*#__PURE__*/object({
  condition: /*#__PURE__*/AddressOrEnsSchema.required()
}));
var WithdrawEthSchema = /*#__PURE__*/object({
  type: /*#__PURE__*/string().required().oneOf(["native"]),
  recipientAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.required(),
  amount: /*#__PURE__*/BigintSchema.required()
});
var WithdrawErc20Schema = /*#__PURE__*/object({
  type: /*#__PURE__*/string().required().oneOf(["erc20"]),
  recipientAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.required(),
  tokenAddress: /*#__PURE__*/AddressOrEnsSchema.required(),
  amount: /*#__PURE__*/BigintSchema.required()
});
var WithdrawErc721Schema = /*#__PURE__*/object({
  type: /*#__PURE__*/string().required().oneOf(["erc721"]),
  daoAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.required(),
  recipientAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.required(),
  tokenAddress: /*#__PURE__*/AddressOrEnsSchema.required(),
  tokenId: /*#__PURE__*/BigintSchema.required()
});
var WithdrawErc1155Schema = /*#__PURE__*/object({
  type: string().required().oneOf(["erc1155"]),
  daoAddressOrEns: AddressOrEnsSchema.required(),
  recipientAddressOrEns: AddressOrEnsSchema.required(),
  tokenAddress: AddressOrEnsSchema.required(),
  tokenIds: array(BigintSchema).required().min(1),
  amounts: array(BigintSchema).required().min(1)
}).test("isSameLength", new SizeMismatchError("tokenIds", "amounts").message, function (value) {
  var v = value;
  return v.tokenIds && v.amounts ? v.tokenIds.length === v.amounts.length : true;
});
var RegisterStandardCallbackSchema = /*#__PURE__*/object({
  interfaceId: /*#__PURE__*/string().required(),
  callbackSelector: /*#__PURE__*/string().required(),
  magicNumber: /*#__PURE__*/string().required()
});
var UpgradeToAndCallSchema = /*#__PURE__*/object({
  implementationAddress: /*#__PURE__*/AddressOrEnsSchema.required(),
  data: /*#__PURE__*/Uint8ArraySchema.required()
});
var InitializeFromSchema = /*#__PURE__*/object({
  previousVersion: /*#__PURE__*/array().of(number()).length(3).required(),
  initData: /*#__PURE__*/Uint8ArraySchema.notRequired()
});
var DaoUpdateSchema = /*#__PURE__*/object({
  previousVersion: /*#__PURE__*/array().of(number()).length(3).required(),
  initData: /*#__PURE__*/Uint8ArraySchema.notRequired(),
  daoFactoryAddress: /*#__PURE__*/AddressOrEnsSchema.notRequired()
});
var PluginPreparationQuerySchema = /*#__PURE__*/PaginationSchema.concat( /*#__PURE__*/object({
  sortBy: /*#__PURE__*/string().notRequired().oneOf([PluginPreparationSortBy.ID]),
  type: /*#__PURE__*/string().notRequired().oneOf([PluginPreparationType.INSTALLATION, PluginPreparationType.UPDATE]),
  daoAddressOrEns: /*#__PURE__*/AddressOrEnsSchema.notRequired(),
  pluginAddress: /*#__PURE__*/AddressOrEnsSchema.notRequired(),
  pluginRepoAddress: /*#__PURE__*/AddressOrEnsSchema.notRequired()
}));

function toDaoDetails(dao, metadata) {
  return {
    address: dao.id,
    ensDomain: dao.subdomain + ".dao.eth",
    metadata: {
      name: metadata.name,
      description: metadata.description,
      avatar: metadata.avatar || undefined,
      links: metadata.links
    },
    metadataHash: dao.metadata,
    creationDate: new Date(parseInt(dao.createdAt) * 1000),
    // TODO update when new subgraph schema is deployed
    // filter out plugins that are not applied
    plugins: dao.plugins.filter(function (plugin) {
      return plugin.appliedPreparation && plugin.appliedVersion && plugin.appliedPluginRepo;
    }).map(function (plugin) {
      return {
        // we checked with the filter above that these are not null
        id: plugin.appliedPluginRepo.subdomain + ".plugin.dao.eth",
        release: plugin.appliedVersion.release.release,
        build: plugin.appliedVersion.build,
        instanceAddress: plugin.appliedPreparation.pluginAddress
      };
    })
  };
}
function toDaoListItem(dao, metadata) {
  return {
    address: dao.id,
    ensDomain: dao.subdomain + ".dao.eth",
    metadata: {
      name: metadata.name,
      description: metadata.description,
      avatar: metadata.avatar || undefined
    },
    metadataHash: dao.metadata,
    plugins: dao.plugins.filter(function (plugin) {
      return plugin.appliedPreparation && plugin.appliedVersion && plugin.appliedPluginRepo;
    }).map(function (plugin) {
      return {
        // we checked with the filter above that these are not null
        id: plugin.appliedPluginRepo.subdomain + ".plugin.dao.eth",
        release: plugin.appliedVersion.release.release,
        build: plugin.appliedVersion.build,
        instanceAddress: plugin.appliedPreparation.pluginAddress
      };
    })
  };
}
function toNativeBalance(balance) {
  return {
    id: balance.id,
    type: TokenType.NATIVE,
    balance: BigInt(balance.balance),
    updateDate: new Date(parseInt(balance.lastUpdated) * 1000)
  };
}
function toErc20Balance(balance) {
  return {
    id: balance.id,
    type: TokenType.ERC20,
    address: balance.token.id,
    name: balance.token.name,
    symbol: balance.token.symbol,
    decimals: balance.token.decimals,
    balance: BigInt(balance.balance),
    updateDate: new Date(parseInt(balance.lastUpdated) * 1000)
  };
}
function toErc721Balance(balance) {
  return {
    id: balance.id,
    type: TokenType.ERC721,
    address: balance.token.id,
    name: balance.token.name,
    symbol: balance.token.symbol,
    updateDate: new Date(parseInt(balance.lastUpdated) * 1000),
    tokenIds: balance.tokenIds.map(function (id) {
      return BigInt(id);
    })
  };
}
function toErc1155Balance(balance) {
  return {
    id: balance.id,
    type: TokenType.ERC1155,
    address: balance.token.id,
    metadataUri: balance.metadataUri,
    updateDate: new Date(parseInt(balance.lastUpdated) * 1000),
    balances: balance.balances.map(function (balance) {
      return {
        tokenId: BigInt(balance.tokenId),
        amount: BigInt(balance.amount),
        id: balance.id
      };
    })
  };
}
function toAssetBalance(balance) {
  switch (balance.__typename) {
    case "NativeBalance":
      return toNativeBalance(balance);
    case "ERC20Balance":
      return toErc20Balance(balance);
    case "ERC721Balance":
      return toErc721Balance(balance);
    case "ERC1155Balance":
      return toErc1155Balance(balance);
    default:
      throw new InvalidParameter("Token type not supported");
  }
}
function toErc20Transfer(transfer) {
  var _transfer$proposal;
  var creationDate = new Date(parseInt(transfer.createdAt) * 1000);
  if (transfer.type === SubgraphTransferType.DEPOSIT) {
    return {
      type: TransferType.DEPOSIT,
      tokenType: TokenType.ERC20,
      token: {
        address: transfer.token.id,
        name: transfer.token.name,
        symbol: transfer.token.symbol,
        decimals: transfer.token.decimals
      },
      amount: BigInt(transfer.amount),
      creationDate: creationDate,
      transactionId: transfer.txHash,
      from: transfer.from,
      to: transfer.to
    };
  }
  return {
    type: TransferType.WITHDRAW,
    tokenType: TokenType.ERC20,
    token: {
      address: transfer.token.id,
      name: transfer.token.name,
      symbol: transfer.token.symbol,
      decimals: transfer.token.decimals
    },
    amount: BigInt(transfer.amount),
    creationDate: creationDate,
    transactionId: transfer.txHash,
    to: transfer.to,
    from: transfer.from,
    proposalId: ((_transfer$proposal = transfer.proposal) == null ? void 0 : _transfer$proposal.id) || ""
  };
}
function toErc721Transfer(transfer) {
  var _transfer$proposal2;
  var creationDate = new Date(parseInt(transfer.createdAt) * 1000);
  if (transfer.type === SubgraphTransferType.DEPOSIT) {
    return {
      type: TransferType.DEPOSIT,
      tokenType: TokenType.ERC721,
      token: {
        address: transfer.token.id,
        name: transfer.token.name,
        symbol: transfer.token.symbol
      },
      creationDate: creationDate,
      transactionId: transfer.txHash,
      from: transfer.from,
      to: transfer.to
    };
  }
  return {
    type: TransferType.WITHDRAW,
    tokenType: TokenType.ERC721,
    token: {
      address: transfer.token.id,
      name: transfer.token.name,
      symbol: transfer.token.symbol
    },
    creationDate: creationDate,
    transactionId: transfer.txHash,
    to: transfer.to,
    from: transfer.from,
    proposalId: ((_transfer$proposal2 = transfer.proposal) == null ? void 0 : _transfer$proposal2.id) || ""
  };
}
function toErc1155Transfer(transfer) {
  var _transfer$proposal3;
  var creationDate = new Date(parseInt(transfer.createdAt) * 1000);
  if (transfer.type === SubgraphTransferType.DEPOSIT) {
    return {
      type: TransferType.DEPOSIT,
      tokenType: TokenType.ERC1155,
      amount: BigInt(transfer.amount),
      tokenId: BigInt(transfer.tokenId),
      token: {
        address: transfer.token.id
      },
      creationDate: creationDate,
      transactionId: transfer.txHash,
      from: transfer.from,
      to: transfer.to
    };
  }
  return {
    type: TransferType.WITHDRAW,
    tokenType: TokenType.ERC1155,
    amount: BigInt(transfer.amount),
    tokenId: BigInt(transfer.tokenId),
    token: {
      address: transfer.token.id
    },
    creationDate: creationDate,
    transactionId: transfer.txHash,
    proposalId: ((_transfer$proposal3 = transfer.proposal) == null ? void 0 : _transfer$proposal3.id) || "",
    to: transfer.to,
    from: transfer.from
  };
}
function toNativeTransfer(transfer) {
  var _transfer$proposal4;
  var creationDate = new Date(parseInt(transfer.createdAt) * 1000);
  if (transfer.type === SubgraphTransferType.DEPOSIT) {
    return {
      type: TransferType.DEPOSIT,
      tokenType: TokenType.NATIVE,
      amount: BigInt(transfer.amount),
      creationDate: creationDate,
      transactionId: transfer.txHash,
      from: transfer.from,
      to: transfer.to
    };
  }
  return {
    type: TransferType.WITHDRAW,
    tokenType: TokenType.NATIVE,
    amount: BigInt(transfer.amount),
    creationDate: creationDate,
    transactionId: transfer.txHash,
    proposalId: ((_transfer$proposal4 = transfer.proposal) == null ? void 0 : _transfer$proposal4.id) || "",
    to: transfer.to,
    from: transfer.from
  };
}
function toTokenTransfer(transfer) {
  switch (transfer.__typename) {
    case "ERC20Transfer":
      return toErc20Transfer(transfer);
    case "ERC721Transfer":
      return toErc721Transfer(transfer);
    case "NativeTransfer":
      return toNativeTransfer(transfer);
    case "ERC1155Transfer":
      return toErc1155Transfer(transfer);
    default:
      throw new InvalidParameter("Token type not supported");
  }
}
function toPluginRepo(pluginRepo, releaseMetadata, buildMetadata) {
  var _pluginRepo$releases, _pluginRepo$releases2;
  return {
    address: pluginRepo.id,
    subdomain: pluginRepo.subdomain,
    releases: pluginRepo.releases.map(function (release) {
      return {
        release: release.release,
        metadata: release.metadata,
        builds: release.builds.map(function (build) {
          return {
            build: build.build,
            metadata: build.metadata
          };
        })
      };
    }),
    current: {
      build: {
        metadata: buildMetadata,
        // the subgraph returns only one build ordered by build number
        // in descending order, this means it's the latest build
        number: (_pluginRepo$releases = pluginRepo.releases) == null || (_pluginRepo$releases = _pluginRepo$releases[0]) == null || (_pluginRepo$releases = _pluginRepo$releases.builds) == null || (_pluginRepo$releases = _pluginRepo$releases[0]) == null ? void 0 : _pluginRepo$releases.build
      },
      release: {
        metadata: releaseMetadata,
        // the subgraph returns only one release ordered by release number
        // in descending order, this means it's the latest release
        number: (_pluginRepo$releases2 = pluginRepo.releases) == null || (_pluginRepo$releases2 = _pluginRepo$releases2[0]) == null ? void 0 : _pluginRepo$releases2.release
      }
    }
  };
}
function applyInstallatonParamsToContract(params) {
  return {
    plugin: params.pluginAddress,
    pluginSetupRef: {
      pluginSetupRepo: params.pluginRepo,
      versionTag: params.versionTag
    },
    helpersHash: keccak256(defaultAbiCoder.encode(["address[]"], [params.helpers])),
    permissions: params.permissions.map(function (permission) {
      return _extends({}, permission, {
        condition: permission.condition || AddressZero
      });
    })
  };
}
function applyUninstallationParamsToContract(params) {
  return {
    plugin: params.pluginAddress,
    pluginSetupRef: {
      pluginSetupRepo: params.pluginRepo,
      versionTag: params.versionTag
    },
    permissions: params.permissions.map(function (permission) {
      return _extends({}, permission, {
        condition: permission.condition || AddressZero
      });
    })
  };
}
function applyInstallatonParamsFromContract$1(result) {
  var params = result[1];
  return {
    helpersHash: params.helpersHash,
    permissions: params.permissions,
    versionTag: params.pluginSetupRef.versionTag,
    pluginAddress: params.plugin,
    pluginRepo: params.pluginSetupRef.pluginSetupRepo
  };
}
function applyUpdateParamsToContract(params) {
  return {
    plugin: params.pluginAddress,
    pluginSetupRef: {
      pluginSetupRepo: params.pluginRepo,
      versionTag: params.versionTag
    },
    initData: params.initData,
    helpersHash: keccak256(defaultAbiCoder.encode(["address[]"], [params.helpers])),
    permissions: params.permissions.map(function (permission) {
      return _extends({}, permission, {
        condition: permission.condition || AddressZero
      });
    })
  };
}
function applyUpdateParamsFromContract(result) {
  var params = result[1];
  return {
    helpersHash: params.helpersHash,
    permissions: params.permissions,
    versionTag: params.pluginSetupRef.versionTag,
    pluginAddress: params.plugin,
    pluginRepo: params.pluginSetupRef.pluginSetupRepo,
    initData: hexToBytes(params.initData)
  };
}
function permissionParamsToContract(params) {
  return [params.where, params.who, keccak256(toUtf8Bytes(params.permission))];
}
function permissionWithConditionParamsToContract(params) {
  return [].concat(permissionParamsToContract({
    who: params.who,
    where: params.where,
    permission: params.permission
  }), [params.condition]);
}
function permissionParamsFromContract(result) {
  var _Object$keys$find;
  return {
    where: result[0],
    who: result[1],
    permissionId: result[2],
    permission: ((_Object$keys$find = Object.keys(PermissionIds).find(function (k) {
      return PermissionIds[k] === result[2];
    })) == null ? void 0 : _Object$keys$find.replace(/_ID$/, "")) || ""
  };
}
function permissionParamsWitConditionFromContract(result) {
  return _extends({}, permissionParamsFromContract(result), {
    condition: result[3]
  });
}
function withdrawParamsFromContract(to, _value, result, tokenStandard, isBatch) {
  switch (tokenStandard) {
    case TokenType.ERC20:
      return {
        type: TokenType.ERC20,
        tokenAddress: to,
        recipientAddressOrEns: result[0],
        amount: BigInt(result[1])
      };
    case TokenType.ERC721:
      return {
        type: TokenType.ERC721,
        tokenAddress: to,
        recipientAddressOrEns: result[1],
        tokenId: BigInt(result[2]),
        daoAddressOrEns: result[0]
      };
    case TokenType.ERC1155:
      var tokenIds, amounts;
      if (isBatch) {
        tokenIds = result[2].map(function (id) {
          return BigInt(id);
        });
        amounts = result[3].map(function (amount) {
          return BigInt(amount);
        });
      } else {
        tokenIds = [BigInt(result[2])];
        amounts = [BigInt(result[3])];
      }
      return {
        type: TokenType.ERC1155,
        tokenAddress: to,
        recipientAddressOrEns: result[1],
        tokenIds: tokenIds,
        amounts: amounts,
        daoAddressOrEns: result[0]
      };
  }
  throw new NotImplementedError("Token standard not supported");
}
function estimateNativeDeposit(_x, _x2) {
  return _estimateNativeDeposit.apply(this, arguments);
}
function _estimateNativeDeposit() {
  _estimateNativeDeposit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(signer, params) {
    var daoInstance;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return DepositEthSchema.strict().validate(params);
        case 2:
          daoInstance = DAO__factory.connect(params.daoAddressOrEns, signer);
          _context.next = 5;
          return daoInstance.estimateGas.deposit(AddressZero, params.amount, "");
        case 5:
          return _context.abrupt("return", _context.sent);
        case 6:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _estimateNativeDeposit.apply(this, arguments);
}
function estimateErc20Deposit(_x3, _x4) {
  return _estimateErc20Deposit.apply(this, arguments);
}
function _estimateErc20Deposit() {
  _estimateErc20Deposit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(signer, params) {
    var daoInstance;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return DepositErc20Schema.strict().validate(params);
        case 2:
          daoInstance = DAO__factory.connect(params.daoAddressOrEns, signer);
          _context2.next = 5;
          return daoInstance.estimateGas.deposit(params.tokenAddress, params.amount, "");
        case 5:
          return _context2.abrupt("return", _context2.sent);
        case 6:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _estimateErc20Deposit.apply(this, arguments);
}
function estimateErc721Deposit(_x5, _x6) {
  return _estimateErc721Deposit.apply(this, arguments);
}
function _estimateErc721Deposit() {
  _estimateErc721Deposit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(signer, params) {
    var erc721Contract;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return DepositErc721Schema.strict().validate(params);
        case 2:
          erc721Contract = new Contract(params.tokenAddress, abi$1, signer);
          _context3.t0 = erc721Contract.estimateGas;
          _context3.next = 6;
          return signer.getAddress();
        case 6:
          _context3.t1 = _context3.sent;
          _context3.t2 = params.daoAddressOrEns;
          _context3.t3 = params.tokenId;
          return _context3.abrupt("return", _context3.t0["safeTransferFrom(address,address,uint256)"].call(_context3.t0, _context3.t1, _context3.t2, _context3.t3));
        case 10:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _estimateErc721Deposit.apply(this, arguments);
}
function estimateErc1155Deposit(_x7, _x8) {
  return _estimateErc1155Deposit.apply(this, arguments);
}
function _estimateErc1155Deposit() {
  _estimateErc1155Deposit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(signer, params) {
    var erc1155Contract, estimation;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.next = 2;
          return DepositErc1155Schema.strict().validate(params);
        case 2:
          erc1155Contract = new Contract(params.tokenAddress, abi$2, signer);
          if (!(params.tokenIds.length === 1)) {
            _context4.next = 17;
            break;
          }
          _context4.t0 = erc1155Contract.estimateGas;
          _context4.next = 7;
          return signer.getAddress();
        case 7:
          _context4.t1 = _context4.sent;
          _context4.t2 = params.daoAddressOrEns;
          _context4.t3 = params.tokenIds[0];
          _context4.t4 = params.amounts[0];
          _context4.t5 = new Uint8Array(0);
          _context4.next = 14;
          return _context4.t0["safeTransferFrom(address,address,uint256,uint256,bytes)"].call(_context4.t0, _context4.t1, _context4.t2, _context4.t3, _context4.t4, _context4.t5);
        case 14:
          estimation = _context4.sent;
          _context4.next = 28;
          break;
        case 17:
          _context4.t6 = erc1155Contract.estimateGas;
          _context4.next = 20;
          return signer.getAddress();
        case 20:
          _context4.t7 = _context4.sent;
          _context4.t8 = params.daoAddressOrEns;
          _context4.t9 = params.tokenIds;
          _context4.t10 = params.amounts;
          _context4.t11 = new Uint8Array(0);
          _context4.next = 27;
          return _context4.t6["safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"].call(_context4.t6, _context4.t7, _context4.t8, _context4.t9, _context4.t10, _context4.t11);
        case 27:
          estimation = _context4.sent;
        case 28:
          return _context4.abrupt("return", estimation);
        case 29:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _estimateErc1155Deposit.apply(this, arguments);
}
function decodeGrantAction(data) {
  var daoInterface = DAO__factory.createInterface();
  var hexBytes = bytesToHex(data);
  var expectedFunction = daoInterface.getFunction("grant");
  var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
  return permissionParamsFromContract(result);
}
function decodeRevokeAction(data) {
  var daoInterface = DAO__factory.createInterface();
  var hexBytes = bytesToHex(data);
  var expectedFunction = daoInterface.getFunction("revoke");
  var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
  return permissionParamsFromContract(result);
}
function decodeApplyUpdateAction(data) {
  var pspInterface = PluginSetupProcessor__factory.createInterface();
  var hexBytes = bytesToHex(data);
  var expectedFunction = pspInterface.getFunction("applyUpdate");
  var result = pspInterface.decodeFunctionData(expectedFunction, hexBytes);
  return applyUpdateParamsFromContract(result);
}
function findInterface(data, functionSignatures) {
  try {
    var func = getFunctionFragment(data, functionSignatures);
    return {
      id: func.format("minimal"),
      functionName: func.name,
      hash: bytesToHex(data).substring(0, 10)
    };
  } catch (_unused) {
    return null;
  }
}
function toDaoActions(actions) {
  return actions.map(function (action) {
    return {
      to: action.to,
      value: BigInt(action.value),
      data: hexToBytes(action.data)
    };
  });
}
function hashPermissions(permissions) {
  return keccak256(defaultAbiCoder.encode(["tuple(uint8,address,address,address,bytes32)[]"], [permissions]));
}
function getPreparedSetupId(params, preparationType) {
  return keccak256(defaultAbiCoder.encode(["tuple(uint8, uint16)", "address", "bytes32", "bytes32", "bytes32", "uint8"], [[params.versionTag.release, params.versionTag.build], params.pluginRepo, hashPermissions(params.permissions), params.helpersHash, keccak256(new Uint8Array()),
  // there is no data so we pass an empty uint8Array
  preparationType]));
}
function decodeUpgradeToAndCallAction(data) {
  var daoInterface = DAO__factory.createInterface();
  var hexBytes = bytesToHex(data);
  var expectedFunction = daoInterface.getFunction("upgradeToAndCall");
  var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
  return {
    implementationAddress: result[0],
    data: hexToBytes(result[1])
  };
}
function decodeUpgradeToAction(data) {
  var daoInterface = DAO__factory.createInterface();
  var hexBytes = bytesToHex(data);
  var expectedFunction = daoInterface.getFunction("upgradeTo");
  var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
  return result[0];
}
function decodeInitializeFromAction(data) {
  var daoInterface = DAO__factory.createInterface();
  var hexBytes = bytesToHex(data);
  var expectedFunction = daoInterface.getFunction("initializeFrom");
  var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
  return {
    previousVersion: result[0],
    initData: hexToBytes(result[1])
  };
}
function toPluginPreparationListItem(pluginPreparation) {
  return {
    id: pluginPreparation.id,
    type: pluginPreparation.type,
    creator: pluginPreparation.creator,
    dao: pluginPreparation.dao.id,
    pluginRepo: pluginPreparation.pluginRepo,
    versionTag: {
      build: pluginPreparation.pluginVersion.build,
      release: pluginPreparation.pluginVersion.release.release
    },
    pluginAddress: pluginPreparation.pluginAddress,
    permissions: pluginPreparation.permissions.map(function (permission) {
      return {
        id: permission.id,
        operation: toPluginPermissionOperationType(permission.operation),
        who: permission.who,
        where: permission.where,
        condition: permission.condition,
        permissionId: permission.permissionId
      };
    }),
    helpers: pluginPreparation.helpers,
    data: hexToBytes(pluginPreparation.data)
  };
}
function toPluginPermissionOperationType(operation) {
  switch (operation) {
    case SubgraphPluginPermissionOperation.GRANT:
      return PermissionOperationType.GRANT;
    case SubgraphPluginPermissionOperation.REVOKE:
      return PermissionOperationType.REVOKE;
    case SubgraphPluginPermissionOperation.GRANT_WITH_CONDITION:
      return PermissionOperationType.GRANT_WITH_CONDITION;
    default:
      throw new InvalidPermissionOperationType();
  }
}
// function that compares 2 generic arrays
// and returns true if they are equal
// and false if they are not
function compareArrays(array1, array2) {
  return JSON.stringify(array1) === JSON.stringify(array2);
}
function getPluginInstallations(_x9, _x10, _x11) {
  return _getPluginInstallations.apply(this, arguments);
}
function _getPluginInstallations() {
  _getPluginInstallations = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(daoAddress, pluginAddress, graphql) {
    var name, query, params, res, pluginInstallations;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          name = "pluginInstallations";
          query = QueryPluginInstallations;
          params = {
            where: {
              plugin: pluginAddress.toLowerCase(),
              dao: daoAddress.toLowerCase()
            }
          };
          _context5.next = 5;
          return graphql.request({
            query: query,
            params: params,
            name: name
          });
        case 5:
          res = _context5.sent;
          pluginInstallations = res.pluginInstallations;
          return _context5.abrupt("return", pluginInstallations);
        case 8:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  }));
  return _getPluginInstallations.apply(this, arguments);
}
function validateGrantUpgradePluginPermissionAction(_x12, _x13, _x14, _x15) {
  return _validateGrantUpgradePluginPermissionAction.apply(this, arguments);
}
function _validateGrantUpgradePluginPermissionAction() {
  _validateGrantUpgradePluginPermissionAction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(action, pspAddress, daoAddress, graphql) {
    var causes, decodedPermission, pluginInstallations;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          causes = []; // decode the action
          decodedPermission = decodeGrantAction(action.data); // retrieve the plugin installations from subgraph
          // with the same plugin address and the specified
          // dao address
          _context6.next = 4;
          return getPluginInstallations(daoAddress, decodedPermission.where, graphql);
        case 4:
          pluginInstallations = _context6.sent;
          // if the plugin installations length is 0 means that
          // that the address in the where field is not a plugin
          // or is not installed in the specified dao
          if (pluginInstallations.length === 0) {
            causes.push(PluginUpdateProposalInValidityCause.PLUGIN_NOT_INSTALLED);
          }
          // Value must be 0
          if (action.value.toString() !== "0") {
            causes.push(PluginUpdateProposalInValidityCause.NON_ZERO_GRANT_UPGRADE_PLUGIN_PERMISSION_CALL_VALUE);
          }
          // The action should be sent to the DAO
          if (action.to !== daoAddress) {
            causes.push(PluginUpdateProposalInValidityCause.INVALID_GRANT_UPGRADE_PLUGIN_PERMISSION_TO_ADDRESS);
          }
          // The permission should be granted to the PSP
          if (decodedPermission.who !== pspAddress) {
            causes.push(PluginUpdateProposalInValidityCause.INVALID_GRANT_UPGRADE_PLUGIN_PERMISSION_WHO_ADDRESS);
          }
          // The permission should be `UPGRADE_PLUGIN_PERMISSION`
          if (decodedPermission.permission !== Permissions.UPGRADE_PLUGIN_PERMISSION) {
            causes.push(PluginUpdateProposalInValidityCause.INVALID_GRANT_UPGRADE_PLUGIN_PERMISSION_PERMISSION_NAME);
          }
          // The permissionId should be `UPGRADE_PLUGIN_PERMISSION_ID`
          if (decodedPermission.permissionId !== PermissionIds.UPGRADE_PLUGIN_PERMISSION_ID) {
            causes.push(PluginUpdateProposalInValidityCause.INVALID_GRANT_UPGRADE_PLUGIN_PERMISSION_PERMISSION_ID);
          }
          return _context6.abrupt("return", causes);
        case 12:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _validateGrantUpgradePluginPermissionAction.apply(this, arguments);
}
function validateRevokeUpgradePluginPermissionAction(_x16, _x17, _x18, _x19) {
  return _validateRevokeUpgradePluginPermissionAction.apply(this, arguments);
}
function _validateRevokeUpgradePluginPermissionAction() {
  _validateRevokeUpgradePluginPermissionAction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(action, pspAddress, daoAddress, graphql) {
    var causes, decodedPermission, pluginInstallations;
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          causes = [];
          decodedPermission = decodeRevokeAction(action.data);
          _context7.next = 4;
          return getPluginInstallations(daoAddress, decodedPermission.where, graphql);
        case 4:
          pluginInstallations = _context7.sent;
          if (pluginInstallations.length === 0) {
            causes.push(PluginUpdateProposalInValidityCause.PLUGIN_NOT_INSTALLED);
          }
          // The action should be sent to the DAO
          if (action.to !== daoAddress) {
            causes.push(PluginUpdateProposalInValidityCause.INVALID_REVOKE_UPGRADE_PLUGIN_PERMISSION_TO_ADDRESS);
          }
          if (action.value.toString() !== "0") {
            causes.push(PluginUpdateProposalInValidityCause.NON_ZERO_REVOKE_UPGRADE_PLUGIN_PERMISSION_CALL_VALUE);
          }
          if (decodedPermission.who !== pspAddress) {
            causes.push(PluginUpdateProposalInValidityCause.INVALID_REVOKE_UPGRADE_PLUGIN_PERMISSION_WHO_ADDRESS);
          }
          if (decodedPermission.permission !== Permissions.UPGRADE_PLUGIN_PERMISSION) {
            causes.push(PluginUpdateProposalInValidityCause.INVALID_REVOKE_UPGRADE_PLUGIN_PERMISSION_PERMISSION_NAME);
          }
          if (decodedPermission.permissionId !== PermissionIds.UPGRADE_PLUGIN_PERMISSION_ID) {
            causes.push(PluginUpdateProposalInValidityCause.INVALID_REVOKE_UPGRADE_PLUGIN_PERMISSION_PERMISSION_ID);
          }
          return _context7.abrupt("return", causes);
        case 12:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  }));
  return _validateRevokeUpgradePluginPermissionAction.apply(this, arguments);
}
function validateGrantRootPermissionAction(action, daoAddress, pspAddress) {
  var causes = [];
  var decodedPermission = decodeGrantAction(action.data);
  if (action.value.toString() !== "0") {
    causes.push(PluginUpdateProposalInValidityCause.NON_ZERO_GRANT_ROOT_PERMISSION_CALL_VALUE);
  }
  // The action should be sent to the DAO
  // both come from subgraph so they are already lowercase
  if (action.to !== daoAddress) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_GRANT_ROOT_PERMISSION_TO_ADDRESS);
  }
  // decodedPermission.where is checksummed so we need to lowercase it
  // to compare it with the daoAddress because it comes from the subgraph
  if (decodedPermission.where.toLowerCase() !== daoAddress) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_GRANT_ROOT_PERMISSION_WHERE_ADDRESS);
  }
  if (decodedPermission.who !== pspAddress) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_GRANT_ROOT_PERMISSION_WHO_ADDRESS);
  }
  if (decodedPermission.permission !== Permissions.ROOT_PERMISSION) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_GRANT_ROOT_PERMISSION_PERMISSION_NAME);
  }
  if (decodedPermission.permissionId !== PermissionIds.ROOT_PERMISSION_ID) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_GRANT_ROOT_PERMISSION_PERMISSION_ID);
  }
  return causes;
}
function validateRevokeRootPermissionAction(action, daoAddress, pspAddress) {
  var causes = [];
  var decodedPermission = decodeRevokeAction(action.data);
  if (action.value.toString() !== "0") {
    causes.push(PluginUpdateProposalInValidityCause.NON_ZERO_REVOKE_ROOT_PERMISSION_CALL_VALUE);
  }
  // The action should be sent to the DAO
  if (action.to !== daoAddress) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_REVOKE_ROOT_PERMISSION_TO_ADDRESS);
  }
  if (decodedPermission.where !== daoAddress) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_REVOKE_ROOT_PERMISSION_WHERE_ADDRESS);
  }
  if (decodedPermission.who !== pspAddress) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_REVOKE_ROOT_PERMISSION_WHO_ADDRESS);
  }
  if (decodedPermission.permission !== Permissions.ROOT_PERMISSION) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_REVOKE_ROOT_PERMISSION_PERMISSION_NAME);
  }
  if (decodedPermission.permissionId !== PermissionIds.ROOT_PERMISSION_ID) {
    causes.push(PluginUpdateProposalInValidityCause.INVALID_REVOKE_ROOT_PERMISSION_PERMISSION_ID);
  }
  return causes;
}
/**
 * Validate a plugin update proposal
 *
 * @export
 * @param {DaoAction} action
 * @param {string} daoAddress
 * @param {IClientGraphQLCore} graphql
 * @param {IClientIpfsCore} ipfs
 * @return {Promise<PluginUpdateProposalInValidityCause[]>}
 */
function validateApplyUpdateFunction(_x20, _x21, _x22, _x23) {
  return _validateApplyUpdateFunction.apply(this, arguments);
}
/**
 * Given a list of actions, it decodes the actions and returns the
 * type of action
 *
 * @export
 * @param {DaoAction[]} actions
 * @return {ProposalActionTypes[]}
 */
function _validateApplyUpdateFunction() {
  _validateApplyUpdateFunction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(action, daoAddress, graphql, ipfs) {
    var _plugin$appliedVersio, _plugin$appliedVersio2, _plugin$appliedVersio3, _metadataJson$pluginS, _plugin$appliedVersio4;
    var causes, decodedParams, _yield$graphql$reques, dao, plugin, _yield$graphql$reques2, pluginRepo, preparedSetupId, _yield$graphql$reques3, pluginPreparations, release, build, metadataUri, metadataCid, metadata, metadataJson, updateAbi, _metadataJson$pluginS2, _plugin$appliedVersio5;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          causes = [];
          if (action.value.toString() !== "0") {
            causes.push(PluginUpdateProposalInValidityCause.NON_ZERO_APPLY_UPDATE_CALL_VALUE);
          }
          decodedParams = decodeApplyUpdateAction(action.data);
          _context8.next = 5;
          return graphql.request({
            query: QueryDao,
            params: {
              address: daoAddress
            },
            name: "dao"
          });
        case 5:
          _yield$graphql$reques = _context8.sent;
          dao = _yield$graphql$reques.dao;
          // find the plugin with the same address
          plugin = dao.plugins.find(function (plugin) {
            var _plugin$appliedPrepar;
            return ((_plugin$appliedPrepar = plugin.appliedPreparation) == null ? void 0 : _plugin$appliedPrepar.pluginAddress) === decodedParams.pluginAddress.toLowerCase();
          });
          if (plugin) {
            _context8.next = 11;
            break;
          }
          causes.push(PluginUpdateProposalInValidityCause.PLUGIN_NOT_INSTALLED);
          return _context8.abrupt("return", causes);
        case 11:
          // check release is the same as the one installed
          if (((_plugin$appliedVersio = plugin.appliedVersion) == null ? void 0 : _plugin$appliedVersio.release.release) !== decodedParams.versionTag.release) {
            causes.push(PluginUpdateProposalInValidityCause.UPDATE_TO_INCOMPATIBLE_RELEASE);
          }
          // check build is higher than the one installed
          if (!((_plugin$appliedVersio2 = plugin.appliedVersion) != null && _plugin$appliedVersio2.build) || ((_plugin$appliedVersio3 = plugin.appliedVersion) == null ? void 0 : _plugin$appliedVersio3.build) >= decodedParams.versionTag.build) {
            causes.push(PluginUpdateProposalInValidityCause.UPDATE_TO_OLDER_OR_SAME_BUILD);
          }
          _context8.next = 15;
          return graphql.request({
            query: QueryPlugin,
            params: {
              id: decodedParams.pluginRepo.toLowerCase()
            },
            name: "pluginRepo"
          });
        case 15:
          _yield$graphql$reques2 = _context8.sent;
          pluginRepo = _yield$graphql$reques2.pluginRepo;
          if (pluginRepo) {
            _context8.next = 20;
            break;
          }
          causes.push(PluginUpdateProposalInValidityCause.MISSING_PLUGIN_REPO);
          return _context8.abrupt("return", causes);
        case 20:
          // check if is one of the aragon plugin repos
          if (!SupportedPluginRepoArray.includes(pluginRepo.subdomain)) {
            causes.push(PluginUpdateProposalInValidityCause.NOT_ARAGON_PLUGIN_REPO);
          }
          // get the prepared setup id
          preparedSetupId = getPreparedSetupId(decodedParams, PreparationType.UPDATE);
          _context8.next = 24;
          return graphql.request({
            query: QueryPluginPreparations,
            params: {
              where: {
                preparedSetupId: preparedSetupId.toLowerCase(),
                pluginAddress: decodedParams.pluginAddress.toLowerCase()
              }
            },
            name: "pluginPreparations"
          });
        case 24:
          _yield$graphql$reques3 = _context8.sent;
          pluginPreparations = _yield$graphql$reques3.pluginPreparations;
          if (pluginPreparations.length) {
            _context8.next = 29;
            break;
          }
          causes.push(PluginUpdateProposalInValidityCause.MISSING_PLUGIN_PREPARATION);
          return _context8.abrupt("return", causes);
        case 29:
          // get the metadata of the plugin repo
          // for the release and build specified
          release = pluginRepo.releases.find(function (release) {
            return release.release === decodedParams.versionTag.release;
          });
          build = release == null ? void 0 : release.builds.find(function (build) {
            return build.build === decodedParams.versionTag.build;
          });
          if (build) {
            _context8.next = 34;
            break;
          }
          causes.push(PluginUpdateProposalInValidityCause.INVALID_PLUGIN_REPO_METADATA);
          return _context8.abrupt("return", causes);
        case 34:
          metadataUri = build.metadata; // fetch the metadata
          metadataCid = new MultiUri(metadataUri).ipfsCid;
          _context8.next = 38;
          return ipfs.fetchString(metadataCid);
        case 38:
          metadata = _context8.sent;
          metadataJson = JSON.parse(metadata); // Due to an human error the build metadata on the plugins
          // was not correct on the first release of the plugin repos
          // this is on chain so we cannot change it and we need to
          // handle it here. So we check if the metadata has the fields
          // for the fixed metadata and if it does not we try with the
          // old metadata fields
          // Original PR: https://github.com/aragon/osx/pull/375
          // Fix PR: https://github.com/aragon/osx/pull/481
          updateAbi = [];
          updateAbi = metadataJson == null || (_metadataJson$pluginS = metadataJson.pluginSetup) == null || (_metadataJson$pluginS = _metadataJson$pluginS.prepareUpdate) == null || (_metadataJson$pluginS = _metadataJson$pluginS[(_plugin$appliedVersio4 = plugin.appliedVersion) == null ? void 0 : _plugin$appliedVersio4.build]) == null ? void 0 : _metadataJson$pluginS.inputs;
          if (!updateAbi) {
            updateAbi = metadataJson == null || (_metadataJson$pluginS2 = metadataJson.pluginSetup) == null || (_metadataJson$pluginS2 = _metadataJson$pluginS2.prepareInstallation) == null || (_metadataJson$pluginS2 = _metadataJson$pluginS2.prepareUpdate) == null || (_metadataJson$pluginS2 = _metadataJson$pluginS2[(_plugin$appliedVersio5 = plugin.appliedVersion) == null ? void 0 : _plugin$appliedVersio5.build]) == null ? void 0 : _metadataJson$pluginS2.inputs;
          }
          // get the update abi for the specified build
          if (!updateAbi) {
            _context8.next = 55;
            break;
          }
          _context8.prev = 44;
          if (!(decodedParams.initData.length > 0 && updateAbi.length === 0)) {
            _context8.next = 47;
            break;
          }
          throw new Error();
        case 47:
          // if the decode does not throw an error the data is valid
          defaultAbiCoder.decode(getNamedTypesFromMetadata(updateAbi), decodedParams.initData);
          _context8.next = 53;
          break;
        case 50:
          _context8.prev = 50;
          _context8.t0 = _context8["catch"](44);
          // if the decode throws an error the data is invalid
          causes.push(PluginUpdateProposalInValidityCause.INVALID_DATA);
        case 53:
          _context8.next = 56;
          break;
        case 55:
          causes.push(PluginUpdateProposalInValidityCause.INVALID_PLUGIN_REPO_METADATA);
        case 56:
          return _context8.abrupt("return", causes);
        case 57:
        case "end":
          return _context8.stop();
      }
    }, _callee8, null, [[44, 50]]);
  }));
  return _validateApplyUpdateFunction.apply(this, arguments);
}
function classifyProposalActions(actions) {
  var classifiedActions = [];
  for (var _iterator2 = _createForOfIteratorHelperLoose(actions), _step2; !(_step2 = _iterator2()).done;) {
    var action = _step2.value;
    try {
      var decodedPermission = void 0;
      var func = getFunctionFragment(action.data, UPDATE_PLUGIN_SIGNATURES);
      switch (func.name) {
        case "upgradeTo":
          classifiedActions.push(ProposalActionTypes.UPGRADE_TO);
          break;
        case "upgradeToAndCall":
          classifiedActions.push(ProposalActionTypes.UPGRADE_TO_AND_CALL);
          break;
        case "grant":
          decodedPermission = decodeGrantAction(action.data);
          // check the permission that is being granted
          switch (decodedPermission.permission) {
            case Permissions.UPGRADE_PLUGIN_PERMISSION:
              classifiedActions.push(ProposalActionTypes.GRANT_PLUGIN_UPGRADE_PERMISSION);
              break;
            case Permissions.ROOT_PERMISSION:
              classifiedActions.push(ProposalActionTypes.GRANT_ROOT_PERMISSION);
              break;
            default:
              classifiedActions.push(ProposalActionTypes.UNKNOWN);
              break;
          }
          break;
        case "revoke":
          decodedPermission = decodeRevokeAction(action.data);
          // check the permission that is being granted
          switch (decodedPermission.permission) {
            case Permissions.UPGRADE_PLUGIN_PERMISSION:
              classifiedActions.push(ProposalActionTypes.REVOKE_PLUGIN_UPGRADE_PERMISSION);
              break;
            case Permissions.ROOT_PERMISSION:
              classifiedActions.push(ProposalActionTypes.REVOKE_ROOT_PERMISSION);
              break;
            default:
              classifiedActions.push(ProposalActionTypes.UNKNOWN);
              break;
          }
          break;
        case "applyUpdate":
          classifiedActions.push(ProposalActionTypes.APPLY_UPDATE);
          break;
        default:
          classifiedActions.push(ProposalActionTypes.ACTION_NOT_ALLOWED);
          break;
      }
    } catch (_unused2) {
      classifiedActions.push(ProposalActionTypes.UNKNOWN);
    }
  }
  return classifiedActions;
}
/**
 * Returns true if the actions are valid for a plugin update proposal with root permission
 *
 * @export
 * @param {ProposalActionTypes[]} actions
 * @return {boolean}
 */
function containsPluginUpdateActionBlockWithRootPermission(actions) {
  // get the first 5 actions
  var receivedPattern = actions.slice(0, 5);
  // check if it matches the expected pattern
  // length should be 5
  return receivedPattern.length === 5 && compareArrays(receivedPattern, PLUGIN_UPDATE_WITH_ROOT_ACTION_PATTERN);
}
/**
 * Returns true if the actions are valid for a plugin update proposal without root permission
 *
 * @export
 * @param {ProposalActionTypes[]} actions
 * @return {boolean}
 */
function containsPluginUpdateActionBlock(actions) {
  // get the first 3 action
  var receivedPattern = actions.slice(0, 3);
  // check if it matches the expected pattern
  // length should be 3
  return receivedPattern.length === 3 && compareArrays(receivedPattern, PLUGIN_UPDATE_ACTION_PATTERN);
}
/**
 * Returns true if the actions are valid for a plugin update proposal
 *
 * @export
 * @param {ProposalActionTypes[]} actions
 * @return {boolean}
 */
function startsWithDaoUpdateAction(actions) {
  // UpgradeTo or UpgradeToAndCall should be the first action
  return actions[0] === ProposalActionTypes.UPGRADE_TO || actions[0] === ProposalActionTypes.UPGRADE_TO_AND_CALL;
}
function validateUpdateDaoProposalActions(actions, daoAddress, expectedImplementationAddress, currentDaoVersion) {
  var classifiedActions = classifyProposalActions(actions);
  var actionErrorCauses = [];
  var proposalSettingsErrorCauses = [];
  // check if the actions are valid
  if (!startsWithDaoUpdateAction(classifiedActions)) {
    // If actions are not valid, add the cause to the causes array
    // and return
    return {
      isValid: false,
      proposalSettingsErrorCauses: [ProposalSettingsErrorCause.INVALID_ACTIONS],
      actionErrorCauses: []
    };
  }
  // if they are valid, this means that
  // the upgrade action must be the first one
  var upgradeActionType = classifiedActions[0];
  var upgradeAction = actions[0];
  // if the to address is not the dao address
  // add the cause to the causes array
  if (upgradeAction.to !== daoAddress) {
    actionErrorCauses.push(DaoUpdateProposalInvalidityCause.INVALID_TO_ADDRESS);
  }
  // if the value is different from 0
  // add the cause to the causes array
  if (upgradeAction.value.toString() !== "0") {
    actionErrorCauses.push(DaoUpdateProposalInvalidityCause.NON_ZERO_CALL_VALUE);
  }
  switch (upgradeActionType) {
    case ProposalActionTypes.UPGRADE_TO:
      // decode the upgradeTo action
      var decodedImplementationAddress = decodeUpgradeToAction(actions[0].data);
      // check that the implementation address is the same
      if (expectedImplementationAddress !== decodedImplementationAddress) {
        actionErrorCauses.push(DaoUpdateProposalInvalidityCause.INVALID_UPGRADE_TO_IMPLEMENTATION_ADDRESS);
      }
      break;
    case ProposalActionTypes.UPGRADE_TO_AND_CALL:
      // decode the action
      var upgradeToAndCallDecodedParams = decodeUpgradeToAndCallAction(actions[0].data);
      // the call data should be the initializeFrom function encoded
      // so we decode the initialize from function
      var initializeFromDecodedParams = decodeInitializeFromAction(upgradeToAndCallDecodedParams.data);
      // check that the implementation address is the same as specified
      // in the upgradeToAndCall action
      if (expectedImplementationAddress !== upgradeToAndCallDecodedParams.implementationAddress) {
        actionErrorCauses.push(DaoUpdateProposalInvalidityCause.INVALID_UPGRADE_TO_AND_CALL_IMPLEMENTATION_ADDRESS);
      }
      // check that the current version version of the dao is the same
      // as the one specified as previous version in the initializeFrom function
      if (JSON.stringify(initializeFromDecodedParams.previousVersion) !== JSON.stringify(currentDaoVersion)) {
        actionErrorCauses.push(DaoUpdateProposalInvalidityCause.INVALID_UPGRADE_TO_AND_CALL_VERSION);
      }
      // For now, we check that the `bytes calldata _initData` parameter of the `initializeFrom` function call is empty (because updates related to 1.0.0, 1.3.0, or 1.4.0 don't require `_initData`).
      // TODO For future upgrade requiring non-empty `_initData`, we must define a place to obtain this information from permissionlessly.
      if (initializeFromDecodedParams.initData.length !== 0) {
        actionErrorCauses.push(DaoUpdateProposalInvalidityCause.INVALID_UPGRADE_TO_AND_CALL_DATA);
      }
      break;
    default:
      proposalSettingsErrorCauses.push(ProposalSettingsErrorCause.INVALID_ACTIONS);
      break;
  }
  // return the validity of the proposal
  return {
    isValid: actionErrorCauses.length === 0 && proposalSettingsErrorCauses.length === 0,
    actionErrorCauses: actionErrorCauses,
    proposalSettingsErrorCauses: proposalSettingsErrorCauses
  };
}
function validateUpdatePluginProposalActions(_x24, _x25, _x26, _x27, _x28) {
  return _validateUpdatePluginProposalActions.apply(this, arguments);
}
function _validateUpdatePluginProposalActions() {
  _validateUpdatePluginProposalActions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(actions, daoAddress, pspAddress, graphql, ipfs) {
    var actionErrorCauses, resCauses, proposalSettingsErrorCauses, classifiedActions, _iterator3, _step3, _step3$value, index, action, recCauses, _iterator4, _step4, _step4$value, _index, _action, _recCauses;
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          // Declare variables
          actionErrorCauses = [];
          proposalSettingsErrorCauses = [];
          classifiedActions = classifyProposalActions(actions); // check if is an update plugin proposal
          if (!containsPluginUpdateActionBlock(classifiedActions)) {
            _context9.next = 36;
            break;
          }
          // initialize the causes array
          // we always use the index 0
          // because this is going to be called recursively
          // and then joined
          actionErrorCauses[0] = [];
          // iterate over the first 3 actions actions
          _iterator3 = _createForOfIteratorHelperLoose(classifiedActions.slice(0, 3).entries());
        case 6:
          if ((_step3 = _iterator3()).done) {
            _context9.next = 28;
            break;
          }
          _step3$value = _step3.value, index = _step3$value[0], action = _step3$value[1];
          _context9.t0 = action;
          _context9.next = _context9.t0 === ProposalActionTypes.GRANT_PLUGIN_UPGRADE_PERMISSION ? 11 : _context9.t0 === ProposalActionTypes.REVOKE_PLUGIN_UPGRADE_PERMISSION ? 16 : _context9.t0 === ProposalActionTypes.APPLY_UPDATE ? 21 : 26;
          break;
        case 11:
          _context9.next = 13;
          return validateGrantUpgradePluginPermissionAction(actions[index], pspAddress, daoAddress, graphql);
        case 13:
          resCauses = _context9.sent;
          actionErrorCauses[0] = [].concat(actionErrorCauses[0], resCauses);
          return _context9.abrupt("break", 26);
        case 16:
          _context9.next = 18;
          return validateRevokeUpgradePluginPermissionAction(actions[index], pspAddress, daoAddress, graphql);
        case 18:
          resCauses = _context9.sent;
          actionErrorCauses[0] = [].concat(actionErrorCauses[0], resCauses);
          return _context9.abrupt("break", 26);
        case 21:
          _context9.next = 23;
          return validateApplyUpdateFunction(actions[index], daoAddress, graphql, ipfs);
        case 23:
          resCauses = _context9.sent;
          actionErrorCauses[0] = [].concat(actionErrorCauses[0], resCauses);
          return _context9.abrupt("break", 26);
        case 26:
          _context9.next = 6;
          break;
        case 28:
          // slice the first 3 actions
          // because they have already been validated
          // and recursively call the function
          actions = actions.slice(3);
          if (!(actions.length !== 0)) {
            _context9.next = 35;
            break;
          }
          _context9.next = 32;
          return validateUpdatePluginProposalActions(actions, daoAddress, pspAddress, graphql, ipfs);
        case 32:
          recCauses = _context9.sent;
          // join the causes
          actionErrorCauses = [].concat(actionErrorCauses, recCauses.actionErrorCauses);
          proposalSettingsErrorCauses = [].concat(proposalSettingsErrorCauses, recCauses.proposalSettingsErrorCauses);
        case 35:
          return _context9.abrupt("return", {
            // every item in the array should be empty
            isValid: actionErrorCauses.every(function (cause) {
              return cause.length === 0;
            }) && proposalSettingsErrorCauses.length === 0,
            actionErrorCauses: actionErrorCauses,
            proposalSettingsErrorCauses: proposalSettingsErrorCauses
          });
        case 36:
          if (!containsPluginUpdateActionBlockWithRootPermission(classifiedActions)) {
            _context9.next = 75;
            break;
          }
          // initialize the causes array
          // we always use the index 0
          // because this is going to be called recursively
          // and then joined
          actionErrorCauses[0] = [];
          // iterate over the first 5 actions actions
          _iterator4 = _createForOfIteratorHelperLoose(classifiedActions.slice(0, 5).entries());
        case 39:
          if ((_step4 = _iterator4()).done) {
            _context9.next = 67;
            break;
          }
          _step4$value = _step4.value, _index = _step4$value[0], _action = _step4$value[1];
          _context9.t1 = _action;
          _context9.next = _context9.t1 === ProposalActionTypes.GRANT_PLUGIN_UPGRADE_PERMISSION ? 44 : _context9.t1 === ProposalActionTypes.REVOKE_PLUGIN_UPGRADE_PERMISSION ? 49 : _context9.t1 === ProposalActionTypes.GRANT_ROOT_PERMISSION ? 54 : _context9.t1 === ProposalActionTypes.REVOKE_ROOT_PERMISSION ? 57 : _context9.t1 === ProposalActionTypes.APPLY_UPDATE ? 60 : 65;
          break;
        case 44:
          _context9.next = 46;
          return validateGrantUpgradePluginPermissionAction(actions[_index], pspAddress, daoAddress, graphql);
        case 46:
          resCauses = _context9.sent;
          actionErrorCauses[0] = [].concat(actionErrorCauses[0], resCauses);
          return _context9.abrupt("break", 65);
        case 49:
          _context9.next = 51;
          return validateRevokeUpgradePluginPermissionAction(actions[_index], pspAddress, daoAddress, graphql);
        case 51:
          resCauses = _context9.sent;
          actionErrorCauses[0] = [].concat(actionErrorCauses[0], resCauses);
          return _context9.abrupt("break", 65);
        case 54:
          resCauses = validateGrantRootPermissionAction(actions[_index], daoAddress, pspAddress);
          actionErrorCauses[0] = [].concat(actionErrorCauses[0], resCauses);
          return _context9.abrupt("break", 65);
        case 57:
          resCauses = validateRevokeRootPermissionAction(actions[_index], daoAddress, pspAddress);
          actionErrorCauses[0] = [].concat(actionErrorCauses[0], resCauses);
          return _context9.abrupt("break", 65);
        case 60:
          _context9.next = 62;
          return validateApplyUpdateFunction(actions[_index], daoAddress, graphql, ipfs);
        case 62:
          resCauses = _context9.sent;
          actionErrorCauses[0] = [].concat(actionErrorCauses[0], resCauses);
          return _context9.abrupt("break", 65);
        case 65:
          _context9.next = 39;
          break;
        case 67:
          // slice the first 5 actions
          // because they have already been validated
          actions = actions.slice(5);
          if (!(actions.length !== 0)) {
            _context9.next = 74;
            break;
          }
          _context9.next = 71;
          return validateUpdatePluginProposalActions(actions, daoAddress, pspAddress, graphql, ipfs);
        case 71:
          _recCauses = _context9.sent;
          // join the causes
          actionErrorCauses = [].concat(actionErrorCauses, _recCauses.actionErrorCauses);
          proposalSettingsErrorCauses = [].concat(proposalSettingsErrorCauses, _recCauses.proposalSettingsErrorCauses);
        case 74:
          return _context9.abrupt("return", {
            // every item in the array should be empty
            isValid: actionErrorCauses.every(function (cause) {
              return cause.length === 0;
            }) && proposalSettingsErrorCauses.length === 0,
            actionErrorCauses: actionErrorCauses,
            proposalSettingsErrorCauses: proposalSettingsErrorCauses
          });
        case 75:
          return _context9.abrupt("return", {
            isValid: false,
            proposalSettingsErrorCauses: [ProposalSettingsErrorCause.INVALID_ACTIONS],
            actionErrorCauses: actionErrorCauses
          });
        case 76:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  }));
  return _validateUpdatePluginProposalActions.apply(this, arguments);
}

/**
 * Methods module the SDK Generic Client
 */
var ClientMethods = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(ClientMethods, _ClientCore);
  function ClientMethods() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = ClientMethods.prototype;
  _proto.prepareInstallation = function prepareInstallation(params) {
    var _this = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return _awaitAsyncGenerator(PrepareInstallationSchema.strict().validate(params));
          case 2:
            return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(prepareGenericInstallation(_this.web3, _extends({}, params, {
              pluginSetupProcessorAddress: _this.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR)
            })))), "t0", 3);
          case 3:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  }
  /**
   * Creates a DAO with the given settings and plugins
      * @param {CreateDaoParams} params
   * @return {AsyncGenerator<DaoCreationStepValue>}
   * @memberof ClientMethods
   */;
  _proto.createDao = function createDao(params) {
    var _this2 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var _params$ensSubdomain, _params$daoUri, _params$trustedForwar, _receipt$logs, _receipt$logs2;
      var signer, daoFactoryInstance, pluginInstallationData, _iterator, _step, plugin, repo, currentRelease, latestVersion, pluginSetupProcessorAddr, pluginSetupProcessor, execPermissionFound, daoBaseAddr, _i, _pluginInstallationDa, installData, pluginSetupProcessorResponse, found, tx, receipt, daoFactoryInterface, log, pspInterface, installedLogs, parsedLog;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return _awaitAsyncGenerator(CreateDaoSchema.strict().validate(params));
          case 2:
            signer = _this2.web3.getConnectedSigner();
            daoFactoryInstance = DAOFactory__factory.connect(_this2.web3.getAddress(FrameworkContractsNames.DAO_FACTORY), signer);
            pluginInstallationData = [];
            _iterator = _createForOfIteratorHelperLoose(params.plugins);
          case 6:
            if ((_step = _iterator()).done) {
              _context2.next = 18;
              break;
            }
            plugin = _step.value;
            repo = PluginRepo__factory.connect(plugin.id, signer);
            _context2.next = 11;
            return _awaitAsyncGenerator(repo.latestRelease());
          case 11:
            currentRelease = _context2.sent;
            _context2.next = 14;
            return _awaitAsyncGenerator(repo["getLatestVersion(uint8)"](currentRelease));
          case 14:
            latestVersion = _context2.sent;
            pluginInstallationData.push({
              pluginSetupRef: {
                pluginSetupRepo: repo.address,
                versionTag: latestVersion.tag
              },
              data: plugin.data
            });
          case 16:
            _context2.next = 6;
            break;
          case 18:
            _context2.next = 20;
            return _awaitAsyncGenerator(daoFactoryInstance.pluginSetupProcessor());
          case 20:
            pluginSetupProcessorAddr = _context2.sent;
            pluginSetupProcessor = PluginSetupProcessor__factory.connect(pluginSetupProcessorAddr, signer);
            execPermissionFound = false; // using the DAO base because it reflects a newly created DAO the best
            _context2.next = 25;
            return _awaitAsyncGenerator(daoFactoryInstance.daoBase());
          case 25:
            daoBaseAddr = _context2.sent;
            _i = 0, _pluginInstallationDa = pluginInstallationData;
          case 27:
            if (!(_i < _pluginInstallationDa.length)) {
              _context2.next = 39;
              break;
            }
            installData = _pluginInstallationDa[_i];
            _context2.next = 31;
            return _awaitAsyncGenerator(pluginSetupProcessor.callStatic.prepareInstallation(daoBaseAddr, installData));
          case 31:
            pluginSetupProcessorResponse = _context2.sent;
            found = pluginSetupProcessorResponse[1].permissions.find(function (permission) {
              return permission.permissionId === PermissionIds.EXECUTE_PERMISSION_ID;
            });
            if (!found) {
              _context2.next = 36;
              break;
            }
            execPermissionFound = true;
            return _context2.abrupt("break", 39);
          case 36:
            _i++;
            _context2.next = 27;
            break;
          case 39:
            if (execPermissionFound) {
              _context2.next = 41;
              break;
            }
            throw new MissingExecPermissionError();
          case 41:
            _context2.next = 43;
            return _awaitAsyncGenerator(daoFactoryInstance.connect(signer).createDao({
              subdomain: (_params$ensSubdomain = params.ensSubdomain) != null ? _params$ensSubdomain : "",
              metadata: toUtf8Bytes(params.metadataUri),
              daoURI: (_params$daoUri = params.daoUri) != null ? _params$daoUri : "",
              trustedForwarder: (_params$trustedForwar = params.trustedForwarder) != null ? _params$trustedForwar : AddressZero
            }, pluginInstallationData));
          case 43:
            tx = _context2.sent;
            _context2.next = 46;
            return {
              key: DaoCreationSteps.CREATING,
              txHash: tx.hash
            };
          case 46:
            _context2.next = 48;
            return _awaitAsyncGenerator(tx.wait());
          case 48:
            receipt = _context2.sent;
            daoFactoryInterface = DAORegistry__factory.createInterface(); // find dao address using the dao registry address
            log = (_receipt$logs = receipt.logs) == null ? void 0 : _receipt$logs.find(function (e) {
              return e.topics[0] === id(daoFactoryInterface.getEvent("DAORegistered").format("sighash"));
            });
            if (log) {
              _context2.next = 53;
              break;
            }
            throw new DaoCreationError();
          case 53:
            // Plugin logs
            pspInterface = PluginSetupProcessor__factory.createInterface();
            installedLogs = (_receipt$logs2 = receipt.logs) == null ? void 0 : _receipt$logs2.filter(function (e) {
              return e.topics[0] === id(pspInterface.getEvent("InstallationApplied").format("sighash"));
            }); // DAO logs
            parsedLog = daoFactoryInterface.parseLog(log);
            if (parsedLog.args["dao"]) {
              _context2.next = 58;
              break;
            }
            throw new DaoCreationError();
          case 58:
            _context2.next = 60;
            return {
              key: DaoCreationSteps.DONE,
              address: parsedLog.args["dao"],
              pluginAddresses: installedLogs.map(function (log) {
                return pspInterface.parseLog(log).args[1];
              })
            };
          case 60:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }))();
  }
  /**
   * Pins a metadata object into IPFS and retruns the generated hash
   *
   * @param {DaoMetadata} params
   * @return {Promise<string>}
   * @memberof ClientMethods
   */;
  _proto.pinMetadata =
  /*#__PURE__*/
  function () {
    var _pinMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {
      var cid;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return DaoMetadataSchema.strict().validate(params);
          case 2:
            _context3.prev = 2;
            _context3.next = 5;
            return this.ipfs.add(JSON.stringify(params));
          case 5:
            cid = _context3.sent;
            _context3.next = 8;
            return this.ipfs.pin(cid);
          case 8:
            return _context3.abrupt("return", "ipfs://" + cid);
          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](2);
            throw new IpfsPinError(_context3.t0);
          case 14:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this, [[2, 11]]);
    }));
    function pinMetadata(_x) {
      return _pinMetadata.apply(this, arguments);
    }
    return pinMetadata;
  }()
  /**
   * Deposits ether or an ERC20 token into the DAO
   *
   * @param {DepositParams} params
   * @return {AsyncGenerator<DaoDepositStepValue>}
   * @memberof ClientMethods
   */
  ;
  _proto.deposit = function deposit(params) {
    var _this3 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.t0 = params.type;
            _context4.next = _context4.t0 === TokenType.NATIVE ? 3 : _context4.t0 === TokenType.ERC20 ? 5 : _context4.t0 === TokenType.ERC721 ? 7 : _context4.t0 === TokenType.ERC1155 ? 9 : 11;
            break;
          case 3:
            return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this3.depositNative(params))), "t1", 4);
          case 4:
            return _context4.abrupt("break", 12);
          case 5:
            return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this3.depositErc20(params))), "t2", 6);
          case 6:
            return _context4.abrupt("break", 12);
          case 7:
            return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this3.depositErc721(params))), "t3", 8);
          case 8:
            return _context4.abrupt("break", 12);
          case 9:
            return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this3.depositErc1155(params))), "t4", 10);
          case 10:
            return _context4.abrupt("break", 12);
          case 11:
            throw new NotImplementedError("Token type not valid, use transfer function instead");
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }))();
  };
  _proto.depositNative = function depositNative(params) {
    var _this4 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var signer, daoAddressOrEns, amount, override, daoInstance, tx, cr, log, daoInterface, parsedLog;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return _awaitAsyncGenerator(DepositEthSchema.strict().validate(params));
          case 2:
            signer = _this4.web3.getConnectedSigner();
            daoAddressOrEns = params.daoAddressOrEns, amount = params.amount;
            override = {
              value: params.amount
            };
            daoInstance = DAO__factory.connect(daoAddressOrEns, signer);
            _context5.next = 8;
            return _awaitAsyncGenerator(daoInstance.deposit(AddressZero, amount, "", override));
          case 8:
            tx = _context5.sent;
            _context5.next = 11;
            return {
              key: DaoDepositSteps.DEPOSITING,
              txHash: tx.hash
            };
          case 11:
            _context5.next = 13;
            return _awaitAsyncGenerator(tx.wait());
          case 13:
            cr = _context5.sent;
            log = findLog(cr, daoInstance["interface"], "Deposited");
            if (log) {
              _context5.next = 17;
              break;
            }
            throw new FailedDepositError();
          case 17:
            daoInterface = DAO__factory.createInterface();
            parsedLog = daoInterface.parseLog(log);
            if (!(!amount.toString() === parsedLog.args["amount"])) {
              _context5.next = 21;
              break;
            }
            throw new AmountMismatchError(amount, parsedLog.args["amount"].toBigInt());
          case 21:
            _context5.next = 23;
            return {
              key: DaoDepositSteps.DONE,
              amount: amount
            };
          case 23:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }))();
  };
  _proto.depositErc20 = function depositErc20(params) {
    var _this5 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var signer, tokenAddress, daoAddressOrEns, amount, tokenContract, currentAllowance, daoInstance, tx, cr, log, daoInterface, parsedLog;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return _awaitAsyncGenerator(DepositErc20Schema.strict().validate(params));
          case 2:
            signer = _this5.web3.getConnectedSigner();
            tokenAddress = params.tokenAddress, daoAddressOrEns = params.daoAddressOrEns, amount = params.amount; // check current allowance
            tokenContract = new Contract(tokenAddress, abi, signer);
            _context6.t0 = _awaitAsyncGenerator;
            _context6.t1 = tokenContract;
            _context6.next = 9;
            return _awaitAsyncGenerator(signer.getAddress());
          case 9:
            _context6.t2 = _context6.sent;
            _context6.t3 = daoAddressOrEns;
            _context6.t4 = _context6.t1.allowance.call(_context6.t1, _context6.t2, _context6.t3);
            _context6.next = 14;
            return (0, _context6.t0)(_context6.t4);
          case 14:
            currentAllowance = _context6.sent;
            _context6.next = 17;
            return {
              key: DaoDepositSteps.CHECKED_ALLOWANCE,
              allowance: currentAllowance.toBigInt()
            };
          case 17:
            if (!currentAllowance.lt(params.amount)) {
              _context6.next = 19;
              break;
            }
            return _context6.delegateYield(_asyncGeneratorDelegate(_asyncIterator(_this5.setAllowance({
              amount: params.amount,
              spender: params.daoAddressOrEns,
              tokenAddress: params.tokenAddress
            }))), "t5", 19);
          case 19:
            // Doing the transfer
            daoInstance = DAO__factory.connect(daoAddressOrEns, signer);
            _context6.next = 22;
            return _awaitAsyncGenerator(daoInstance.deposit(tokenAddress, amount, ""));
          case 22:
            tx = _context6.sent;
            _context6.next = 25;
            return {
              key: DaoDepositSteps.DEPOSITING,
              txHash: tx.hash
            };
          case 25:
            _context6.next = 27;
            return _awaitAsyncGenerator(tx.wait());
          case 27:
            cr = _context6.sent;
            log = findLog(cr, daoInstance["interface"], "Deposited");
            if (log) {
              _context6.next = 31;
              break;
            }
            throw new FailedDepositError();
          case 31:
            daoInterface = DAO__factory.createInterface();
            parsedLog = daoInterface.parseLog(log);
            if (!(!amount.toString() === parsedLog.args["amount"])) {
              _context6.next = 35;
              break;
            }
            throw new AmountMismatchError(amount, parsedLog.args["amount"].toBigInt());
          case 35:
            _context6.next = 37;
            return {
              key: DaoDepositSteps.DONE,
              amount: amount
            };
          case 37:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }))();
  };
  _proto.depositErc721 = function depositErc721(params) {
    var _this6 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var signer, erc721Contract, tx, cr, log, parsedLog;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return _awaitAsyncGenerator(DepositErc721Schema.strict().validate(params));
          case 2:
            signer = _this6.web3.getConnectedSigner();
            erc721Contract = new Contract(params.tokenAddress, abi$1, signer);
            _context7.t0 = _awaitAsyncGenerator;
            _context7.t1 = erc721Contract;
            _context7.next = 8;
            return _awaitAsyncGenerator(signer.getAddress());
          case 8:
            _context7.t2 = _context7.sent;
            _context7.t3 = params.daoAddressOrEns;
            _context7.t4 = params.tokenId;
            _context7.t5 = _context7.t1["safeTransferFrom(address,address,uint256)"].call(_context7.t1, _context7.t2, _context7.t3, _context7.t4);
            _context7.next = 14;
            return (0, _context7.t0)(_context7.t5);
          case 14:
            tx = _context7.sent;
            _context7.next = 17;
            return _awaitAsyncGenerator(tx.wait());
          case 17:
            cr = _context7.sent;
            log = findLog(cr, erc721Contract["interface"], "Transfer");
            if (log) {
              _context7.next = 21;
              break;
            }
            throw new FailedDepositError();
          case 21:
            parsedLog = erc721Contract["interface"].parseLog(log);
            if (!(!parsedLog.args["tokenId"] || parsedLog.args["tokenId"].toString() !== params.tokenId.toString())) {
              _context7.next = 24;
              break;
            }
            throw new FailedDepositError();
          case 24:
            _context7.next = 26;
            return {
              key: DaoDepositSteps.DONE,
              tokenId: params.tokenId
            };
          case 26:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }))();
  };
  _proto.depositErc1155 = function depositErc1155(params) {
    var _this7 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var signer, erc1155Contract, tx, logName, logArg, cr, log, parsedLog;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return _awaitAsyncGenerator(DepositErc1155Schema.strict().validate(params));
          case 2:
            signer = _this7.web3.getConnectedSigner();
            erc1155Contract = new Contract(params.tokenAddress, abi$2, signer);
            if (!(params.tokenIds.length === 1)) {
              _context8.next = 22;
              break;
            }
            _context8.t0 = _awaitAsyncGenerator;
            _context8.t1 = erc1155Contract;
            _context8.next = 9;
            return _awaitAsyncGenerator(signer.getAddress());
          case 9:
            _context8.t2 = _context8.sent;
            _context8.t3 = params.daoAddressOrEns;
            _context8.t4 = params.tokenIds[0];
            _context8.t5 = params.amounts[0];
            _context8.t6 = new Uint8Array([]);
            _context8.t7 = _context8.t1["safeTransferFrom(address,address,uint256,uint256,bytes)"].call(_context8.t1, _context8.t2, _context8.t3, _context8.t4, _context8.t5, _context8.t6);
            _context8.next = 17;
            return (0, _context8.t0)(_context8.t7);
          case 17:
            tx = _context8.sent;
            logName = "TransferSingle";
            logArg = "id";
            _context8.next = 37;
            break;
          case 22:
            _context8.t8 = _awaitAsyncGenerator;
            _context8.t9 = erc1155Contract;
            _context8.next = 26;
            return _awaitAsyncGenerator(signer.getAddress());
          case 26:
            _context8.t10 = _context8.sent;
            _context8.t11 = params.daoAddressOrEns;
            _context8.t12 = params.tokenIds;
            _context8.t13 = params.amounts;
            _context8.t14 = new Uint8Array([]);
            _context8.t15 = _context8.t9["safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"].call(_context8.t9, _context8.t10, _context8.t11, _context8.t12, _context8.t13, _context8.t14);
            _context8.next = 34;
            return (0, _context8.t8)(_context8.t15);
          case 34:
            tx = _context8.sent;
            logName = "TransferBatch";
            logArg = "ids";
          case 37:
            _context8.next = 39;
            return _awaitAsyncGenerator(tx.wait());
          case 39:
            cr = _context8.sent;
            log = findLog(cr, erc1155Contract["interface"], logName);
            if (log) {
              _context8.next = 43;
              break;
            }
            throw new FailedDepositError();
          case 43:
            parsedLog = erc1155Contract["interface"].parseLog(log);
            if (!(!parsedLog.args[logArg] || parsedLog.args[logArg].toString() !== params.tokenIds.toString())) {
              _context8.next = 46;
              break;
            }
            throw new FailedDepositError();
          case 46:
            _context8.next = 48;
            return {
              key: DaoDepositSteps.DONE,
              tokenIds: params.tokenIds,
              amounts: params.amounts
            };
          case 48:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }))();
  }
  /**
   * Checks if the allowance is enough and updates it
   *
   * @param {SetAllowanceParams} params
   * @return {AsyncGenerator<SetAllowanceStepValue>}
   * @memberof ClientMethods
   */;
  _proto.setAllowance = function setAllowance(params) {
    var _this8 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      var signer, tokenInstance, tx, cr, log, value;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            signer = _this8.web3.getConnectedSigner(); // TODO
            // add params check with yup
            tokenInstance = new Contract(params.tokenAddress, abi, signer);
            _context9.next = 4;
            return _awaitAsyncGenerator(tokenInstance.approve(params.spender, params.amount));
          case 4:
            tx = _context9.sent;
            _context9.next = 7;
            return {
              key: SetAllowanceSteps.SETTING_ALLOWANCE,
              txHash: tx.hash
            };
          case 7:
            _context9.next = 9;
            return _awaitAsyncGenerator(tx.wait());
          case 9:
            cr = _context9.sent;
            log = findLog(cr, tokenInstance["interface"], "Approval");
            if (log) {
              _context9.next = 13;
              break;
            }
            throw new UpdateAllowanceError();
          case 13:
            value = log.data;
            if (!(!value || BigNumber.from(params.amount).gt(BigNumber.from(value)))) {
              _context9.next = 16;
              break;
            }
            throw new UpdateAllowanceError();
          case 16:
            _context9.next = 18;
            return {
              key: SetAllowanceSteps.ALLOWANCE_SET,
              allowance: params.amount
            };
          case 18:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }))();
  }
  /**
   * Prepare uninstallation of a plugin
   *
   * @param {PrepareUninstallationParams} params
   * @return {AsyncGenerator<PrepareUninstallationStepValue>}
   * @memberof ClientMethods
   */;
  _proto.prepareUninstallation = function prepareUninstallation(params) {
    var _this9 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      var signer, _yield$_awaitAsyncGen, iplugin, _params$pluginInstall, pluginInstallationIndex, selectedInstallation, _params$uninstallatio, uninstallationParams, _params$uninstallatio2, uninstallationAbi, data, pspContract, tx, cr, log, parsedLog, permissions;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return _awaitAsyncGenerator(PrepareUninstallationSchema.strict().validate(params));
          case 2:
            signer = _this9.web3.getConnectedSigner();
            _context10.next = 5;
            return _awaitAsyncGenerator(_this9.graphql.request({
              query: QueryIPlugin,
              params: {
                address: params.pluginAddress.toLowerCase(),
                where: {
                  dao: params.daoAddressOrEns.toLowerCase()
                }
              },
              name: "plugin"
            }));
          case 5:
            _yield$_awaitAsyncGen = _context10.sent;
            iplugin = _yield$_awaitAsyncGen.iplugin;
            // filter specified installation
            _params$pluginInstall = params.pluginInstallationIndex, pluginInstallationIndex = _params$pluginInstall === void 0 ? 0 : _params$pluginInstall;
            selectedInstallation = iplugin.installations[pluginInstallationIndex];
            if (selectedInstallation) {
              _context10.next = 11;
              break;
            }
            throw new InstallationNotFoundError();
          case 11:
            // encode uninstallation params
            _params$uninstallatio = params.uninstallationParams, uninstallationParams = _params$uninstallatio === void 0 ? [] : _params$uninstallatio, _params$uninstallatio2 = params.uninstallationAbi, uninstallationAbi = _params$uninstallatio2 === void 0 ? [] : _params$uninstallatio2;
            data = defaultAbiCoder.encode(uninstallationAbi, uninstallationParams); // connect to psp contract
            pspContract = PluginSetupProcessor__factory.connect(_this9.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR), signer);
            _context10.next = 16;
            return _awaitAsyncGenerator(pspContract.prepareUninstallation(params.daoAddressOrEns, {
              pluginSetupRef: {
                pluginSetupRepo: selectedInstallation.appliedPreparation.pluginRepo.id,
                versionTag: {
                  build: selectedInstallation.appliedVersion.build,
                  release: selectedInstallation.appliedVersion.release.release
                }
              },
              setupPayload: {
                plugin: params.pluginAddress,
                currentHelpers: selectedInstallation.appliedPreparation.helpers,
                data: data
              }
            }));
          case 16:
            tx = _context10.sent;
            _context10.next = 19;
            return {
              key: PrepareUninstallationSteps.PREPARING,
              txHash: tx.hash
            };
          case 19:
            _context10.next = 21;
            return _awaitAsyncGenerator(tx.wait());
          case 21:
            cr = _context10.sent;
            log = findLog(cr, pspContract["interface"], "UninstallationPrepared");
            if (log) {
              _context10.next = 25;
              break;
            }
            throw new PluginUninstallationPreparationError();
          case 25:
            parsedLog = pspContract["interface"].parseLog(log);
            permissions = parsedLog.args["permissions"];
            if (permissions) {
              _context10.next = 29;
              break;
            }
            throw new PluginUninstallationPreparationError();
          case 29:
            _context10.next = 31;
            return {
              key: PrepareUninstallationSteps.DONE,
              permissions: permissions.map(function (permission) {
                return {
                  operation: permission.operation,
                  where: permission.where,
                  who: permission.who,
                  permissionId: permission.permissionId
                };
              }),
              pluginRepo: selectedInstallation.appliedPreparation.pluginRepo.id,
              pluginAddress: params.pluginAddress,
              versionTag: {
                build: selectedInstallation.appliedVersion.build,
                release: selectedInstallation.appliedVersion.release.release
              }
            };
          case 31:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }))();
  }
  /**
   * Prepare update of a plugin
   *
   * @param {PrepareUpdateParams} params
   * @return {AsyncGenerator<PrepareUpdateStepValue>}
   * @memberof ClientMethods
   */;
  _proto.prepareUpdate = function prepareUpdate(params) {
    var _this10 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            return _context11.delegateYield(_asyncGeneratorDelegate(_asyncIterator(prepareGenericUpdate(_this10.web3, _this10.graphql, _extends({}, params, {
              pluginSetupProcessorAddress: _this10.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR)
            })))), "t0", 1);
          case 1:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    }))();
  }
  /**
   * Checks whether a role is granted by the current DAO's ACL settings
   *
   * @param {HasPermissionParams} params
   * @return {Promise<boolean>}
   * @memberof ClientMethods
   */;
  _proto.hasPermission =
  /*#__PURE__*/
  function () {
    var _hasPermission = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(params) {
      var provider, daoInstance;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            _context12.next = 2;
            return HasPermissionSchema.strict().validate(params);
          case 2:
            provider = this.web3.getProvider(); // connect to the managing dao
            daoInstance = DAO__factory.connect(params.daoAddressOrEns, provider);
            return _context12.abrupt("return", daoInstance.hasPermission(params.where, params.who, id(params.permission), params.data || new Uint8Array([])));
          case 5:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this);
    }));
    function hasPermission(_x2) {
      return _hasPermission.apply(this, arguments);
    }
    return hasPermission;
  }()
  /**
   * Retrieves metadata for DAO with given identifier (address or ens domain)
   *
   * @param {string} daoAddressOrEns
   * @return {(Promise<DaoDetails | null>)}
   * @memberof ClientMethods
   */
  ;
  _proto.getDao =
  /*#__PURE__*/
  function () {
    var _getDao = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(daoAddressOrEns) {
      var address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r, dao, metadataCid, metadataString, metadata;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            _context13.next = 2;
            return AddressOrEnsSchema.strict().validate(daoAddressOrEns);
          case 2:
            address = daoAddressOrEns.toLowerCase();
            if (isAddress(address)) {
              _context13.next = 21;
              break;
            }
            _context13.next = 6;
            return this.web3.ensureOnline();
          case 6:
            provider = this.web3.getProvider();
            if (provider) {
              _context13.next = 9;
              break;
            }
            throw new NoProviderError();
          case 9:
            _context13.prev = 9;
            _context13.next = 12;
            return provider.resolveName(address);
          case 12:
            resolvedAddress = _context13.sent;
            if (resolvedAddress) {
              _context13.next = 15;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 15:
            address = resolvedAddress.toLowerCase();
            _context13.next = 21;
            break;
          case 18:
            _context13.prev = 18;
            _context13.t0 = _context13["catch"](9);
            throw new InvalidAddressOrEnsError(_context13.t0);
          case 21:
            query = QueryDao;
            params = {
              address: address
            };
            name = "DAO";
            _context13.next = 26;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 26:
            _yield$this$graphql$r = _context13.sent;
            dao = _yield$this$graphql$r.dao;
            if (dao) {
              _context13.next = 32;
              break;
            }
            return _context13.abrupt("return", null);
          case 32:
            if (dao.metadata) {
              _context13.next = 34;
              break;
            }
            return _context13.abrupt("return", toDaoDetails(dao, EMPTY_DAO_METADATA_LINK));
          case 34:
            _context13.prev = 34;
            metadataCid = resolveIpfsCid(dao.metadata);
            _context13.next = 38;
            return this.ipfs.fetchString(metadataCid);
          case 38:
            metadataString = _context13.sent;
            metadata = JSON.parse(metadataString);
            return _context13.abrupt("return", toDaoDetails(dao, metadata));
          case 43:
            _context13.prev = 43;
            _context13.t1 = _context13["catch"](34);
            if (!(_context13.t1 instanceof InvalidCidError)) {
              _context13.next = 47;
              break;
            }
            return _context13.abrupt("return", toDaoDetails(dao, UNSUPPORTED_DAO_METADATA_LINK));
          case 47:
            return _context13.abrupt("return", toDaoDetails(dao, UNAVAILABLE_DAO_METADATA));
          case 48:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this, [[9, 18], [34, 43]]);
    }));
    function getDao(_x3) {
      return _getDao.apply(this, arguments);
    }
    return getDao;
  }()
  /**
   * Retrieves metadata for DAO with given identifier (address or ens domain)
   *
   * @param {DaoQueryParams} params
   *     - limit = 10
   *     - skip = 0
   *     - direction = SortDirection.ASC
   *     - sortBy = DaoSortBy.CREATED_AT
   * @return {Promise<DaoListItem[]>}
   * @memberof ClientMethods
   */
  ;
  _proto.getDaos =
  /*#__PURE__*/
  function () {
    var _getDaos = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(_ref) {
      var _this11 = this;
      var _ref$limit, limit, _ref$skip, skip, _ref$direction, direction, _ref$sortBy, sortBy, query, params, name, _yield$this$graphql$r2, daos;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 10 : _ref$limit, _ref$skip = _ref.skip, skip = _ref$skip === void 0 ? 0 : _ref$skip, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? SortDirection.ASC : _ref$direction, _ref$sortBy = _ref.sortBy, sortBy = _ref$sortBy === void 0 ? DaoSortBy.CREATED_AT : _ref$sortBy;
            _context15.next = 3;
            return DaoQuerySchema.strict().validate({
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            });
          case 3:
            query = QueryDaos;
            params = {
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "DAOs";
            _context15.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r2 = _context15.sent;
            daos = _yield$this$graphql$r2.daos;
            return _context15.abrupt("return", Promise.all(daos.map( /*#__PURE__*/function () {
              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(dao) {
                var metadataCid, stringMetadata, metadata;
                return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                  while (1) switch (_context14.prev = _context14.next) {
                    case 0:
                      if (dao.metadata) {
                        _context14.next = 2;
                        break;
                      }
                      return _context14.abrupt("return", toDaoListItem(dao, EMPTY_DAO_METADATA_LINK));
                    case 2:
                      _context14.prev = 2;
                      metadataCid = resolveIpfsCid(dao.metadata); // Avoid blocking Promise.all if this individual fetch takes too long
                      _context14.next = 6;
                      return promiseWithTimeout(_this11.ipfs.fetchString(metadataCid), MULTI_FETCH_TIMEOUT);
                    case 6:
                      stringMetadata = _context14.sent;
                      metadata = JSON.parse(stringMetadata);
                      return _context14.abrupt("return", toDaoListItem(dao, metadata));
                    case 11:
                      _context14.prev = 11;
                      _context14.t0 = _context14["catch"](2);
                      if (!(_context14.t0 instanceof InvalidCidError)) {
                        _context14.next = 15;
                        break;
                      }
                      return _context14.abrupt("return", toDaoListItem(dao, UNSUPPORTED_DAO_METADATA_LINK));
                    case 15:
                      return _context14.abrupt("return", toDaoListItem(dao, UNAVAILABLE_DAO_METADATA));
                    case 16:
                    case "end":
                      return _context14.stop();
                  }
                }, _callee14, null, [[2, 11]]);
              }));
              return function (_x5) {
                return _ref2.apply(this, arguments);
              };
            }())));
          case 11:
          case "end":
            return _context15.stop();
        }
      }, _callee15, this);
    }));
    function getDaos(_x4) {
      return _getDaos.apply(this, arguments);
    }
    return getDaos;
  }()
  /**
   * Retrieves the asset balances of the given DAO, by default, ETH, DAI, USDC and USDT on Mainnet
   *
   * @param {DaoBalancesQueryParams} params
   *     - daoAddressOrEns
   *     - limit = 10
   *     - skip = 0
   *     - direction = SortDirection.ASC
   *     - sortBy = AssetBalanceSortBy.LAST_UPDATED
   * @return {(Promise<AssetBalance[] | null>)}
   * @memberof ClientMethods
   */
  ;
  _proto.getDaoBalances =
  /*#__PURE__*/
  function () {
    var _getDaoBalances = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(_ref3) {
      var daoAddressOrEns, _ref3$limit, limit, _ref3$skip, skip, _ref3$direction, direction, _ref3$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r3, tokenBalances;
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            daoAddressOrEns = _ref3.daoAddressOrEns, _ref3$limit = _ref3.limit, limit = _ref3$limit === void 0 ? 10 : _ref3$limit, _ref3$skip = _ref3.skip, skip = _ref3$skip === void 0 ? 0 : _ref3$skip, _ref3$direction = _ref3.direction, direction = _ref3$direction === void 0 ? SortDirection.ASC : _ref3$direction, _ref3$sortBy = _ref3.sortBy, sortBy = _ref3$sortBy === void 0 ? AssetBalanceSortBy.LAST_UPDATED : _ref3$sortBy;
            _context16.next = 3;
            return DaoBalancesQuerySchema.strict().validate({
              daoAddressOrEns: daoAddressOrEns,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            });
          case 3:
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context16.next = 19;
              break;
            }
            if (isAddress(address)) {
              _context16.next = 18;
              break;
            }
            _context16.next = 9;
            return this.web3.ensureOnline();
          case 9:
            provider = this.web3.getProvider();
            if (provider) {
              _context16.next = 12;
              break;
            }
            throw new NoProviderError();
          case 12:
            _context16.next = 14;
            return provider.resolveName(address);
          case 14:
            resolvedAddress = _context16.sent;
            if (resolvedAddress) {
              _context16.next = 17;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 17:
            address = resolvedAddress;
          case 18:
            where = {
              dao: address.toLowerCase()
            };
          case 19:
            query = QueryTokenBalances;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "dao balances";
            _context16.next = 24;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 24:
            _yield$this$graphql$r3 = _context16.sent;
            tokenBalances = _yield$this$graphql$r3.tokenBalances;
            if (!(tokenBalances.length === 0)) {
              _context16.next = 28;
              break;
            }
            return _context16.abrupt("return", []);
          case 28:
            return _context16.abrupt("return", tokenBalances.map(function (balance) {
              return toAssetBalance(balance);
            }));
          case 29:
          case "end":
            return _context16.stop();
        }
      }, _callee16, this);
    }));
    function getDaoBalances(_x6) {
      return _getDaoBalances.apply(this, arguments);
    }
    return getDaoBalances;
  }()
  /**
   * Retrieves the list of asset transfers to and from the given DAO (by default, from ETH, DAI, USDC and USDT, on Mainnet)
   *
   * @param {TransferQueryParams} params
   *     - daoAddressOrEns
   *     - type
   *     - limit = 10
   *     - skip = 0
   *     - direction = SortDirection.ASC
   *     - sortBy = TransferSortBy.CREATED_AT
   * @return {(Promise<Transfer[] | null>)}
   * @memberof ClientMethods
   */
  ;
  _proto.getDaoTransfers =
  /*#__PURE__*/
  function () {
    var _getDaoTransfers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(_ref4) {
      var daoAddressOrEns, type, _ref4$limit, limit, _ref4$skip, skip, _ref4$direction, direction, _ref4$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r4, tokenTransfers;
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            daoAddressOrEns = _ref4.daoAddressOrEns, type = _ref4.type, _ref4$limit = _ref4.limit, limit = _ref4$limit === void 0 ? 10 : _ref4$limit, _ref4$skip = _ref4.skip, skip = _ref4$skip === void 0 ? 0 : _ref4$skip, _ref4$direction = _ref4.direction, direction = _ref4$direction === void 0 ? SortDirection.ASC : _ref4$direction, _ref4$sortBy = _ref4.sortBy, sortBy = _ref4$sortBy === void 0 ? TransferSortBy.CREATED_AT : _ref4$sortBy;
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context17.next = 23;
              break;
            }
            if (isAddress(address)) {
              _context17.next = 22;
              break;
            }
            _context17.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context17.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context17.prev = 10;
            _context17.next = 13;
            return provider.resolveName(address);
          case 13:
            resolvedAddress = _context17.sent;
            if (resolvedAddress) {
              _context17.next = 16;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 16:
            address = resolvedAddress;
            _context17.next = 22;
            break;
          case 19:
            _context17.prev = 19;
            _context17.t0 = _context17["catch"](10);
            throw new InvalidAddressOrEnsError(_context17.t0);
          case 22:
            where = {
              dao: address.toLowerCase()
            };
          case 23:
            if (type) {
              where = _extends({}, where, {
                type: SubgraphTransferTypeMap.get(type)
              });
            }
            query = QueryTokenTransfers;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "dao transfers";
            _context17.next = 29;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 29:
            _yield$this$graphql$r4 = _context17.sent;
            tokenTransfers = _yield$this$graphql$r4.tokenTransfers;
            if (tokenTransfers) {
              _context17.next = 33;
              break;
            }
            return _context17.abrupt("return", null);
          case 33:
            return _context17.abrupt("return", tokenTransfers.map(function (transfer) {
              return toTokenTransfer(transfer);
            }));
          case 34:
          case "end":
            return _context17.stop();
        }
      }, _callee17, this, [[10, 19]]);
    }));
    function getDaoTransfers(_x7) {
      return _getDaoTransfers.apply(this, arguments);
    }
    return getDaoTransfers;
  }();
  _proto.getMetadata = /*#__PURE__*/function () {
    var _getMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(ipfsUri) {
      var metadataCid, stringMetadata, resolvedMetadata;
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            metadataCid = resolveIpfsCid(ipfsUri);
            _context18.next = 3;
            return this.ipfs.fetchString(metadataCid);
          case 3:
            stringMetadata = _context18.sent;
            resolvedMetadata = JSON.parse(stringMetadata);
            return _context18.abrupt("return", resolvedMetadata);
          case 6:
          case "end":
            return _context18.stop();
        }
      }, _callee18, this);
    }));
    function getMetadata(_x8) {
      return _getMetadata.apply(this, arguments);
    }
    return getMetadata;
  }();
  _proto.getPluginRepo = /*#__PURE__*/function () {
    var _getPluginRepo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(pluginRepo, inlcudeMetadata) {
      var _pluginRepo$releases$, _pluginRepo$releases$2;
      var releaseMetadata, releaseIpfsUri, buildMetadata, buildIpfsUri;
      return _regeneratorRuntime().wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            if (inlcudeMetadata) {
              _context19.next = 2;
              break;
            }
            return _context19.abrupt("return", toPluginRepo(pluginRepo, EMPTY_RELEASE_METADATA_LINK, EMPTY_BUILD_METADATA_LINK));
          case 2:
            // releases are ordered son the index 0 will be the latest
            releaseIpfsUri = pluginRepo == null || (_pluginRepo$releases$ = pluginRepo.releases[0]) == null ? void 0 : _pluginRepo$releases$.metadata;
            _context19.prev = 3;
            _context19.next = 6;
            return this.getMetadata(releaseIpfsUri);
          case 6:
            releaseMetadata = _context19.sent;
            _context19.next = 13;
            break;
          case 9:
            _context19.prev = 9;
            _context19.t0 = _context19["catch"](3);
            releaseMetadata = UNAVAILABLE_RELEASE_METADATA;
            if (_context19.t0 instanceof InvalidCidError) {
              releaseMetadata = UNSUPPORTED_RELEASE_METADATA_LINK;
            } else if (_context19.t0 instanceof EmptyMultiUriError) {
              releaseMetadata = EMPTY_RELEASE_METADATA_LINK;
            }
          case 13:
            // builds are ordered son the index 0 will be the latest
            buildIpfsUri = pluginRepo == null || (_pluginRepo$releases$2 = pluginRepo.releases[0]) == null || (_pluginRepo$releases$2 = _pluginRepo$releases$2.builds[0]) == null ? void 0 : _pluginRepo$releases$2.metadata;
            _context19.prev = 14;
            _context19.next = 17;
            return this.getMetadata(buildIpfsUri);
          case 17:
            buildMetadata = _context19.sent;
            _context19.next = 24;
            break;
          case 20:
            _context19.prev = 20;
            _context19.t1 = _context19["catch"](14);
            buildMetadata = UNAVAILABLE_BUILD_METADATA;
            if (_context19.t1 instanceof InvalidCidError) {
              buildMetadata = UNSUPPORTED_BUILD_METADATA_LINK;
            } else if (_context19.t1 instanceof EmptyMultiUriError) {
              buildMetadata = EMPTY_BUILD_METADATA_LINK;
            }
          case 24:
            return _context19.abrupt("return", toPluginRepo(pluginRepo, releaseMetadata, buildMetadata));
          case 25:
          case "end":
            return _context19.stop();
        }
      }, _callee19, this, [[3, 9], [14, 20]]);
    }));
    function getPluginRepo(_x9, _x10) {
      return _getPluginRepo.apply(this, arguments);
    }
    return getPluginRepo;
  }()
  /**
   * Retrieves the list of plugins available on the PluginRegistry
   *
   * @param {PluginQueryParams} params
   *     - limit = 10
   *     - skip = 0
   *     - direction = SortDirection.ASC
   *     - sortBy = PluginSortBy.SUBDOMAIN
   *     - subdomain
   * @param {boolean} [includeMetadata=true]
   * @return {(Promise<PluginRepo[] | null>)}
   * @memberof ClientMethods
   */
  ;
  _proto.getPlugins =
  /*#__PURE__*/
  function () {
    var _getPlugins = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(_temp) {
      var _this12 = this;
      var _ref5, _ref5$limit, limit, _ref5$skip, skip, _ref5$direction, direction, _ref5$sortBy, sortBy, subdomain, _ref5$includeMetadata, includeMetadata, where, query, params, name, _yield$this$graphql$r5, pluginRepos;
      return _regeneratorRuntime().wrap(function _callee20$(_context20) {
        while (1) switch (_context20.prev = _context20.next) {
          case 0:
            _ref5 = _temp === void 0 ? {} : _temp, _ref5$limit = _ref5.limit, limit = _ref5$limit === void 0 ? 10 : _ref5$limit, _ref5$skip = _ref5.skip, skip = _ref5$skip === void 0 ? 0 : _ref5$skip, _ref5$direction = _ref5.direction, direction = _ref5$direction === void 0 ? SortDirection.ASC : _ref5$direction, _ref5$sortBy = _ref5.sortBy, sortBy = _ref5$sortBy === void 0 ? PluginSortBy.SUBDOMAIN : _ref5$sortBy, subdomain = _ref5.subdomain, _ref5$includeMetadata = _ref5.includeMetadata, includeMetadata = _ref5$includeMetadata === void 0 ? true : _ref5$includeMetadata;
            _context20.next = 3;
            return PluginQuerySchema.strict().validate({
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy,
              subdomain: subdomain
            });
          case 3:
            where = {};
            if (subdomain) {
              where = {
                subdomain_contains_nocase: subdomain
              };
            }
            query = QueryPlugins;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "plugin repos";
            _context20.next = 10;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 10:
            _yield$this$graphql$r5 = _context20.sent;
            pluginRepos = _yield$this$graphql$r5.pluginRepos;
            return _context20.abrupt("return", Promise.all(pluginRepos.map(function (pluginRepo) {
              return _this12.getPluginRepo(pluginRepo, includeMetadata);
            })));
          case 13:
          case "end":
            return _context20.stop();
        }
      }, _callee20, this);
    }));
    function getPlugins(_x11) {
      return _getPlugins.apply(this, arguments);
    }
    return getPlugins;
  }()
  /**
   * Get plugin details given an address, release and build
   *
   * @param {string} pluginAddress
   * @param {boolean} [includeMetadata=true]
   * @return {Promise<PluginRepo>}
   * @memberof ClientMethods
   */
  ;
  _proto.getPlugin =
  /*#__PURE__*/
  function () {
    var _getPlugin = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(pluginAddress, includeMetadata) {
      var name, query, _yield$this$graphql$r6, pluginRepo;
      return _regeneratorRuntime().wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            if (includeMetadata === void 0) {
              includeMetadata = true;
            }
            _context21.next = 3;
            return AddressOrEnsSchema.strict().validate(pluginAddress);
          case 3:
            name = "plugin version";
            query = QueryPlugin;
            _context21.next = 7;
            return this.graphql.request({
              query: query,
              params: {
                id: pluginAddress.toLowerCase()
              },
              name: name
            });
          case 7:
            _yield$this$graphql$r6 = _context21.sent;
            pluginRepo = _yield$this$graphql$r6.pluginRepo;
            return _context21.abrupt("return", this.getPluginRepo(pluginRepo, includeMetadata));
          case 10:
          case "end":
            return _context21.stop();
        }
      }, _callee21, this);
    }));
    function getPlugin(_x12, _x13) {
      return _getPlugin.apply(this, arguments);
    }
    return getPlugin;
  }()
  /**
   * Returns the protocol version of a contract
   * if the transaction fails returns [1,0,0]
   *
   * @param {string} contractAddress
   * @return {Promise<number[]>}
   * @memberof ClientMethods
   */
  ;
  _proto.getProtocolVersion =
  /*#__PURE__*/
  function () {
    var _getProtocolVersion = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(contractAddress) {
      var provider, protocolInstance, version;
      return _regeneratorRuntime().wrap(function _callee22$(_context22) {
        while (1) switch (_context22.prev = _context22.next) {
          case 0:
            _context22.next = 2;
            return AddressOrEnsSchema.strict().validate(contractAddress);
          case 2:
            provider = this.web3.getProvider();
            protocolInstance = IProtocolVersion__factory.connect(contractAddress, provider);
            _context22.prev = 4;
            _context22.next = 7;
            return protocolInstance.protocolVersion();
          case 7:
            version = _context22.sent;
            _context22.next = 13;
            break;
          case 10:
            _context22.prev = 10;
            _context22.t0 = _context22["catch"](4);
            // ethers5 throws an call exception error which could mean a lot of things
            // so this is not accurate
            version = [1, 0, 0];
          case 13:
            return _context22.abrupt("return", version);
          case 14:
          case "end":
            return _context22.stop();
        }
      }, _callee22, this, [[4, 10]]);
    }));
    function getProtocolVersion(_x14) {
      return _getProtocolVersion.apply(this, arguments);
    }
    return getProtocolVersion;
  }()
  /**
   * Given a proposal id returns if that proposal is a dao update proposal
   *
   * @param {string} proposalId
   * @return {Promise<boolean>}
   * @memberof ClientMethods
   */
  ;
  _proto.isDaoUpdateProposal =
  /*#__PURE__*/
  function () {
    var _isDaoUpdateProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(proposalId) {
      var name, query, _yield$this$graphql$r7, iproposal, subgraphActions, actions, classifiedActions;
      return _regeneratorRuntime().wrap(function _callee23$(_context23) {
        while (1) switch (_context23.prev = _context23.next) {
          case 0:
            name = "iproposal";
            query = QueryIProposal;
            _context23.next = 4;
            return this.graphql.request({
              query: query,
              params: {
                id: getExtendedProposalId(proposalId.toLowerCase())
              },
              name: name
            });
          case 4:
            _yield$this$graphql$r7 = _context23.sent;
            iproposal = _yield$this$graphql$r7.iproposal;
            if (iproposal) {
              _context23.next = 8;
              break;
            }
            return _context23.abrupt("return", false);
          case 8:
            subgraphActions = iproposal.actions;
            actions = toDaoActions(subgraphActions);
            classifiedActions = classifyProposalActions(actions);
            return _context23.abrupt("return", classifiedActions.includes(ProposalActionTypes.UPGRADE_TO_AND_CALL) || classifiedActions.includes(ProposalActionTypes.UPGRADE_TO));
          case 12:
          case "end":
            return _context23.stop();
        }
      }, _callee23, this);
    }));
    function isDaoUpdateProposal(_x15) {
      return _isDaoUpdateProposal.apply(this, arguments);
    }
    return isDaoUpdateProposal;
  }()
  /**
   * Given a proposal id returns if that proposal is a plugin update proposal
   *
   * @param {string} proposalId
   * @return {Promise<boolean>}
   * @memberof ClientMethods
   */
  ;
  _proto.isPluginUpdateProposal =
  /*#__PURE__*/
  function () {
    var _isPluginUpdateProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(proposalId) {
      var name, query, _yield$this$graphql$r8, iproposal, actions, classifiedActions;
      return _regeneratorRuntime().wrap(function _callee24$(_context24) {
        while (1) switch (_context24.prev = _context24.next) {
          case 0:
            name = "iproposal";
            query = QueryIProposal;
            _context24.next = 4;
            return this.graphql.request({
              query: query,
              params: {
                id: getExtendedProposalId(proposalId.toLowerCase())
              },
              name: name
            });
          case 4:
            _yield$this$graphql$r8 = _context24.sent;
            iproposal = _yield$this$graphql$r8.iproposal;
            if (iproposal) {
              _context24.next = 8;
              break;
            }
            return _context24.abrupt("return", false);
          case 8:
            actions = toDaoActions(iproposal.actions);
            classifiedActions = classifyProposalActions(actions);
            return _context24.abrupt("return", classifiedActions.includes(ProposalActionTypes.APPLY_UPDATE));
          case 11:
          case "end":
            return _context24.stop();
        }
      }, _callee24, this);
    }));
    function isPluginUpdateProposal(_x16) {
      return _isPluginUpdateProposal.apply(this, arguments);
    }
    return isPluginUpdateProposal;
  }()
  /**
   * Check if the specified proposal id is valid for updating a plugin
   *
   * @param {string} proposalId
   * @return {Promise<PluginUpdateProposalValidity>}
   * @memberof ClientMethods
   */
  ;
  _proto.isPluginUpdateProposalValid =
  /*#__PURE__*/
  function () {
    var _isPluginUpdateProposalValid = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(proposalId) {
      var name, query, _yield$this$graphql$r9, iproposal, daoActions, classifiedActions;
      return _regeneratorRuntime().wrap(function _callee25$(_context25) {
        while (1) switch (_context25.prev = _context25.next) {
          case 0:
            // not validating the proposalId because multiple proposal id formats can be used
            // get the iproposal given the proposal id
            name = "iproposal";
            query = QueryIProposal;
            _context25.next = 4;
            return this.graphql.request({
              query: query,
              params: {
                id: getExtendedProposalId(proposalId.toLowerCase())
              },
              name: name
            });
          case 4:
            _yield$this$graphql$r9 = _context25.sent;
            iproposal = _yield$this$graphql$r9.iproposal;
            if (iproposal) {
              _context25.next = 8;
              break;
            }
            return _context25.abrupt("return", {
              isValid: false,
              actionErrorCauses: [],
              proposalSettingsErrorCauses: [ProposalSettingsErrorCause.PROPOSAL_NOT_FOUND]
            });
          case 8:
            if (!(iproposal.allowFailureMap !== "0")) {
              _context25.next = 10;
              break;
            }
            return _context25.abrupt("return", {
              isValid: false,
              actionErrorCauses: [],
              proposalSettingsErrorCauses: [ProposalSettingsErrorCause.NON_ZERO_ALLOW_FAILURE_MAP_VALUE]
            });
          case 10:
            daoActions = toDaoActions(iproposal.actions);
            classifiedActions = classifyProposalActions(daoActions); // remove upgradeToAndCall action
            if (startsWithDaoUpdateAction(classifiedActions)) {
              daoActions = daoActions.slice(1);
            }
            // validate actions
            return _context25.abrupt("return", validateUpdatePluginProposalActions(daoActions, iproposal.dao.id, this.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR), this.graphql, this.ipfs));
          case 14:
          case "end":
            return _context25.stop();
        }
      }, _callee25, this);
    }));
    function isPluginUpdateProposalValid(_x17) {
      return _isPluginUpdateProposalValid.apply(this, arguments);
    }
    return isPluginUpdateProposalValid;
  }()
  /**
   * Check if the specified proposalId actions are valid for updating a dao
   *
   * @param {string} proposalId
   * @param {SupportedVersion} [version]
   * @return {Promise<DaoUpdateProposalValidity>}
   * @memberof ClientMethods
   */
  ;
  _proto.isDaoUpdateProposalValid =
  /*#__PURE__*/
  function () {
    var _isDaoUpdateProposalValid = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(proposalId, version) {
      var name, query, res, iproposal, daoFactoryAddress;
      return _regeneratorRuntime().wrap(function _callee26$(_context26) {
        while (1) switch (_context26.prev = _context26.next) {
          case 0:
            // omit input validation because we are receiving the proposal id
            // get the iproposal given the proposal id
            name = "iproposal";
            query = QueryIProposal;
            _context26.next = 4;
            return this.graphql.request({
              query: query,
              params: {
                id: getExtendedProposalId(proposalId.toLowerCase())
              },
              name: name
            });
          case 4:
            res = _context26.sent;
            iproposal = res.iproposal; // if the proposal does not exist return invalid
            if (iproposal) {
              _context26.next = 8;
              break;
            }
            return _context26.abrupt("return", {
              isValid: false,
              proposalSettingsErrorCauses: [ProposalSettingsErrorCause.PROPOSAL_NOT_FOUND],
              actionErrorCauses: []
            });
          case 8:
            if (!(iproposal.allowFailureMap !== "0")) {
              _context26.next = 10;
              break;
            }
            return _context26.abrupt("return", {
              isValid: false,
              actionErrorCauses: [],
              proposalSettingsErrorCauses: [ProposalSettingsErrorCause.NON_ZERO_ALLOW_FAILURE_MAP_VALUE]
            });
          case 10:
            // get implementation address, use latest version as default
            daoFactoryAddress = this.web3.getAddress(FrameworkContractsNames.DAO_FACTORY);
            if (version) {
              // if version is specified get the dao factory address from the live contracts
              daoFactoryAddress = contracts[this.web3.getNetworkName()][version].DAOFactory.address;
            }
            _context26.t0 = validateUpdateDaoProposalActions;
            _context26.t1 = toDaoActions(iproposal.actions);
            _context26.t2 = iproposal.dao.id;
            _context26.next = 17;
            return this.getDaoImplementation(daoFactoryAddress);
          case 17:
            _context26.t3 = _context26.sent;
            _context26.next = 20;
            return this.getProtocolVersion(iproposal.dao.id);
          case 20:
            _context26.t4 = _context26.sent;
            return _context26.abrupt("return", (0, _context26.t0)(_context26.t1, _context26.t2, _context26.t3, _context26.t4));
          case 22:
          case "end":
            return _context26.stop();
        }
      }, _callee26, this);
    }));
    function isDaoUpdateProposalValid(_x18, _x19) {
      return _isDaoUpdateProposalValid.apply(this, arguments);
    }
    return isDaoUpdateProposalValid;
  }()
  /**
   *  Return the implementation address for the specified dao factory
   *
   * @param {string} daoFactoryAddress
   * @return {Promise<string>}
   * @memberof ClientMethods
   */
  ;
  _proto.getDaoImplementation =
  /*#__PURE__*/
  function () {
    var _getDaoImplementation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(daoFactoryAddress) {
      var daoFactoryImplementation;
      return _regeneratorRuntime().wrap(function _callee27$(_context27) {
        while (1) switch (_context27.prev = _context27.next) {
          case 0:
            daoFactoryImplementation = DAOFactory__factory.connect(daoFactoryAddress, this.web3.getProvider());
            return _context27.abrupt("return", daoFactoryImplementation.daoBase());
          case 2:
          case "end":
            return _context27.stop();
        }
      }, _callee27, this);
    }));
    function getDaoImplementation(_x20) {
      return _getDaoImplementation.apply(this, arguments);
    }
    return getDaoImplementation;
  }();
  _proto.getPluginPreparations = /*#__PURE__*/function () {
    var _getPluginPreparations = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(_ref6) {
      var type, pluginAddress, pluginRepoAddress, daoAddressOrEns, _ref6$limit, limit, _ref6$skip, skip, _ref6$direction, direction, _ref6$sortBy, sortBy, where, query, params, name, _yield$this$graphql$r10, pluginPreparations;
      return _regeneratorRuntime().wrap(function _callee28$(_context28) {
        while (1) switch (_context28.prev = _context28.next) {
          case 0:
            type = _ref6.type, pluginAddress = _ref6.pluginAddress, pluginRepoAddress = _ref6.pluginRepoAddress, daoAddressOrEns = _ref6.daoAddressOrEns, _ref6$limit = _ref6.limit, limit = _ref6$limit === void 0 ? 10 : _ref6$limit, _ref6$skip = _ref6.skip, skip = _ref6$skip === void 0 ? 0 : _ref6$skip, _ref6$direction = _ref6.direction, direction = _ref6$direction === void 0 ? SortDirection.ASC : _ref6$direction, _ref6$sortBy = _ref6.sortBy, sortBy = _ref6$sortBy === void 0 ? PluginPreparationSortBy.ID : _ref6$sortBy;
            _context28.next = 3;
            return PluginPreparationQuerySchema.strict().validate({
              type: type,
              pluginAddress: pluginAddress,
              pluginRepoAddress: pluginRepoAddress,
              daoAddressOrEns: daoAddressOrEns,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            });
          case 3:
            where = {};
            if (type) {
              where = _extends({}, where, {
                type: type
              });
            }
            if (pluginAddress) {
              where = _extends({}, where, {
                pluginAddress: pluginAddress.toLowerCase()
              });
            }
            if (pluginRepoAddress) {
              where = _extends({}, where, {
                pluginRepo: pluginRepoAddress.toLowerCase()
              });
            }
            if (daoAddressOrEns) {
              where = _extends({}, where, {
                dao: daoAddressOrEns.toLowerCase()
              });
            }
            query = QueryPluginPreparationsExtended;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "plugin preparations";
            _context28.next = 13;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 13:
            _yield$this$graphql$r10 = _context28.sent;
            pluginPreparations = _yield$this$graphql$r10.pluginPreparations;
            return _context28.abrupt("return", Promise.all(pluginPreparations.map(function (pluginPreparation) {
              return toPluginPreparationListItem(pluginPreparation);
            })));
          case 16:
          case "end":
            return _context28.stop();
        }
      }, _callee28, this);
    }));
    function getPluginPreparations(_x21) {
      return _getPluginPreparations.apply(this, arguments);
    }
    return getPluginPreparations;
  }();
  return ClientMethods;
}(ClientCore);

/**
 * Encoding module the SDK Generic Client
 */
var ClientEncoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(ClientEncoding, _ClientCore);
  function ClientEncoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = ClientEncoding.prototype;
  /**
   * @param {string} daoAddress
   * @param {ApplyInstallationParams} params
   * @return {DaoAction}
   * @memberof ClientEncoding
   */
  _proto.applyInstallationAction = function applyInstallationAction(daoAddress, params) {
    AddressOrEnsSchema.strict().validateSync(daoAddress);
    ApplyInstallationSchema.strict().validateSync(params);
    var pspInterface = PluginSetupProcessor__factory.createInterface();
    var args = applyInstallatonParamsToContract(params);
    var hexBytes = pspInterface.encodeFunctionData("applyInstallation", [daoAddress, args]);
    var pspAddress = this.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR);
    // Grant ROOT_PERMISION in the DAO to the PSP
    var grantAction = this.grantAction(daoAddress, {
      where: daoAddress,
      who: pspAddress,
      permission: Permissions.ROOT_PERMISSION
    });
    // Revoke ROOT_PERMISION in the DAO to the PSP
    var revokeAction = this.revokeAction(daoAddress, {
      where: daoAddress,
      who: pspAddress,
      permission: Permissions.ROOT_PERMISSION
    });
    return [grantAction, {
      to: pspAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    }, revokeAction];
  };
  _proto.applyUninstallationAction = function applyUninstallationAction(daoAddress, params) {
    AddressOrEnsSchema.strict().validateSync(daoAddress);
    ApplyUninstallationSchema.strict().validateSync(params);
    var pspInterface = PluginSetupProcessor__factory.createInterface();
    var args = applyUninstallationParamsToContract(params);
    var hexBytes = pspInterface.encodeFunctionData("applyUninstallation", [daoAddress, args]);
    var pspAddress = this.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR);
    // Grant ROOT_PERMISION in the DAO to the PSP
    var grantAction = this.grantAction(daoAddress, {
      where: daoAddress,
      who: pspAddress,
      permission: Permissions.ROOT_PERMISSION
    });
    // Revoke ROOT_PERMISION in the DAO to the PSP
    var revokeAction = this.revokeAction(daoAddress, {
      where: daoAddress,
      who: pspAddress,
      permission: Permissions.ROOT_PERMISSION
    });
    return [grantAction, {
      to: pspAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    }, revokeAction];
  }
  /**
   * Computes the payload to be given when creating a proposal that applies an update to a plugin
   *
   * @param {string} daoAddress
   * @param {ApplyUpdateParams} params
   * @return {DaoAction[]}
   * @memberof ClientEncoding
   */;
  _proto.applyUpdateAndPermissionsActionBlock = function applyUpdateAndPermissionsActionBlock(daoAddress, params) {
    var pspInterface = PluginSetupProcessor__factory.createInterface();
    var args = applyUpdateParamsToContract(params);
    var hexBytes = pspInterface.encodeFunctionData("applyUpdate", [daoAddress, args]);
    var pspAddress = this.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR);
    // Grant UPGRADE_PLUGIN_PERMISSION in the plugin to the PSP
    var grantUpgradeAction = this.grantAction(daoAddress, {
      where: params.pluginAddress,
      who: pspAddress,
      permission: Permissions.UPGRADE_PLUGIN_PERMISSION
    });
    // Revoke UPGRADE_PLUGIN_PERMISSION in the plugin to the PSP
    var revokeUpgradeAction = this.revokeAction(daoAddress, {
      where: params.pluginAddress,
      who: pspAddress,
      permission: Permissions.UPGRADE_PLUGIN_PERMISSION
    });
    // If the update requests permissions to be granted or revoked, the PSP needs temporary `ROOT_PERMISSION_ID` permission
    if (params.permissions.length > 0) {
      var grantRootAction = this.grantAction(daoAddress, {
        where: daoAddress,
        who: pspAddress,
        permission: Permissions.ROOT_PERMISSION
      });
      // Revoke ROOT_PERMISSION in the DAO to the PSP
      var revokeRootAction = this.revokeAction(daoAddress, {
        where: daoAddress,
        who: pspAddress,
        permission: Permissions.ROOT_PERMISSION
      });
      return [grantUpgradeAction, grantRootAction, {
        to: pspAddress,
        value: BigInt(0),
        data: hexToBytes(hexBytes)
      }, revokeRootAction, revokeUpgradeAction];
    }
    return [grantUpgradeAction, {
      to: pspAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    }, revokeUpgradeAction];
  }
  /**
   * Computes the payload to be given when creating a proposal that grants a permission within a DAO
   *
   * @param {string} daoAddress
   * @param {GrantPermissionParams} params
   * @return {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.grantAction = function grantAction(daoAddress, params) {
    AddressOrEnsSchema.strict().validateSync(daoAddress);
    PermissionBaseSchema.strict().validateSync(params);
    var where = params.where,
      who = params.who;
    if (!isAddress(where) || !isAddress(who) || !isAddress(daoAddress)) {
      throw new InvalidAddressError();
    }
    var daoInterface = DAO__factory.createInterface();
    var args = permissionParamsToContract({
      who: who,
      where: where,
      permission: params.permission
    });
    // get hex bytes
    var hexBytes = daoInterface.encodeFunctionData("grant", args);
    return {
      to: daoAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that grants a permission within a DAO given a certain condition
   *
   * @param {string} daoAddress
   * @param {GrantPermissionWithConditionParams} params
   * @return {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.grantWithConditionAction = function grantWithConditionAction(daoAddress, params) {
    AddressOrEnsSchema.strict().validateSync(daoAddress);
    PermissionWithConditionSchema.strict().validateSync(params);
    var where = params.where,
      who = params.who;
    if (!isAddress(where) || !isAddress(who) || !isAddress(daoAddress)) {
      throw new InvalidAddressError();
    }
    var daoInterface = DAO__factory.createInterface();
    var args = permissionWithConditionParamsToContract({
      who: who,
      where: where,
      permission: params.permission,
      condition: params.condition
    });
    // get hex bytes
    var hexBytes = daoInterface.encodeFunctionData("grantWithCondition", args);
    return {
      to: daoAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that revokes a permission within a DAO
   *
   * @param {string} daoAddress
   * @param {RevokePermissionParams} params
   * @return {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.revokeAction = function revokeAction(daoAddress, params) {
    AddressOrEnsSchema.strict().validateSync(daoAddress);
    PermissionBaseSchema.strict().validateSync(params);
    var where = params.where,
      who = params.who;
    if (!isAddress(where) || !isAddress(who) || !isAddress(daoAddress)) {
      throw new InvalidAddressError();
    }
    var daoInterface = DAO__factory.createInterface();
    var args = permissionParamsToContract({
      who: who,
      where: where,
      permission: params.permission
    });
    // get hex bytes
    var hexBytes = daoInterface.encodeFunctionData("revoke", args);
    return {
      to: daoAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that withdraws ether from the DAO
   *
   * @param {string} recipientAddressOrEns
   * @param {WithdrawParams} value
   * @return {Promise<DaoAction>}
   * @memberof ClientEncoding
   */;
  _proto.withdrawAction =
  /*#__PURE__*/
  function () {
    var _withdrawAction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var to, _this$web3$getSigner, resolvedAddress, iface, data;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            to = params.recipientAddressOrEns;
            if (isAddress(params.recipientAddressOrEns)) {
              _context.next = 8;
              break;
            }
            _context.next = 4;
            return (_this$web3$getSigner = this.web3.getSigner()) == null ? void 0 : _this$web3$getSigner.resolveName(params.recipientAddressOrEns);
          case 4:
            resolvedAddress = _context.sent;
            if (resolvedAddress) {
              _context.next = 7;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 7:
            to = resolvedAddress;
          case 8:
            _context.t0 = params.type;
            _context.next = _context.t0 === TokenType.NATIVE ? 11 : _context.t0 === TokenType.ERC20 ? 14 : _context.t0 === TokenType.ERC721 ? 19 : _context.t0 === TokenType.ERC1155 ? 24 : 29;
            break;
          case 11:
            _context.next = 13;
            return WithdrawEthSchema.strict().validate(params);
          case 13:
            return _context.abrupt("return", {
              to: to,
              value: params.amount,
              data: new Uint8Array()
            });
          case 14:
            _context.next = 16;
            return WithdrawErc20Schema.strict().validate(params);
          case 16:
            iface = new Contract(params.tokenAddress, abi)["interface"];
            data = iface.encodeFunctionData("transfer", [params.recipientAddressOrEns, params.amount]);
            return _context.abrupt("return", {
              to: params.tokenAddress,
              value: BigInt(0),
              data: hexToBytes(data)
            });
          case 19:
            _context.next = 21;
            return WithdrawErc721Schema.strict().validate(params);
          case 21:
            iface = new Contract(params.tokenAddress, abi$1)["interface"];
            data = iface.encodeFunctionData("safeTransferFrom(address,address,uint256)", [params.daoAddressOrEns,
            // from
            params.recipientAddressOrEns,
            // to
            params.tokenId // tokenId
            ]);
            return _context.abrupt("return", {
              to: params.tokenAddress,
              value: BigInt(0),
              data: hexToBytes(data)
            });
          case 24:
            _context.next = 26;
            return WithdrawErc1155Schema.strict().validate(params);
          case 26:
            iface = new Contract(params.tokenAddress, abi$2)["interface"];
            if (params.tokenIds.length === 1) {
              data = iface.encodeFunctionData("safeTransferFrom(address,address,uint256,uint256,bytes)", [params.daoAddressOrEns,
              // from
              params.recipientAddressOrEns,
              // to
              params.tokenIds[0],
              // tokenId
              params.amounts[0],
              // amount
              new Uint8Array() // data
              ]);
            } else {
              data = iface.encodeFunctionData("safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)", [params.daoAddressOrEns,
              // from
              params.recipientAddressOrEns,
              // to
              params.tokenIds,
              // tokenIds
              params.amounts,
              // amounts
              new Uint8Array() // data
              ]);
            }
            return _context.abrupt("return", {
              to: params.tokenAddress,
              value: BigInt(0),
              data: hexToBytes(data)
            });
          case 29:
            throw new NotImplementedError("Token type not supported");
          case 30:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function withdrawAction(_x) {
      return _withdrawAction.apply(this, arguments);
    }
    return withdrawAction;
  }()
  /**
   * Computes the payload to be given when creating a proposal that updates the metadata the DAO
   *
   * @param {string} daoAddressOrEns
   * @param {DaoMetadata} params
   * @return {Promise<DaoAction>}
   * @memberof ClientEncoding
   */
  ;
  _proto.updateDaoMetadataAction =
  /*#__PURE__*/
  function () {
    var _updateDaoMetadataAction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(daoAddressOrEns, metadataUri) {
      var address, _this$web3$getSigner2, resolvedAddress, daoInterface, args, hexBytes;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return AddressOrEnsSchema.strict().validate(daoAddressOrEns);
          case 2:
            _context2.next = 4;
            return IpfsUriSchema.strict().validate(metadataUri);
          case 4:
            address = daoAddressOrEns;
            if (isAddress(daoAddressOrEns)) {
              _context2.next = 12;
              break;
            }
            _context2.next = 8;
            return (_this$web3$getSigner2 = this.web3.getSigner()) == null ? void 0 : _this$web3$getSigner2.resolveName(daoAddressOrEns);
          case 8:
            resolvedAddress = _context2.sent;
            if (resolvedAddress) {
              _context2.next = 11;
              break;
            }
            throw new InvalidEnsError();
          case 11:
            address = resolvedAddress;
          case 12:
            // upload metadata to IPFS
            daoInterface = DAO__factory.createInterface();
            args = toUtf8Bytes(metadataUri);
            hexBytes = daoInterface.encodeFunctionData("setMetadata", [args]);
            return _context2.abrupt("return", {
              to: address,
              value: BigInt(0),
              data: hexToBytes(hexBytes)
            });
          case 16:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function updateDaoMetadataAction(_x2, _x3) {
      return _updateDaoMetadataAction.apply(this, arguments);
    }
    return updateDaoMetadataAction;
  }()
  /**
   * Computes the payload to be given when creating a proposal that sets the dao uri
   *
   * @param {string} daoAddressOrEns
   * @param {string} daoUri
   * @return {DaoAction}
   * @memberof ClientEncoding
   */
  ;
  _proto.setDaoUriAction = function setDaoUriAction(daoAddressOrEns, daoUri) {
    AddressOrEnsSchema.strict().validateSync(daoAddressOrEns);
    string().url().strict().validateSync(daoUri);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("setDaoURI", [daoUri]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that registers a new standard callback
   *
   * @param {string} daoAddressOrEns
   * @param {string} daoUri
   * @return {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.registerStandardCallbackAction = function registerStandardCallbackAction(daoAddressOrEns, params) {
    AddressOrEnsSchema.strict().validateSync(daoAddressOrEns);
    RegisterStandardCallbackSchema.strict().validateSync(params);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("registerStandardCallback", [params.interfaceId, params.callbackSelector, params.magicNumber]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that sets the signature validator
   *
   * @param {string} daoAddressOrEns
   * @param {string} signatureValidator
   * @return {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.setSignatureValidatorAction = function setSignatureValidatorAction(daoAddressOrEns, signatureValidator) {
    AddressOrEnsSchema.strict().validateSync(daoAddressOrEns);
    AddressOrEnsSchema.strict().validateSync(signatureValidator);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("setSignatureValidator", [signatureValidator]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that sets a new implementation for the proxy
   *
   * @param {string} daoAddressOrEns
   * @param {string} implementationAddress
   * @return {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.upgradeToAction = function upgradeToAction(daoAddressOrEns, implementationAddress) {
    AddressOrEnsSchema.strict().validateSync(daoAddressOrEns);
    AddressOrEnsSchema.strict().validateSync(implementationAddress);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("upgradeTo", [implementationAddress]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the payload to be given when creating a proposal that sets a new implementation for the proxy and calls the callback function with the specified data
   *
   * @param {string} daoAddressOrEns
   * @param {UpgradeToAndCallParams} params
   * @return {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.upgradeToAndCallAction = function upgradeToAndCallAction(daoAddressOrEns, params) {
    AddressOrEnsSchema.strict().validateSync(daoAddressOrEns);
    UpgradeToAndCallSchema.strict().validateSync(params);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("upgradeToAndCall", [params.implementationAddress, params.data]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes an action to be passed to the upgradeToAndCallAction method when upgrading a DAO to a new version.
   *
   * @param {string} daoAddressOrEns
   * @param {InitializeFromParams} params
   * @return {DaoAction}
   * @memberof ClientEncoding
   */;
  _proto.initializeFromAction = function initializeFromAction(daoAddressOrEns, params) {
    var _params$initData;
    AddressOrEnsSchema.strict().validateSync(daoAddressOrEns);
    InitializeFromSchema.strict().validateSync(params);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = daoInterface.encodeFunctionData("initializeFrom", [params.previousVersion, (_params$initData = params.initData) != null ? _params$initData : new Uint8Array()]);
    return {
      to: daoAddressOrEns,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Does the necessary steps to encode an action that updates a DAO
   *
   * @param {string} daoAddressOrEns
   * @param {DaoUpdateParams} params
   * @return {Promise<DaoAction>}
   * @memberof ClientEncoding
   */;
  _proto.daoUpdateAction =
  /*#__PURE__*/
  function () {
    var _daoUpdateAction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(daoAddressOrEns, params) {
      var initializeFromAction, daoFactoryAddress, daoFactory, implementation;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            AddressOrEnsSchema.strict().validateSync(daoAddressOrEns);
            DaoUpdateSchema.strict().validateSync(params);
            initializeFromAction = this.initializeFromAction(daoAddressOrEns, params);
            daoFactoryAddress = params.daoFactoryAddress;
            daoFactory = DAOFactory__factory.connect(daoFactoryAddress != null ? daoFactoryAddress : this.web3.getAddress(FrameworkContractsNames.DAO_FACTORY), this.web3.getProvider());
            _context3.next = 7;
            return daoFactory.daoBase();
          case 7:
            implementation = _context3.sent;
            return _context3.abrupt("return", this.upgradeToAndCallAction(daoAddressOrEns, {
              implementationAddress: implementation,
              data: initializeFromAction.data
            }));
          case 9:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function daoUpdateAction(_x4, _x5) {
      return _daoUpdateAction.apply(this, arguments);
    }
    return daoUpdateAction;
  }();
  return ClientEncoding;
}(ClientCore);

/**
 * Estimation module the SDK Generic Client
 */
var ClientEstimation = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(ClientEstimation, _ClientCore);
  function ClientEstimation() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = ClientEstimation.prototype;
  _proto.prepareInstallation = /*#__PURE__*/function () {
    var _prepareInstallation = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return PrepareInstallationSchema.strict().validate(params);
          case 2:
            return _context.abrupt("return", prepareGenericInstallationEstimation(this.web3, params));
          case 3:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function prepareInstallation(_x) {
      return _prepareInstallation.apply(this, arguments);
    }
    return prepareInstallation;
  }()
  /**
   * Estimates the gas fee of creating a DAO
   *
   * @param {CreateDaoParams} _params
   * @return {Promise<GasFeeEstimation>}
   * @memberof ClientEstimation
   */
  ;
  _proto.createDao =
  /*#__PURE__*/
  function () {
    var _createDao = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var _params$ensSubdomain, _params$daoUri, _params$trustedForwar;
      var provider, daoInstance, pluginInstallationData, _iterator, _step, plugin, repo, currentRelease, latestVersion, gasEstimation;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return CreateDaoSchema.strict().validate(params);
          case 2:
            provider = this.web3.getProvider();
            daoInstance = DAOFactory__factory.connect(this.web3.getAddress(FrameworkContractsNames.DAO_FACTORY), provider);
            pluginInstallationData = [];
            _iterator = _createForOfIteratorHelperLoose(params.plugins);
          case 6:
            if ((_step = _iterator()).done) {
              _context2.next = 18;
              break;
            }
            plugin = _step.value;
            repo = PluginRepo__factory.connect(plugin.id, provider);
            _context2.next = 11;
            return repo.latestRelease();
          case 11:
            currentRelease = _context2.sent;
            _context2.next = 14;
            return repo["getLatestVersion(uint8)"](currentRelease);
          case 14:
            latestVersion = _context2.sent;
            pluginInstallationData.push({
              pluginSetupRef: {
                pluginSetupRepo: repo.address,
                versionTag: latestVersion.tag
              },
              data: plugin.data
            });
          case 16:
            _context2.next = 6;
            break;
          case 18:
            _context2.next = 20;
            return daoInstance.estimateGas.createDao({
              subdomain: (_params$ensSubdomain = params.ensSubdomain) != null ? _params$ensSubdomain : "",
              metadata: toUtf8Bytes(params.metadataUri),
              daoURI: (_params$daoUri = params.daoUri) != null ? _params$daoUri : "",
              trustedForwarder: (_params$trustedForwar = params.trustedForwarder) != null ? _params$trustedForwar : AddressZero
            }, pluginInstallationData);
          case 20:
            gasEstimation = _context2.sent;
            return _context2.abrupt("return", this.web3.getApproximateGasFee(gasEstimation.toBigInt()));
          case 22:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function createDao(_x2) {
      return _createDao.apply(this, arguments);
    }
    return createDao;
  }()
  /**
   * Estimates the gas fee of depositing ether or an ERC20 token into the DAO
   * This does not estimate the gas cost of updating the allowance of an ERC20 token
   *
   * @param {DepositParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof ClientEstimation
   */
  ;
  _proto.deposit =
  /*#__PURE__*/
  function () {
    var _deposit = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(params) {
      var signer, estimation;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _context3.t0 = params.type;
            _context3.next = _context3.t0 === TokenType.NATIVE ? 4 : _context3.t0 === TokenType.ERC20 ? 10 : _context3.t0 === TokenType.ERC721 ? 16 : _context3.t0 === TokenType.ERC1155 ? 22 : 28;
            break;
          case 4:
            _context3.next = 6;
            return DepositEthSchema.strict().validate(params);
          case 6:
            _context3.next = 8;
            return estimateNativeDeposit(signer, params);
          case 8:
            estimation = _context3.sent;
            return _context3.abrupt("break", 29);
          case 10:
            _context3.next = 12;
            return DepositErc20Schema.strict().validate(params);
          case 12:
            _context3.next = 14;
            return estimateErc20Deposit(signer, params);
          case 14:
            estimation = _context3.sent;
            return _context3.abrupt("break", 29);
          case 16:
            _context3.next = 18;
            return DepositErc721Schema.strict().validate(params);
          case 18:
            _context3.next = 20;
            return estimateErc721Deposit(signer, params);
          case 20:
            estimation = _context3.sent;
            return _context3.abrupt("break", 29);
          case 22:
            _context3.next = 24;
            return DepositErc1155Schema.strict().validate(params);
          case 24:
            _context3.next = 26;
            return estimateErc1155Deposit(signer, params);
          case 26:
            estimation = _context3.sent;
            return _context3.abrupt("break", 29);
          case 28:
            throw new NotImplementedError("Token type not valid");
          case 29:
            return _context3.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 30:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function deposit(_x3) {
      return _deposit.apply(this, arguments);
    }
    return deposit;
  }()
  /**
   * Estimates the gas fee of updating the allowance of an ERC20 token
   *
   * @param {SetAllowanceParams} _params
   * @return {Promise<GasFeeEstimation>}
   * @memberof ClientEstimation
   */
  ;
  _proto.setAllowance =
  /*#__PURE__*/
  function () {
    var _setAllowance = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params) {
      var _this = this;
      var signer, daoAddress, provider, resolvedAddress, contract;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return SetAllowanceSchema.strict().validate(params);
          case 2:
            signer = this.web3.getConnectedSigner(); // resolve ens
            daoAddress = params.spender;
            if (isAddress(daoAddress)) {
              _context4.next = 16;
              break;
            }
            _context4.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context4.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context4.next = 12;
            return provider.resolveName(daoAddress);
          case 12:
            resolvedAddress = _context4.sent;
            if (resolvedAddress) {
              _context4.next = 15;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 15:
            daoAddress = resolvedAddress;
          case 16:
            contract = new Contract(params.tokenAddress, abi, signer);
            return _context4.abrupt("return", contract.estimateGas.approve(daoAddress, params.amount).then(function (gasLimit) {
              return _this.web3.getApproximateGasFee(gasLimit.toBigInt());
            }));
          case 18:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function setAllowance(_x4) {
      return _setAllowance.apply(this, arguments);
    }
    return setAllowance;
  }()
  /**
   * Estimates the gas fee of preparing an update
   *
   * @param {PrepareUpdateParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof ClientEstimation
   */
  ;
  _proto.prepareUpdate =
  /*#__PURE__*/
  function () {
    var _prepareUpdate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(params) {
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return prepareGenericUpdateEstimation(this.web3, this.graphql, _extends({}, params, {
              pluginSetupProcessorAddress: this.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR)
            }));
          case 2:
            return _context5.abrupt("return", _context5.sent);
          case 3:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function prepareUpdate(_x5) {
      return _prepareUpdate.apply(this, arguments);
    }
    return prepareUpdate;
  }();
  return ClientEstimation;
}(ClientCore);

/**
 * Decoding module the SDK Generic Client
 */
var ClientDecoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(ClientDecoding, _ClientCore);
  function ClientDecoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = ClientDecoding.prototype;
  /**
   * @param {data} Uint8Array
   * @return {DecodedApplyInstallationParams}
   * @memberof ClientDecoding
   */
  _proto.applyInstallationAction = function applyInstallationAction(data) {
    Uint8ArraySchema.strict().validateSync(data);
    var pspInterface = PluginSetupProcessor__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = pspInterface.getFunction("applyInstallation");
    var result = pspInterface.decodeFunctionData(expectedFunction, hexBytes);
    return applyInstallatonParamsFromContract$1(result);
  }
  /**
   * @param {data} Uint8Array
   * @return {DecodedApplyInstallationParams}
   * @memberof ClientDecoding
   */;
  _proto.applyUninstallationAction = function applyUninstallationAction(data) {
    Uint8ArraySchema.strict().validateSync(data);
    var pspInterface = PluginSetupProcessor__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = pspInterface.getFunction("applyUninstallation");
    var result = pspInterface.decodeFunctionData(expectedFunction, hexBytes);
    return applyInstallatonParamsFromContract$1(result);
  }
  /**
   * Decodes the apply update parameters from an encoded apply update action
   *
   * @param {Uint8Array} data
   * @return {DecodedApplyUpdateParams}
   * @memberof ClientDecoding
   */;
  _proto.applyUpdateAction = function applyUpdateAction(data) {
    return decodeApplyUpdateAction(data);
  }
  /**
   * Decodes the permission parameters from an encoded grant action
   *
   * @param {Uint8Array} data
   * @return {GrantPermissionDecodedParams}
   * @memberof ClientDecoding
   */;
  _proto.grantAction = function grantAction(data) {
    Uint8ArraySchema.strict().validate(data);
    return decodeGrantAction(data);
  }
  /**
   * Decodes the grant permission with condition parameters from an encoded grant with condition action
   *
   * @param {Uint8Array} data
   * @return {GrantPermissionWithConditionParams}
   * @memberof ClientDecoding
   */;
  _proto.grantWithConditionAction = function grantWithConditionAction(data) {
    Uint8ArraySchema.strict().validateSync(data);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("grantWithCondition");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return permissionParamsWitConditionFromContract(result);
  }
  /**
   * Decodes the permission parameters from an encoded revoke action
   *
   * @param {Uint8Array} data
   * @return {RevokePermissionDecodedParams}
   * @memberof ClientDecoding
   */;
  _proto.revokeAction = function revokeAction(data) {
    Uint8ArraySchema.strict().validateSync(data);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("revoke");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return permissionParamsFromContract(result);
  }
  /**
   * Decodes the withdraw parameters from an encoded withdraw action
   *
   * @param {Uint8Array} data
   * @return {WithdrawParams}
   * @memberof ClientDecoding
   */;
  _proto.withdrawAction = function withdrawAction(to, value, data) {
    AddressOrEnsSchema.strict().validateSync(to);
    BigintSchema.strict().validateSync(value);
    Uint8ArraySchema.strict().validateSync(data);
    // Native
    if (!(data != null && data.length)) {
      return {
        type: TokenType.NATIVE,
        recipientAddressOrEns: to,
        amount: value
      };
    }
    // ERC20 and other
    var abiObjects = [{
      tokenStandard: TokenType.ERC20,
      abi: abi,
      batch: false,
      "function": "transfer"
    }, {
      tokenStandard: TokenType.ERC721,
      abi: abi$1,
      batch: false,
      "function": "safeTransferFrom(address,address,uint256)"
    }, {
      tokenStandard: TokenType.ERC1155,
      abi: abi$2,
      batch: true,
      "function": "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"
    }, {
      tokenStandard: TokenType.ERC1155,
      abi: abi$2,
      batch: false,
      "function": "safeTransferFrom(address,address,uint256,uint256,bytes)"
    }];
    for (var _i = 0, _abiObjects = abiObjects; _i < _abiObjects.length; _i++) {
      var abiObject = _abiObjects[_i];
      try {
        var hexBytes = bytesToHex(data);
        var iface = new Contract(AddressZero, abiObject.abi)["interface"];
        var expectedFunction = iface.getFunction(abiObject["function"]);
        var result = iface.decodeFunctionData(expectedFunction, hexBytes);
        return withdrawParamsFromContract(to, value, result, abiObject.tokenStandard, abiObject.batch);
      } catch (e) {
        continue;
      }
    }
    throw new InvalidActionError();
  }
  /**
   * Decodes a dao metadata ipfs uri from an encoded update metadata action
   *
   * @param {Uint8Array} data
   * @return {string}
   * @memberof ClientDecoding
   */;
  _proto.updateDaoMetadataRawAction = function updateDaoMetadataRawAction(data) {
    Uint8ArraySchema.strict().validateSync(data);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("setMetadata");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    var metadataUri = toUtf8String(result[0]);
    resolveIpfsCid(metadataUri);
    return metadataUri;
  }
  /**
   * Decodes a dao metadata from an encoded update metadata raw action
   *
   * @param {Uint8Array} data
   * @return {Promise<DaoMetadata>}
   * @memberof ClientDecoding
   */;
  _proto.updateDaoMetadataAction =
  /*#__PURE__*/
  function () {
    var _updateDaoMetadataAction = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data) {
      var daoInterface, hexBytes, expectedFunction, result, metadataUri, ipfsCid, stringMetadata;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return Uint8ArraySchema.strict().validate(data);
          case 2:
            daoInterface = DAO__factory.createInterface();
            hexBytes = bytesToHex(data);
            expectedFunction = daoInterface.getFunction("setMetadata");
            result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
            metadataUri = toUtf8String(result[0]);
            ipfsCid = resolveIpfsCid(metadataUri);
            _context.prev = 8;
            _context.next = 11;
            return this.ipfs.fetchString(ipfsCid);
          case 11:
            stringMetadata = _context.sent;
            return _context.abrupt("return", JSON.parse(stringMetadata));
          case 15:
            _context.prev = 15;
            _context.t0 = _context["catch"](8);
            throw new IpfsError(_context.t0);
          case 18:
          case "end":
            return _context.stop();
        }
      }, _callee, this, [[8, 15]]);
    }));
    function updateDaoMetadataAction(_x) {
      return _updateDaoMetadataAction.apply(this, arguments);
    }
    return updateDaoMetadataAction;
  }()
  /**
   * Decodes the daoUri from a setDaoUriAction
   *
   * @param {Uint8Array} data
   * @return {string}
   * @memberof ClientDecoding
   */
  ;
  _proto.setDaoUriAction = function setDaoUriAction(data) {
    Uint8ArraySchema.strict().validateSync(data);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("setDaoURI");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return result[0];
  }
  /**
   * Decodes the RegisterStandardCallbackParams from a registerStandardCallbackAction
   *
   * @param {Uint8Array} data
   * @return {RegisterStandardCallbackParams}
   * @memberof ClientDecoding
   */;
  _proto.registerStandardCallbackAction = function registerStandardCallbackAction(data) {
    Uint8ArraySchema.strict().validateSync(data);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("registerStandardCallback");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return {
      interfaceId: result[0],
      callbackSelector: result[1],
      magicNumber: result[2]
    };
  }
  /**
   * Decodes the implementation address from an encoded upgradeToAction
   *
   * @param {Uint8Array} data
   * @return {string}
   * @memberof ClientDecoding
   */;
  _proto.setSignatureValidatorAction = function setSignatureValidatorAction(data) {
    Uint8ArraySchema.strict().validateSync(data);
    var daoInterface = DAO__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedFunction = daoInterface.getFunction("setSignatureValidator");
    var result = daoInterface.decodeFunctionData(expectedFunction, hexBytes);
    return result[0];
  };
  _proto.upgradeToAction = function upgradeToAction(data) {
    return decodeUpgradeToAction(data);
  }
  /**
   * Decodes upgradeToAndCallback params from an upgradeToAndCallAction
   *
   * @param {Uint8Array} data
   * @return {UpgradeToAndCallParams}
   * @memberof ClientDecoding
   */;
  _proto.upgradeToAndCallAction = function upgradeToAndCallAction(data) {
    Uint8ArraySchema.strict().validate(data);
    return decodeUpgradeToAndCallAction(data);
  }
  /**
   * Decodes the initializeFrom params from an initializeFromAction
   *
   * @param {Uint8Array} data
   * @return {InitializeFromParams}
   * @memberof ClientDecoding
   */;
  _proto.initializeFromAction = function initializeFromAction(data) {
    Uint8ArraySchema.strict().validate(data);
    return decodeInitializeFromAction(data);
  }
  /**
   * Returns the decoded function info given the encoded data of an action
   *
   * @param {Uint8Array} data
   * @return {(InterfaceParams | null)}
   * @memberof ClientDecoding
   */;
  _proto.findInterface = function findInterface$1(data) {
    Uint8ArraySchema.strict().validate(data);
    return findInterface(data, AVAILABLE_FUNCTION_SIGNATURES$3);
  }
  /**
   * Decodes the dao update params from a daoUpdateAction
   *
   * @param {Uint8Array} data
   * @return {DaoUpdateDecodedParams}
   * @memberof ClientDecoding
   */;
  _proto.daoUpdateAction = function daoUpdateAction(data) {
    var upgradeToAndCallDecodedParams = this.upgradeToAndCallAction(data);
    var initializeFromDecodedParams = this.initializeFromAction(upgradeToAndCallDecodedParams.data);
    return {
      implementationAddress: upgradeToAndCallDecodedParams.implementationAddress,
      previousVersion: initializeFromDecodedParams.previousVersion,
      initData: initializeFromDecodedParams.initData
    };
  };
  return ClientDecoding;
}(ClientCore);

/**
 * Provider a generic client with high level methods to manage and interact with DAO's
 */
var Client = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(Client, _ClientCore);
  function Client(context) {
    var _this;
    _this = _ClientCore.call(this, context) || this;
    _this.methods = new ClientMethods(context);
    _this.encoding = new ClientEncoding(context);
    _this.decoding = new ClientDecoding(context);
    _this.estimation = new ClientEstimation(context);
    return _this;
  }
  return Client;
}(ClientCore);

/**
 * Contains the states of a proposal. Note that on chain
 * proposals cannot be in draft state
 */
var VoteValues;
(function (VoteValues) {
  // NONE = 0,
  VoteValues[VoteValues["ABSTAIN"] = 1] = "ABSTAIN";
  VoteValues[VoteValues["YES"] = 2] = "YES";
  VoteValues[VoteValues["NO"] = 3] = "NO";
})(VoteValues || (VoteValues = {}));
var VotingMode;
(function (VotingMode) {
  VotingMode["STANDARD"] = "Standard";
  VotingMode["EARLY_EXECUTION"] = "EarlyExecution";
  VotingMode["VOTE_REPLACEMENT"] = "VoteReplacement";
})(VotingMode || (VotingMode = {}));
var SubgraphVoteValues;
(function (SubgraphVoteValues) {
  SubgraphVoteValues["YES"] = "Yes";
  SubgraphVoteValues["NO"] = "No";
  SubgraphVoteValues["ABSTAIN"] = "Abstain";
})(SubgraphVoteValues || (SubgraphVoteValues = {}));
var SubgraphVoteValuesMap = /*#__PURE__*/new Map([[SubgraphVoteValues.YES, VoteValues.YES], [SubgraphVoteValues.NO, VoteValues.NO], [SubgraphVoteValues.ABSTAIN, VoteValues.ABSTAIN]]);
var ProposalSortBy;
(function (ProposalSortBy) {
  ProposalSortBy["CREATED_AT"] = "createdAt";
  // POPULARITY = "popularity",
  // VOTES = "votes",
})(ProposalSortBy || (ProposalSortBy = {}));
// STEPS
// PROPOSAL CREATION
var ProposalCreationSteps;
(function (ProposalCreationSteps) {
  ProposalCreationSteps["CREATING"] = "creating";
  ProposalCreationSteps["DONE"] = "done";
})(ProposalCreationSteps || (ProposalCreationSteps = {}));
// PROPOSAL VOTING
var VoteProposalStep;
(function (VoteProposalStep) {
  VoteProposalStep["VOTING"] = "voting";
  VoteProposalStep["DONE"] = "done";
})(VoteProposalStep || (VoteProposalStep = {}));
// PROPOSAL EXECUTION
var ExecuteProposalStep;
(function (ExecuteProposalStep) {
  ExecuteProposalStep["EXECUTING"] = "executing";
  ExecuteProposalStep["DONE"] = "done";
})(ExecuteProposalStep || (ExecuteProposalStep = {}));
var MembersSortBy;
(function (MembersSortBy) {
  MembersSortBy["ADDRESS"] = "address";
})(MembersSortBy || (MembersSortBy = {}));

var multisigInterface = /*#__PURE__*/Multisig__factory.createInterface();
var majorityVotingInterface = /*#__PURE__*/MajorityVotingBase__factory.createInterface();
var FAILING_PROPOSAL_AVAILABLE_FUNCTION_SIGNATURES = [/*#__PURE__*/multisigInterface.getFunction("addAddresses").format("minimal"), /*#__PURE__*/multisigInterface.getFunction("removeAddresses").format("minimal"), /*#__PURE__*/multisigInterface.getFunction("updateMultisigSettings").format("minimal"), /*#__PURE__*/majorityVotingInterface.getFunction("updateVotingSettings").format("minimal")];

function unwrapProposalParams(params) {
  var _params$actions, _params$executeOnPass, _params$creatorVote;
  return [params.metadataUri, (_params$actions = params.actions) != null ? _params$actions : [],
  // TODO: Verify => seconds?
  params.startDate ? Math.floor(params.startDate.getTime() / 1000) : 0,
  // TODO: Verify => seconds?
  params.endDate ? Math.floor(params.endDate.getTime() / 1000) : 0, (_params$executeOnPass = params.executeOnPass) != null ? _params$executeOnPass : false, (_params$creatorVote = params.creatorVote) != null ? _params$creatorVote : VoteValues.ABSTAIN];
}
function votingModeToContracts(votingMode) {
  switch (votingMode) {
    case VotingMode.STANDARD:
      return 0;
    case VotingMode.EARLY_EXECUTION:
      return 1;
    case VotingMode.VOTE_REPLACEMENT:
      return 2;
    default:
      throw new InvalidVotingModeError();
  }
}
function votingModeFromContracts(votingMode) {
  switch (votingMode) {
    case 0:
      return VotingMode.STANDARD;
    case 1:
      return VotingMode.EARLY_EXECUTION;
    case 2:
      return VotingMode.VOTE_REPLACEMENT;
    default:
      throw new InvalidVotingModeError();
  }
}
function isFailingProposal(actions) {
  if (actions === void 0) {
    actions = [];
  }
  // store the function names of the actions
  var functionNames = actions.map(function (action) {
    try {
      var fragment = getFunctionFragment(action.data, FAILING_PROPOSAL_AVAILABLE_FUNCTION_SIGNATURES);
      return fragment.name;
    } catch (_unused) {
      return "";
    }
  }).filter(function (name) {
    return name !== "";
  });
  for (var _iterator = _createForOfIteratorHelperLoose(functionNames.entries()), _step; !(_step = _iterator()).done;) {
    var _step$value = _step.value,
      i = _step$value[0],
      functionName = _step$value[1];
    // if I add addresses, we must update the settings after
    if (functionName === "addAddresses") {
      // if there is not an updateVotingSettings after addAddresses then the proposal will fail
      if (functionNames.indexOf("updateVotingSettings", i) === -1 && functionNames.indexOf("updateMultisigSettings", i) === -1) {
        return true;
      }
      // if I remove addresses, we must update the settings befor
    } else if (functionName === "removeAddresses") {
      // if there is not an updateVotingSettings before removeAddresses then the proposal will fail
      var updateVotingSettingsIndex = functionNames.indexOf("updateVotingSettings"); // if there is not an updateVotingSettings before removeAddresses then the proposal will fail
      var updateMultisigSettingsIndex = functionNames.indexOf("updateMultisigSettings");
      if ((updateVotingSettingsIndex === -1 || updateVotingSettingsIndex > i) && (updateMultisigSettingsIndex === -1 || updateMultisigSettingsIndex > i)) {
        return true;
      }
    }
  }
  return false;
}
function applyInstallatonParamsFromContract(result) {
  var params = result[1];
  return {
    helpersHash: params.helpersHash,
    permissions: params.permissions,
    versionTag: params.pluginSetupRef.versionTag,
    pluginAddress: params.plugin,
    pluginRepo: params.pluginSetupRef.pluginSetupRepo
  };
}

function decodeUpdatePluginSettingsAction(data) {
  var votingInterface = MajorityVotingBase__factory.createInterface();
  var hexBytes = bytesToHex(data);
  var expectedfunction = votingInterface.getFunction("updateVotingSettings");
  var result = votingInterface.decodeFunctionData(expectedfunction, hexBytes);
  return pluginSettingsFromContract(result);
}
function encodeUpdateVotingSettingsAction(params) {
  var votingInterface = MajorityVotingBase__factory.createInterface();
  var args = votingSettingsToContract(params);
  // get hex bytes
  var hexBytes = votingInterface.encodeFunctionData("updateVotingSettings", [{
    votingMode: args[0],
    supportThreshold: args[1],
    minParticipation: args[2],
    minDuration: args[3],
    minProposerVotingPower: args[4]
  }]);
  // Strip 0x => encode in Uint8Array
  return hexToBytes(hexBytes);
}
function pluginSettingsFromContract(result) {
  return {
    votingMode: votingModeFromContracts(result[0][0]),
    supportThreshold: decodeRatio(result[0][1], 6),
    minParticipation: decodeRatio(result[0][2], 6),
    minDuration: result[0][3].toNumber(),
    minProposerVotingPower: BigInt(result[0][4])
  };
}
function votingSettingsToContract(params) {
  var _params$minProposerVo;
  return [BigNumber.from(votingModeToContracts(params.votingMode || VotingMode.STANDARD)), BigNumber.from(encodeRatio(params.supportThreshold, 6)), BigNumber.from(encodeRatio(params.minParticipation, 6)), BigNumber.from(params.minDuration), BigNumber.from((_params$minProposerVo = params.minProposerVotingPower) != null ? _params$minProposerVo : 0)];
}

// This file contains common types, interfaces, and enumerations
var DaoRole;
(function (DaoRole) {
  DaoRole["UPGRADE_ROLE"] = "UPGRADE_ROLE";
  DaoRole["DAO_CONFIG_ROLE"] = "DAO_CONFIG_ROLE";
  DaoRole["EXEC_ROLE"] = "EXEC_ROLE";
  DaoRole["WITHDRAW_ROLE"] = "WITHDRAW_ROLE";
  DaoRole["SET_SIGNATURE_VALIDATOR_ROLE"] = "SET_SIGNATURE_VALIDATOR_ROLE";
})(DaoRole || (DaoRole = {}));

var _templateObject$9, _templateObject2$5;
var QueryAddresslistVotingMembers = /*#__PURE__*/gql(_templateObject$9 || (_templateObject$9 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery AddresslistVotingMembers($where: AddresslistVotingVoter_filter!, $block: Block_height, $limit: Int!, $skip: Int!, $sortBy: AddresslistVotingVoter_orderBy!, $direction: OrderDirection!) {\n  addresslistVotingVoters(\n    where: $where\n    block: $block\n    first: $limit\n    skip: $skip\n    orderBy: $sortBy\n    orderDirection: $direction\n  ) {\n    address\n  }\n}"])));
var QueryAddresslistVotingIsMember = /*#__PURE__*/gql(_templateObject2$5 || (_templateObject2$5 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery AddresslistVotingIsMember($id: ID!, $block: Block_height) {\n  addresslistVotingVoter(\n    id: $id\n    block: $block\n  ) {\n    id\n  }\n}"])));

var _templateObject$8, _templateObject2$4;
var QueryAddresslistVotingProposal = /*#__PURE__*/gql(_templateObject$8 || (_templateObject$8 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery AddresslistVotingProposal($proposalId: ID!) {\n  addresslistVotingProposal(id: $proposalId){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    createdAt\n    creationBlockNumber\n    executionDate\n    executionBlockNumber\n    actions {\n      to\n      value\n      data\n    }\n    yes\n    no\n    abstain\n    votingMode\n    supportThreshold\n    startDate\n    endDate\n    executed\n    earlyExecutable\n    approvalReached\n    isSignaling\n    executionTxHash\n    voters{\n      voter{\n        address\n      }\n      voteOption\n      voteReplaced\n    }\n    totalVotingPower\n    minVotingPower\n  }\n}\n"])));
var QueryAddresslistVotingProposals = /*#__PURE__*/gql(_templateObject2$4 || (_templateObject2$4 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery AddresslistVotingProposals($where: AddresslistVotingProposal_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: AddresslistVotingProposal_orderBy!) {\n  addresslistVotingProposals(where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n    id\n    dao {\n      id\n      subdomain\n    }\n    actions {\n      to\n      value\n      data\n    }\n    creator\n    metadata\n    yes\n    no\n    abstain\n    startDate\n    endDate\n    executed\n    earlyExecutable\n    approvalReached\n    isSignaling\n    voters{\n      voter{\n        address\n      }\n      voteOption\n      voteReplaced\n    }\n  }\n}\n"])));

var _templateObject$7;
var QueryAddresslistVotingSettings = /*#__PURE__*/gql(_templateObject$7 || (_templateObject$7 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery AddresslistVotingSettings($address: ID!, $block: Block_height) {\n  addresslistVotingPlugin(id: $address, block: $block){\n    minDuration\n    minProposerVotingPower\n    minParticipation\n    supportThreshold\n    votingMode\n  }\n}\n"])));

function toAddresslistVotingProposal(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  var creationDate = new Date(parseInt(proposal.createdAt) * 1000);
  var executionDate = proposal.executionDate ? new Date(parseInt(proposal.executionDate) * 1000) : null;
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary,
      description: metadata.description,
      resources: metadata.resources,
      media: metadata.media
    },
    metadataHash: proposal.metadata,
    startDate: startDate,
    endDate: endDate,
    creationDate: creationDate,
    executionTxHash: proposal.executionTxHash || null,
    creationBlockNumber: parseInt(proposal.creationBlockNumber),
    executionDate: executionDate,
    executionBlockNumber: parseInt(proposal.executionBlockNumber) || null,
    actions: proposal.actions.map(function (action) {
      return {
        data: hexToBytes(action.data),
        to: action.to,
        value: BigInt(action.value)
      };
    }),
    status: computeProposalStatus$2(proposal),
    result: {
      yes: proposal.yes ? parseInt(proposal.yes) : 0,
      no: proposal.no ? parseInt(proposal.no) : 0,
      abstain: proposal.abstain ? parseInt(proposal.abstain) : 0
    },
    settings: {
      supportThreshold: decodeRatio(BigInt(proposal.supportThreshold), 6),
      minParticipation: decodeRatio(BigInt(proposal.minVotingPower) * BigInt(1000000) / BigInt(proposal.totalVotingPower), 6),
      duration: parseInt(proposal.endDate) - parseInt(proposal.startDate)
    },
    totalVotingWeight: parseInt(proposal.totalVotingPower),
    votes: proposal.voters.map(function (voter) {
      return {
        voteReplaced: voter.voteReplaced,
        address: voter.voter.address,
        vote: SubgraphVoteValuesMap.get(voter.voteOption)
      };
    })
  };
}
function toAddresslistVotingProposalListItem(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary
    },
    metadataHash: proposal.metadata,
    startDate: startDate,
    endDate: endDate,
    status: computeProposalStatus$2(proposal),
    result: {
      yes: proposal.yes ? parseInt(proposal.yes) : 0,
      no: proposal.no ? parseInt(proposal.no) : 0,
      abstain: proposal.abstain ? parseInt(proposal.abstain) : 0
    },
    actions: proposal.actions.map(function (action) {
      return {
        data: hexToBytes(action.data),
        to: action.to,
        value: BigInt(action.value)
      };
    }),
    votes: proposal.voters.map(function (voter) {
      return {
        voteReplaced: voter.voteReplaced,
        address: voter.voter.address,
        vote: SubgraphVoteValuesMap.get(voter.voteOption)
      };
    })
  };
}
function computeProposalStatus$2(proposal) {
  var now = new Date();
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  // The proposal is executed so the status becomes EXECUTED
  // independently of the other conditions
  if (proposal.executed) {
    return ProposalStatus.EXECUTED;
  }
  // The proposal is not executed and the start date is in the future
  // so the status becomes PENDING
  if (startDate >= now) {
    return ProposalStatus.PENDING;
  }
  // The proposal is not executed and the start date is in the past.
  // Accordingly, we check if the proposal reached enough approval
  // (i.e., that the supportThreshold and minParticipation criteria are both met).
  // If approvalReached is true and the vote has ended (end date is in the past), it has succeeded.
  // This applies to normal mode and vote replacement mode.
  if (proposal.approvalReached && endDate <= now) {
    return ProposalStatus.SUCCEEDED;
  }
  // In early exeuction mode, we calculate if subsequent voting can change the result of the vote.
  // If not, the proposal is early executable and is therefore succeeded as well.
  if (proposal.earlyExecutable) {
    return ProposalStatus.SUCCEEDED;
  }
  // The proposal is not executed and the start date is in the past
  // and the approval threshold is not reached
  // If the end date is in the future this means that you can still vote
  // so the status becomes ACTIVE
  if (now < endDate) {
    return ProposalStatus.ACTIVE;
  }
  // If none of the other conditions are met the status becomes DEFEATED
  return ProposalStatus.DEFEATED;
}
function computeProposalStatusFilter$2(status) {
  var where = {};
  var now = Math.round(new Date().getTime() / 1000).toString();
  switch (status) {
    case ProposalStatus.PENDING:
      where = {
        startDate_gte: now
      };
      break;
    case ProposalStatus.ACTIVE:
      where = {
        startDate_lt: now,
        endDate_gte: now,
        executed: false
      };
      break;
    case ProposalStatus.EXECUTED:
      where = {
        executed: true
      };
      break;
    case ProposalStatus.SUCCEEDED:
      where = {
        or: [{
          approvalReached: true,
          endDate_lt: now
        }, {
          earlyExecutable: true
        }]
      };
      break;
    case ProposalStatus.DEFEATED:
      where = {
        potentiallyExecutable: false,
        endDate_lt: now,
        executed: false
      };
      break;
    default:
      throw new InvalidProposalStatusError();
  }
  return where;
}

var AVAILABLE_FUNCTION_SIGNATURES$2 = [/*#__PURE__*/MajorityVotingBase__factory.createInterface().getFunction("updateVotingSettings").format("minimal"), /*#__PURE__*/AddresslistVoting__factory.createInterface().getFunction("addAddresses").format("minimal"), /*#__PURE__*/AddresslistVoting__factory.createInterface().getFunction("removeAddresses").format("minimal")];
// TODO:
// use abi from plugin metadata
var UPDATE_ABI$2 = {
  1: []
};
// TODO:
// use abi from plugin metadata
var INSTALLATION_ABI$2 = [{
  components: [{
    internalType: "enum MajorityVotingBase.VotingMode",
    name: "votingMode",
    type: "uint8",
    description: "A parameter to select the vote mode. In standard mode (0), early execution and vote replacement are disabled. In early execution mode (1), a proposal can be executed early before the end date if the vote outcome cannot mathematically change by more voters voting. In vote replacement mode (2), voters can change their vote multiple times and only the latest vote option is tallied."
  }, {
    internalType: "uint32",
    name: "supportThreshold",
    type: "uint32",
    description: "The support threshold value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`."
  }, {
    internalType: "uint32",
    name: "minParticipation",
    type: "uint32",
    description: "The minimum participation value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`."
  }, {
    internalType: "uint64",
    name: "minDuration",
    type: "uint64",
    description: "The minimum duration of the proposal vote in seconds."
  }, {
    internalType: "uint256",
    name: "minProposerVotingPower",
    type: "uint256",
    description: "The minimum voting power required to create a proposal."
  }],
  internalType: "struct MajorityVotingBase.VotingSettings",
  name: "votingSettings",
  type: "tuple",
  description: "The voting settings that will be enforced when proposals are created."
}, {
  internalType: "address[]",
  name: "members",
  type: "address[]",
  description: "The addresses of the initial members to be added."
}];

/**
 * Methods module the SDK Address List Client
 */
var AddresslistVotingClientMethods = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClientMethods, _ClientCore);
  function AddresslistVotingClientMethods() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = AddresslistVotingClientMethods.prototype;
  /**
   * Creates a new proposal on the given AddressList plugin contract
   *
   * @param {CreateMajorityVotingProposalParams} params
   * @return {AsyncGenerator<ProposalCreationStepValue>}
   * @memberof AddresslistVotingClientMethods
   */
  _proto.createProposal = function createProposal(params) {
    var _this = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var signer, addresslistContract, allowFailureMap, startTimestamp, endTimestamp, tx, receipt, addresslistContractInterface, log, parsedLog, proposalId;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = _this.web3.getConnectedSigner(); // TODO
            // implement a more sophisticated isFailingProposal function
            // if (isFailingProposal(params.actions)) {
            //   throw new AlwaysFailingProposalError();
            // }
            addresslistContract = AddresslistVoting__factory.connect(params.pluginAddress, signer);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new SizeMismatchError("failSafeActions", "actions");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return _awaitAsyncGenerator(addresslistContract.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000), params.creatorVote || 0, params.executeOnPass || false));
          case 9:
            tx = _context.sent;
            _context.next = 12;
            return {
              key: ProposalCreationSteps.CREATING,
              txHash: tx.hash
            };
          case 12:
            _context.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            receipt = _context.sent;
            addresslistContractInterface = AddresslistVoting__factory.createInterface();
            log = findLog(receipt, addresslistContractInterface, "ProposalCreated");
            if (log) {
              _context.next = 19;
              break;
            }
            throw new ProposalCreationError();
          case 19:
            parsedLog = addresslistContractInterface.parseLog(log);
            proposalId = parsedLog.args["proposalId"];
            if (proposalId) {
              _context.next = 23;
              break;
            }
            throw new ProposalCreationError();
          case 23:
            _context.next = 25;
            return {
              key: ProposalCreationSteps.DONE,
              proposalId: encodeProposalId(params.pluginAddress, Number(proposalId))
            };
          case 25:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  }
  /**
   * Pins a metadata object into IPFS and retruns the generated hash
   *
   * @param {ProposalMetadata} params
   * @return {Promise<string>}
   * @memberof ClientMethods
   */;
  _proto.pinMetadata =
  /*#__PURE__*/
  function () {
    var _pinMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var cid;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.ipfs.add(JSON.stringify(params));
          case 3:
            cid = _context2.sent;
            _context2.next = 6;
            return this.ipfs.pin(cid);
          case 6:
            return _context2.abrupt("return", "ipfs://" + cid);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](0);
            throw new IpfsPinError(_context2.t0);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[0, 9]]);
    }));
    function pinMetadata(_x) {
      return _pinMetadata.apply(this, arguments);
    }
    return pinMetadata;
  }()
  /**
   * Cast a vote on the given proposal using the client's wallet. Depending on the proposal settings, an affirmative vote may execute the proposal's actions on the DAO.
   *
   * @param {VoteProposalParams} params
   * @return {AsyncGenerator<VoteProposalStepValue>}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.voteProposal = function voteProposal(params) {
    var _this2 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var signer, _decodeProposalId, pluginAddress, id, addresslistContract, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = _this2.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, signer);
            _context3.next = 5;
            return _awaitAsyncGenerator(addresslistContract.vote(id, params.vote, false));
          case 5:
            tx = _context3.sent;
            _context3.next = 8;
            return {
              key: VoteProposalStep.VOTING,
              txHash: tx.hash
            };
          case 8:
            _context3.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context3.next = 12;
            return {
              key: VoteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }))();
  }
  /**
   * Executes the given proposal, provided that it has already passed
   *
   * @param {string} proposalId
   * @return {AsyncGenerator<ExecuteProposalStepValue>}
   * @memberof AddresslistVotingClientMethods
   */;
  _proto.executeProposal = function executeProposal(proposalId) {
    var _this3 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var signer, _decodeProposalId2, pluginAddress, id, addresslistContract, tx;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            signer = _this3.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, signer);
            _context4.next = 5;
            return _awaitAsyncGenerator(addresslistContract.execute(id));
          case 5:
            tx = _context4.sent;
            _context4.next = 8;
            return {
              key: ExecuteProposalStep.EXECUTING,
              txHash: tx.hash
            };
          case 8:
            _context4.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context4.next = 12;
            return {
              key: ExecuteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }))();
  }
  /**
   * Prepares the installation of a token voting plugin in a given dao
   *
   * @param {AddresslistVotingPluginPrepareInstallationParams} params
   * @return {AsyncGenerator<PrepareInstallationStepValue>}
   * @memberof MultisigClientMethods
   */;
  _proto.prepareInstallation = function prepareInstallation(params) {
    var _this4 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var network, aragonNetwork;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return _awaitAsyncGenerator(_this4.web3.getProvider().getNetwork());
          case 2:
            network = _context5.sent;
            aragonNetwork = getNetworkByAlias(network.name);
            if (aragonNetwork) {
              _context5.next = 6;
              break;
            }
            throw new UnsupportedNetworkError(network.name);
          case 6:
            return _context5.delegateYield(_asyncGeneratorDelegate(_asyncIterator(prepareGenericInstallation(_this4.web3, {
              daoAddressOrEns: params.daoAddressOrEns,
              pluginRepo: _this4.web3.getAddress(NonFrameworkContractsNames.ADDRESSLIST_VOTING_REPO_PROXY),
              version: params.versionTag,
              installationAbi: INSTALLATION_ABI$2,
              installationParams: [votingSettingsToContract(params.settings.votingSettings), params.settings.addresses],
              pluginSetupProcessorAddress: _this4.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR)
            }))), "t0", 7);
          case 7:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }))();
  }
  /**
   * Prepares the update of a token voting plugin in a given dao
   *
   * @param {AddresslistVotingPluginPrepareUpdateParams} params
   * @return {AsyncGenerator<PrepareUpdateStepValue>}
   * @memberof AddresslistVotingClientMethods
   */;
  _proto.prepareUpdate = function prepareUpdate(params) {
    var _this5 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.delegateYield(_asyncGeneratorDelegate(_asyncIterator(prepareGenericUpdate(_this5.web3, _this5.graphql, _extends({}, params, {
              pluginRepo: _this5.web3.getAddress(NonFrameworkContractsNames.ADDRESSLIST_VOTING_REPO_PROXY),
              updateAbi: UPDATE_ABI$2[params.newVersion.build] || params.updateAbi || [],
              pluginSetupProcessorAddress: _this5.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR)
            })))), "t0", 1);
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }))();
  }
  /**
   * Checks if an user can vote in a proposal
   *
   * @param {CanVoteParams} params
   * @return {Promise<boolean>}
   * @memberof AddresslistVotingClientMethods
   */;
  _proto.canVote =
  /*#__PURE__*/
  function () {
    var _canVote = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(params) {
      var provider, _decodeProposalId3, pluginAddress, id, addresslistContract;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            provider = this.web3.getProvider();
            _decodeProposalId3 = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId3.pluginAddress, id = _decodeProposalId3.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, provider);
            return _context7.abrupt("return", addresslistContract.callStatic.canVote(id, params.voterAddressOrEns, params.vote));
          case 4:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function canVote(_x2) {
      return _canVote.apply(this, arguments);
    }
    return canVote;
  }()
  /**
   * Checks whether the current proposal can be executed
   *
   * @param {string} proposalId
   * @return {Promise<boolean>}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.canExecute =
  /*#__PURE__*/
  function () {
    var _canExecute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(proposalId) {
      var provider, _decodeProposalId4, pluginAddress, id, addresslistContract;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            provider = this.web3.getProvider();
            _decodeProposalId4 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId4.pluginAddress, id = _decodeProposalId4.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, provider);
            return _context8.abrupt("return", addresslistContract.canExecute(id));
          case 4:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function canExecute(_x3) {
      return _canExecute.apply(this, arguments);
    }
    return canExecute;
  }()
  /**
   * Returns the list of wallet addresses with signing capabilities on the plugin
   *
   * @param {MembersQueryParams} params
   *     - pluginAddress
   *     - blockNumber
   *     - limit = 10
   *     - skip = 0
   *     - direction = SortDirection.ASC
   *     - sortBy = MembersSortBy.ADDRESS
   * @return {Promise<string[]>}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.getMembers =
  /*#__PURE__*/
  function () {
    var _getMembers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref) {
      var pluginAddress, blockNumber, _ref$limit, limit, _ref$skip, skip, _ref$direction, direction, _ref$sortBy, sortBy, query, params, name, _yield$this$graphql$r, addresslistVotingVoters;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            pluginAddress = _ref.pluginAddress, blockNumber = _ref.blockNumber, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 10 : _ref$limit, _ref$skip = _ref.skip, skip = _ref$skip === void 0 ? 0 : _ref$skip, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? SortDirection.ASC : _ref$direction, _ref$sortBy = _ref.sortBy, sortBy = _ref$sortBy === void 0 ? MembersSortBy.ADDRESS : _ref$sortBy;
            if (isAddress(pluginAddress)) {
              _context9.next = 3;
              break;
            }
            throw new InvalidAddressError();
          case 3:
            query = QueryAddresslistVotingMembers;
            params = {
              where: {
                plugin: pluginAddress.toLowerCase()
              },
              block: blockNumber ? {
                number: blockNumber
              } : null,
              skip: skip,
              limit: limit,
              direction: direction,
              sortBy: sortBy
            };
            name = "AddresslistVotingVoting members";
            _context9.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r = _context9.sent;
            addresslistVotingVoters = _yield$this$graphql$r.addresslistVotingVoters;
            return _context9.abrupt("return", addresslistVotingVoters.map(function (member) {
              return member.address;
            }));
          case 11:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function getMembers(_x4) {
      return _getMembers.apply(this, arguments);
    }
    return getMembers;
  }()
  /**
   * Returns the details of the given proposal
   *
   * @param {string} proposalId
   * @return {(Promise<AddresslistVotingProposal | null>)}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.getProposal =
  /*#__PURE__*/
  function () {
    var _getProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(proposalId) {
      var extendedProposalId, query, params, name, _yield$this$graphql$r2, addresslistVotingProposal, metadataCid, metadataString, metadata;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            if (isProposalId(proposalId)) {
              _context10.next = 2;
              break;
            }
            throw new InvalidProposalIdError();
          case 2:
            extendedProposalId = getExtendedProposalId(proposalId);
            query = QueryAddresslistVotingProposal;
            params = {
              proposalId: extendedProposalId
            };
            name = "AddresslistVoting proposal";
            _context10.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r2 = _context10.sent;
            addresslistVotingProposal = _yield$this$graphql$r2.addresslistVotingProposal;
            if (addresslistVotingProposal) {
              _context10.next = 14;
              break;
            }
            return _context10.abrupt("return", null);
          case 14:
            if (addresslistVotingProposal.metadata) {
              _context10.next = 16;
              break;
            }
            return _context10.abrupt("return", toAddresslistVotingProposal(addresslistVotingProposal, EMPTY_PROPOSAL_METADATA_LINK));
          case 16:
            _context10.prev = 16;
            metadataCid = resolveIpfsCid(addresslistVotingProposal.metadata);
            _context10.next = 20;
            return this.ipfs.fetchString(metadataCid);
          case 20:
            metadataString = _context10.sent;
            metadata = JSON.parse(metadataString);
            return _context10.abrupt("return", toAddresslistVotingProposal(addresslistVotingProposal, metadata));
          case 25:
            _context10.prev = 25;
            _context10.t0 = _context10["catch"](16);
            if (!(_context10.t0 instanceof InvalidCidError)) {
              _context10.next = 29;
              break;
            }
            return _context10.abrupt("return", toAddresslistVotingProposal(addresslistVotingProposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
          case 29:
            return _context10.abrupt("return", toAddresslistVotingProposal(addresslistVotingProposal, UNAVAILABLE_PROPOSAL_METADATA));
          case 30:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this, [[16, 25]]);
    }));
    function getProposal(_x5) {
      return _getProposal.apply(this, arguments);
    }
    return getProposal;
  }()
  /**
   * Returns a list of proposals on the Plugin, filtered by the given criteria
   *
   * @param {ProposalQueryParams} params
   *       - daoAddressOrEns
   *       - limit = 10
   *       - status
   *       - skip = 0
   *       - direction = SortDirection.ASC
   *       - sortBy = ProposalSortBy.CREATED_AT
   * @return {Promise<AddresslistVotingProposalListItem[]>}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.getProposals =
  /*#__PURE__*/
  function () {
    var _getProposals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(_ref2) {
      var _this6 = this;
      var daoAddressOrEns, _ref2$limit, limit, status, _ref2$skip, skip, _ref2$direction, direction, _ref2$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r3, addresslistVotingProposals;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            daoAddressOrEns = _ref2.daoAddressOrEns, _ref2$limit = _ref2.limit, limit = _ref2$limit === void 0 ? 10 : _ref2$limit, status = _ref2.status, _ref2$skip = _ref2.skip, skip = _ref2$skip === void 0 ? 0 : _ref2$skip, _ref2$direction = _ref2.direction, direction = _ref2$direction === void 0 ? SortDirection.ASC : _ref2$direction, _ref2$sortBy = _ref2.sortBy, sortBy = _ref2$sortBy === void 0 ? ProposalSortBy.CREATED_AT : _ref2$sortBy;
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context12.next = 23;
              break;
            }
            if (isAddress(address)) {
              _context12.next = 22;
              break;
            }
            _context12.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context12.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context12.prev = 10;
            _context12.next = 13;
            return provider.resolveName(address);
          case 13:
            resolvedAddress = _context12.sent;
            if (resolvedAddress) {
              _context12.next = 16;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 16:
            address = resolvedAddress;
            _context12.next = 22;
            break;
          case 19:
            _context12.prev = 19;
            _context12.t0 = _context12["catch"](10);
            throw new InvalidAddressOrEnsError();
          case 22:
            where = {
              dao: address.toLowerCase()
            };
          case 23:
            if (status) {
              where = _extends({}, where, computeProposalStatusFilter$2(status));
            }
            query = QueryAddresslistVotingProposals;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "AddresslistVoting proposals";
            _context12.next = 29;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 29:
            _yield$this$graphql$r3 = _context12.sent;
            addresslistVotingProposals = _yield$this$graphql$r3.addresslistVotingProposals;
            return _context12.abrupt("return", Promise.all(addresslistVotingProposals.map( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(proposal) {
                var metadataCid, stringMetadata, metadata;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) switch (_context11.prev = _context11.next) {
                    case 0:
                      if (proposal.metadata) {
                        _context11.next = 2;
                        break;
                      }
                      return _context11.abrupt("return", toAddresslistVotingProposalListItem(proposal, EMPTY_PROPOSAL_METADATA_LINK));
                    case 2:
                      _context11.prev = 2;
                      metadataCid = resolveIpfsCid(proposal.metadata); // Avoid blocking Promise.all if this individual fetch takes too long
                      _context11.next = 6;
                      return promiseWithTimeout(_this6.ipfs.fetchString(metadataCid), MULTI_FETCH_TIMEOUT);
                    case 6:
                      stringMetadata = _context11.sent;
                      metadata = JSON.parse(stringMetadata);
                      return _context11.abrupt("return", toAddresslistVotingProposalListItem(proposal, metadata));
                    case 11:
                      _context11.prev = 11;
                      _context11.t0 = _context11["catch"](2);
                      if (!(_context11.t0 instanceof InvalidCidError)) {
                        _context11.next = 15;
                        break;
                      }
                      return _context11.abrupt("return", toAddresslistVotingProposalListItem(proposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
                    case 15:
                      return _context11.abrupt("return", toAddresslistVotingProposalListItem(proposal, UNAVAILABLE_PROPOSAL_METADATA));
                    case 16:
                    case "end":
                      return _context11.stop();
                  }
                }, _callee11, null, [[2, 11]]);
              }));
              return function (_x7) {
                return _ref3.apply(this, arguments);
              };
            }())));
          case 32:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this, [[10, 19]]);
    }));
    function getProposals(_x6) {
      return _getProposals.apply(this, arguments);
    }
    return getProposals;
  }()
  /**
   * Returns the settings of a plugin given the address of the plugin instance
   *
   * @param {string} pluginAddress
   * @param {number} blockNumber
   * @return {(Promise<VotingSettings | null>)}
   * @memberof AddresslistVotingClientMethods
   */
  ;
  _proto.getVotingSettings =
  /*#__PURE__*/
  function () {
    var _getVotingSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(pluginAddress, blockNumber) {
      var query, params, name, _yield$this$graphql$r4, addresslistVotingPlugin;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context13.next = 2;
              break;
            }
            throw new InvalidAddressError();
          case 2:
            query = QueryAddresslistVotingSettings;
            params = {
              address: pluginAddress.toLowerCase(),
              block: blockNumber ? {
                number: blockNumber
              } : null
            };
            name = "AddresslistVoting settings";
            _context13.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r4 = _context13.sent;
            addresslistVotingPlugin = _yield$this$graphql$r4.addresslistVotingPlugin;
            if (addresslistVotingPlugin) {
              _context13.next = 11;
              break;
            }
            return _context13.abrupt("return", null);
          case 11:
            return _context13.abrupt("return", {
              minDuration: parseInt(addresslistVotingPlugin.minDuration),
              supportThreshold: decodeRatio(BigInt(addresslistVotingPlugin.supportThreshold), 6),
              minParticipation: decodeRatio(BigInt(addresslistVotingPlugin.minParticipation), 6),
              minProposerVotingPower: BigInt(addresslistVotingPlugin.minProposerVotingPower),
              votingMode: addresslistVotingPlugin.votingMode
            });
          case 12:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this);
    }));
    function getVotingSettings(_x8, _x9) {
      return _getVotingSettings.apply(this, arguments);
    }
    return getVotingSettings;
  }()
  /**
   * Checks if a given address is a member of the AddresslistVoting contract.
   * @param params - The parameters for the isMember method.
   * @param params.pluginAddress - The address of the plugin.
   * @param params.address - The address to check.
   * @param params.blockNumber - The block number for specifying a specific block.
   * @returns {boolean} A boolean indicating whether the address is a member or not.
   */
  ;
  _proto.isMember =
  /*#__PURE__*/
  function () {
    var _isMember = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(params) {
      var query, name, _yield$this$graphql$r5, addresslistVotingVoter;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            IsMemberSchema.strict().validateSync(params);
            query = QueryAddresslistVotingIsMember;
            name = "AddresslistVoting isMember";
            _context14.next = 5;
            return this.graphql.request({
              query: query,
              params: {
                id: params.pluginAddress.toLowerCase() + "_" + params.address.toLowerCase(),
                blockHeight: params.blockNumber ? {
                  number: params.blockNumber
                } : null
              },
              name: name
            });
          case 5:
            _yield$this$graphql$r5 = _context14.sent;
            addresslistVotingVoter = _yield$this$graphql$r5.addresslistVotingVoter;
            return _context14.abrupt("return", !!addresslistVotingVoter);
          case 8:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this);
    }));
    function isMember(_x10) {
      return _isMember.apply(this, arguments);
    }
    return isMember;
  }();
  return AddresslistVotingClientMethods;
}(ClientCore);

/**
 * Encoding module for the SDK AddressList Client
 */
var AddresslistVotingClientEncoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClientEncoding, _ClientCore);
  function AddresslistVotingClientEncoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {AddresslistVotingPluginInstall} params
   * @param {Networkish} network
   * @return {PluginInstallItem}
   * @memberof AddresslistVotingClientEncoding
   */
  AddresslistVotingClientEncoding.getPluginInstallItem = function getPluginInstallItem(params, network) {
    var _contracts$aragonNetw;
    var networkName = getNetwork(network).name;
    var aragonNetwork = getNetworkNameByAlias(networkName);
    if (!aragonNetwork) {
      throw new UnsupportedNetworkError(networkName);
    }
    var hexBytes = defaultAbiCoder.encode(getNamedTypesFromMetadata(INSTALLATION_ABI$2), [votingSettingsToContract(params.votingSettings), params.addresses]);
    var repoAddress = (_contracts$aragonNetw = contracts[aragonNetwork][SupportedVersions.V1_3_0]) == null || (_contracts$aragonNetw = _contracts$aragonNetw.AddresslistVotingRepoProxy) == null ? void 0 : _contracts$aragonNetw.address;
    if (!repoAddress) {
      throw new Error("AddresslistVotingRepoProxy address not found");
    }
    return {
      id: repoAddress,
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that updates the governance configuration
   *
   * @param {string} pluginAddress
   * @param {VotingSettings} params
   * @return {DaoAction}
   * @memberof AddresslistVotingClientEncoding
   */;
  var _proto = AddresslistVotingClientEncoding.prototype;
  _proto.updatePluginSettingsAction = function updatePluginSettingsAction(pluginAddress, params) {
    if (!isAddress(pluginAddress)) {
      throw new InvalidAddressError();
    }
    // TODO: check if to and value are correct
    return {
      to: pluginAddress,
      value: BigInt(0),
      data: encodeUpdateVotingSettingsAction(params)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that adds addresses to address list
   *
   * @param {string} pluginAddress
   * @param {string[]} members
   * @return {DaoAction}
   * @memberof AddresslistVotingClientEncoding
   */;
  _proto.addMembersAction = function addMembersAction(pluginAddress, members) {
    if (!isAddress(pluginAddress)) {
      throw new InvalidAddressError();
    }
    for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
      var member = _step.value;
      if (!isAddress(member)) {
        throw new InvalidAddressError();
      }
    }
    var votingInterface = AddresslistVoting__factory.createInterface();
    // get hex bytes
    var hexBytes = votingInterface.encodeFunctionData("addAddresses", [members]);
    return {
      to: pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that removes addresses from the address list
   *
   * @param {string} pluginAddress
   * @param {string[]} members
   * @return {DaoAction}
   * @memberof AddresslistVotingClientEncoding
   */;
  _proto.removeMembersAction = function removeMembersAction(pluginAddress, members) {
    if (!isAddress(pluginAddress)) {
      throw new InvalidAddressError();
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose(members), _step2; !(_step2 = _iterator2()).done;) {
      var member = _step2.value;
      if (!isAddress(member)) {
        throw new InvalidAddressError();
      }
    }
    var votingInterface = AddresslistVoting__factory.createInterface();
    // get hex bytes
    var hexBytes = votingInterface.encodeFunctionData("removeAddresses", [members]);
    return {
      to: pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  };
  return AddresslistVotingClientEncoding;
}(ClientCore);

/**
 * Decoding module for the SDK AddressList Client
 */
var AddresslistVotingClientDecoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClientDecoding, _ClientCore);
  function AddresslistVotingClientDecoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = AddresslistVotingClientDecoding.prototype;
  /**
   * Decodes a dao metadata from an encoded update metadata action
   *
   * @param {Uint8Array} data
   * @return {VotingSettings}
   * @memberof AddresslistVotingClientDecoding
   */
  _proto.updatePluginSettingsAction = function updatePluginSettingsAction(data) {
    return decodeUpdatePluginSettingsAction(data);
  }
  /**
   * Decodes a list of addresses from an encoded add members action
   *
   * @param {Uint8Array} data
   * @return {string[]}
   * @memberof AddresslistVotingClientDecoding
   */;
  _proto.addMembersAction = function addMembersAction(data) {
    var votingInterface = AddresslistVoting__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = votingInterface.getFunction("addAddresses");
    var result = votingInterface.decodeFunctionData(expectedfunction, hexBytes);
    return result[0];
  }
  /**
   * Decodes a list of addresses from an encoded remove members action
   *
   * @param {Uint8Array} data
   * @return {string[]}
   * @memberof AddresslistVotingClientDecoding
   */;
  _proto.removeMembersAction = function removeMembersAction(data) {
    var votingInterface = AddresslistVoting__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = votingInterface.getFunction("removeAddresses");
    var result = votingInterface.decodeFunctionData(expectedfunction, hexBytes);
    return result[0];
  }
  /**
   * Returns the decoded function info given the encoded data of an action
   *
   * @param {Uint8Array} data
   * @return {(InterfaceParams | null)}
   * @memberof AddresslistVotingClientDecoding
   */;
  _proto.findInterface = function findInterface(data) {
    try {
      var func = getFunctionFragment(data, AVAILABLE_FUNCTION_SIGNATURES$2);
      return {
        id: func.format("minimal"),
        functionName: func.name,
        hash: bytesToHex(data).substring(0, 10)
      };
    } catch (_unused) {
      return null;
    }
  };
  return AddresslistVotingClientDecoding;
}(ClientCore);

/**
 * Estimation module the SDK Address List Client
 */
var AddresslistVotingClientEstimation = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClientEstimation, _ClientCore);
  function AddresslistVotingClientEstimation() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = AddresslistVotingClientEstimation.prototype;
  /**
   * Estimates the gas fee of creating a proposal on the plugin
   *
   * @param {CreateMajorityVotingProposalParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof AddresslistVotingClientEstimation
   */
  _proto.createProposal =
  /*#__PURE__*/
  function () {
    var _createProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var provider, addresslistContract, allowFailureMap, startTimestamp, endTimestamp, estimatedGasFee;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            addresslistContract = AddresslistVoting__factory.connect(params.pluginAddress, provider);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new SizeMismatchError("failSafeActions", "actions");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return addresslistContract.estimateGas.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000), params.creatorVote || 0, params.executeOnPass || false);
          case 9:
            estimatedGasFee = _context.sent;
            return _context.abrupt("return", this.web3.getApproximateGasFee(estimatedGasFee.toBigInt()));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function createProposal(_x) {
      return _createProposal.apply(this, arguments);
    }
    return createProposal;
  }()
  /**
   * Estimates the gas fee of casting a vote on a proposal
   *
   * @param {VoteProposalParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof AddresslistVotingClientEstimation
   */
  ;
  _proto.voteProposal =
  /*#__PURE__*/
  function () {
    var _voteProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var provider, _decodeProposalId, pluginAddress, id, addresslistContract, estimation;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, provider);
            _context2.next = 5;
            return addresslistContract.estimateGas.vote(id, params.vote, false);
          case 5:
            estimation = _context2.sent;
            return _context2.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function voteProposal(_x2) {
      return _voteProposal.apply(this, arguments);
    }
    return voteProposal;
  }()
  /**
   * Estimates the gas fee of executing an AddressList proposal
   *
   * @param {string} proposalId
   * @return {Promise<GasFeeEstimation>}
   * @memberof AddresslistVotingClientEstimation
   */
  ;
  _proto.executeProposal =
  /*#__PURE__*/
  function () {
    var _executeProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(proposalId) {
      var provider, _decodeProposalId2, pluginAddress, id, addresslistContract, estimation;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            addresslistContract = AddresslistVoting__factory.connect(pluginAddress, provider);
            _context3.next = 5;
            return addresslistContract.estimateGas.execute(id);
          case 5:
            estimation = _context3.sent;
            return _context3.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function executeProposal(_x3) {
      return _executeProposal.apply(this, arguments);
    }
    return executeProposal;
  }()
  /**
   * Estimates the gas fee of preparing an update
   *
   * @param {AddresslistVotingPluginPrepareUpdateParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof AddresslistVotingClientEstimation
   */
  ;
  _proto.prepareUpdate =
  /*#__PURE__*/
  function () {
    var _prepareUpdate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return prepareGenericUpdateEstimation(this.web3, this.graphql, _extends({}, params, {
              pluginSetupProcessorAddress: this.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR),
              pluginRepo: this.web3.getAddress(NonFrameworkContractsNames.ADDRESSLIST_VOTING_REPO_PROXY)
            }));
          case 2:
            return _context4.abrupt("return", _context4.sent);
          case 3:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function prepareUpdate(_x4) {
      return _prepareUpdate.apply(this, arguments);
    }
    return prepareUpdate;
  }();
  return AddresslistVotingClientEstimation;
}(ClientCore);

var _class$2;
/**
 * Provider a generic client with high level methods to manage and interact an Address List Voting plugin installed in a DAO
 */
var AddresslistVotingClient = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(AddresslistVotingClient, _ClientCore);
  function AddresslistVotingClient(context) {
    var _this;
    _this = _ClientCore.call(this, context) || this;
    _this.methods = new AddresslistVotingClientMethods(context);
    _this.encoding = new AddresslistVotingClientEncoding(context);
    _this.decoding = new AddresslistVotingClientDecoding(context);
    _this.estimation = new AddresslistVotingClientEstimation(context);
    return _this;
  }
  return AddresslistVotingClient;
}(ClientCore);
_class$2 = AddresslistVotingClient;
_class$2.encoding = {
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {AddresslistVotingPluginInstall} params
   * @param {Networkish} [network="mainnet"]
   * @return {PluginInstallItem}
   * @memberof AddresslistVotingClient
   */
  getPluginInstallItem: function getPluginInstallItem(params, network) {
    return AddresslistVotingClientEncoding.getPluginInstallItem(params, network);
  }
};

var WrapTokensStep;
(function (WrapTokensStep) {
  WrapTokensStep["WRAPPING"] = "wrapping";
  WrapTokensStep["DONE"] = "done";
})(WrapTokensStep || (WrapTokensStep = {}));
var UnwrapTokensStep;
(function (UnwrapTokensStep) {
  UnwrapTokensStep["UNWRAPPING"] = "unwrapping";
  UnwrapTokensStep["DONE"] = "done";
})(UnwrapTokensStep || (UnwrapTokensStep = {}));

var SubgraphTokenType;
(function (SubgraphTokenType) {
  SubgraphTokenType["ERC20"] = "ERC20Token";
  SubgraphTokenType["ERC721"] = "ERC721Token";
})(SubgraphTokenType || (SubgraphTokenType = {}));
var SubgraphContractType;
(function (SubgraphContractType) {
  SubgraphContractType["ERC20"] = "ERC20Contract";
  SubgraphContractType["ERC20_WRAPPER"] = "ERC20WrapperContract";
  SubgraphContractType["ERC721"] = "ERC721Contract";
})(SubgraphContractType || (SubgraphContractType = {}));
var TokenVotingMembersSortBy;
(function (TokenVotingMembersSortBy) {
  TokenVotingMembersSortBy["ADDRESS"] = "address";
  TokenVotingMembersSortBy["BALANCE"] = "balance";
  TokenVotingMembersSortBy["VOTING_POWER"] = "votingPower";
})(TokenVotingMembersSortBy || (TokenVotingMembersSortBy = {}));
var TokenVotingTokenCompatibility;
(function (TokenVotingTokenCompatibility) {
  TokenVotingTokenCompatibility["COMPATIBLE"] = "compatible";
  TokenVotingTokenCompatibility["NEEDS_WRAPPING"] = "needsWrapping";
  TokenVotingTokenCompatibility["INCOMPATIBLE"] = "incompatible";
})(TokenVotingTokenCompatibility || (TokenVotingTokenCompatibility = {}));

var _templateObject$6, _templateObject2$3;
var QueryTokenVotingProposal = /*#__PURE__*/gql(_templateObject$6 || (_templateObject$6 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingProposal($proposalId: ID!) {\n  tokenVotingProposal(id: $proposalId){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    createdAt\n    creationBlockNumber\n    executionDate\n    executionBlockNumber\n    actions {\n      to\n      value\n      data\n    }\n    yes,\n    no,\n    abstain\n    votingMode\n    supportThreshold\n    startDate\n    endDate\n    executed\n    earlyExecutable\n    approvalReached\n    isSignaling\n    executionTxHash\n    voters(first: 1000){\n      voter{\n        address\n      }\n      voteReplaced\n      voteOption\n      votingPower\n    }\n    plugin {\n      token {\n        id\n        name\n        symbol\n        __typename\n        ...on ERC20Contract {\n          decimals\n        }\n        ...on ERC20WrapperContract {\n          decimals\n          underlyingToken{\n            id\n            name\n            symbol\n            decimals\n          }\n        }\n      }\n    }\n    totalVotingPower\n    minVotingPower\n  }\n}\n"])));
var QueryTokenVotingProposals = /*#__PURE__*/gql(_templateObject2$3 || (_templateObject2$3 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingProposals($where: TokenVotingProposal_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: TokenVotingProposal_orderBy!) {\n  tokenVotingProposals(where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    yes,\n    no,\n    abstain\n    startDate\n    endDate\n    executed\n    earlyExecutable\n    approvalReached\n    isSignaling\n    votingMode\n    supportThreshold\n    minVotingPower\n    totalVotingPower\n    actions {\n      to\n      value\n      data\n    }\n    voters{\n      voter{\n        address\n      }\n      voteReplaced\n      voteOption\n      votingPower\n    }\n    plugin{\n      token{\n        id\n        name\n        symbol\n        __typename\n        ...on ERC20Contract {\n          decimals\n        }\n        ...on ERC20WrapperContract {\n          decimals\n          underlyingToken{\n            id\n            name\n            symbol\n            decimals\n          }\n        }\n      }\n    }\n  }\n}\n"])));

var _templateObject$5;
var QueryTokenVotingSettings = /*#__PURE__*/gql(_templateObject$5 || (_templateObject$5 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingSettings($address: ID!,$block: Block_height) {\n  tokenVotingPlugin(id: $address, block: $block){\n    minDuration\n    minProposerVotingPower\n    minParticipation\n    supportThreshold\n    votingMode\n  }\n}\n"])));

var _templateObject$4;
var QueryTokenVotingPlugin = /*#__PURE__*/gql(_templateObject$4 || (_templateObject$4 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingPlugin($address: ID!) {\n  tokenVotingPlugin(id: $address){\n    token {\n      id\n      name\n      symbol\n      __typename\n      ...on ERC20WrapperContract {\n        decimals\n        underlyingToken{\n          id\n          name\n          symbol\n          decimals\n        }\n      }\n      ...on ERC20Contract {\n        decimals\n      }\n    }\n  }\n}\n"])));

var _templateObject$3, _templateObject2$2;
var QueryTokenVotingMembers = /*#__PURE__*/gql(_templateObject$3 || (_templateObject$3 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingMembers($where: TokenVotingMember_filter!, $block: Block_height, $limit: Int!, $skip: Int!, $sortBy: TokenVotingMember_orderBy!, $direction: OrderDirection!) {\n  tokenVotingMembers(\n    where: $where\n    block: $block\n    first: $limit\n    skip: $skip\n    orderBy: $sortBy\n    orderDirection: $direction\n  ) {\n    address\n    balance\n    votingPower\n    delegatee{\n      address\n    }\n    delegators{\n      address\n      balance\n    }\n  }\n}\n"])));
var QueryTokenVotingIsMember = /*#__PURE__*/gql(_templateObject2$2 || (_templateObject2$2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery TokenVotingIsMember($id: ID!, $block: Block_height) {\n  tokenVotingMember(\n    id: $id\n    block: $block\n  ) {\n    id\n  }\n}"])));

function toTokenVotingProposal(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  var creationDate = new Date(parseInt(proposal.createdAt) * 1000);
  var executionDate = proposal.executionDate ? new Date(parseInt(proposal.executionDate) * 1000) : null;
  var usedVotingWeight = BigInt(0);
  for (var _iterator = _createForOfIteratorHelperLoose(proposal.voters), _step; !(_step = _iterator()).done;) {
    var voter = _step.value;
    usedVotingWeight += BigInt(voter.votingPower);
  }
  var token = parseToken(proposal.plugin.token);
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary,
      description: metadata.description,
      resources: metadata.resources,
      media: metadata.media
    },
    metadataHash: proposal.metadata,
    startDate: startDate,
    endDate: endDate,
    creationDate: creationDate,
    creationBlockNumber: parseInt(proposal.creationBlockNumber),
    executionDate: executionDate,
    executionBlockNumber: parseInt(proposal.executionBlockNumber) || null,
    executionTxHash: proposal.executionTxHash || null,
    actions: proposal.actions.map(function (action) {
      return {
        data: hexToBytes(action.data),
        to: action.to,
        value: BigInt(action.value)
      };
    }),
    status: computeProposalStatus$1(proposal),
    result: {
      yes: proposal.yes ? BigInt(proposal.yes) : BigInt(0),
      no: proposal.no ? BigInt(proposal.no) : BigInt(0),
      abstain: proposal.abstain ? BigInt(proposal.abstain) : BigInt(0)
    },
    settings: {
      supportThreshold: decodeRatio(BigInt(proposal.supportThreshold), 6),
      duration: parseInt(proposal.endDate) - parseInt(proposal.startDate),
      minParticipation: decodeRatio(BigInt(proposal.minVotingPower) * BigInt(1000000) / BigInt(proposal.totalVotingPower), 6)
    },
    token: token,
    usedVotingWeight: usedVotingWeight,
    totalVotingWeight: BigInt(proposal.totalVotingPower),
    votes: proposal.voters.map(function (voter) {
      return {
        voteReplaced: voter.voteReplaced,
        address: voter.voter.address,
        vote: SubgraphVoteValuesMap.get(voter.voteOption),
        weight: BigInt(voter.votingPower)
      };
    })
  };
}
function toTokenVotingProposalListItem(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  var token = parseToken(proposal.plugin.token);
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    settings: {
      supportThreshold: decodeRatio(BigInt(proposal.supportThreshold), 6),
      duration: parseInt(proposal.endDate) - parseInt(proposal.startDate),
      minParticipation: decodeRatio(BigInt(proposal.minVotingPower) * BigInt(1000000) / BigInt(proposal.totalVotingPower), 6)
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary
    },
    metadataHash: proposal.metadata,
    totalVotingWeight: BigInt(proposal.totalVotingPower),
    startDate: startDate,
    endDate: endDate,
    status: computeProposalStatus$1(proposal),
    result: {
      yes: proposal.yes ? BigInt(proposal.yes) : BigInt(0),
      no: proposal.no ? BigInt(proposal.no) : BigInt(0),
      abstain: proposal.abstain ? BigInt(proposal.abstain) : BigInt(0)
    },
    token: token,
    votes: proposal.voters.map(function (voter) {
      return {
        voteReplaced: voter.voteReplaced,
        address: voter.voter.address,
        vote: SubgraphVoteValuesMap.get(voter.voteOption),
        weight: BigInt(voter.votingPower)
      };
    }),
    actions: proposal.actions.map(function (action) {
      return {
        data: hexToBytes(action.data),
        to: action.to,
        value: BigInt(action.value)
      };
    })
  };
}
function mintTokenParamsToContract(params) {
  return [params.address, BigNumber.from(params.amount)];
}
function mintTokenParamsFromContract(result) {
  return {
    address: result[0],
    amount: BigInt(result[1])
  };
}
function tokenVotingInitParamsToContract(params) {
  var token = ["", "", ""];
  var balances = [[], []];
  if (params.newToken) {
    token = [AddressZero, params.newToken.name, params.newToken.symbol];
    balances = [params.newToken.balances.map(function (balance) {
      return balance.address;
    }), params.newToken.balances.map(function (_ref) {
      var balance = _ref.balance;
      return BigNumber.from(balance);
    })];
  } else if (params.useToken) {
    var _params$useToken;
    token = [(_params$useToken = params.useToken) == null ? void 0 : _params$useToken.tokenAddress, params.useToken.wrappedToken.name, params.useToken.wrappedToken.symbol];
  }
  return [votingSettingsToContract(params.votingSettings), token, balances];
}
function parseToken(subgraphToken) {
  var token = null;
  if (subgraphToken.__typename === SubgraphContractType.ERC20) {
    token = {
      address: subgraphToken.id,
      symbol: subgraphToken.symbol,
      name: subgraphToken.name,
      decimals: subgraphToken.decimals,
      type: TokenType.ERC20
    };
  } else if (subgraphToken.__typename === SubgraphContractType.ERC721) {
    token = {
      address: subgraphToken.id,
      symbol: subgraphToken.symbol,
      name: subgraphToken.name,
      type: TokenType.ERC721
    };
  } else if (subgraphToken.__typename === SubgraphContractType.ERC20_WRAPPER) {
    token = {
      address: subgraphToken.id,
      symbol: subgraphToken.symbol,
      name: subgraphToken.name,
      decimals: subgraphToken.decimals,
      type: TokenType.ERC20,
      underlyingToken: {
        address: subgraphToken.underlyingToken.id,
        symbol: subgraphToken.underlyingToken.symbol,
        name: subgraphToken.underlyingToken.name,
        decimals: subgraphToken.underlyingToken.decimals,
        type: TokenType.ERC20
      }
    };
  }
  return token;
}
function toTokenVotingMember(member) {
  var _member$delegatee;
  return {
    address: member.address,
    votingPower: BigInt(member.votingPower),
    balance: BigInt(member.balance),
    delegatee: ((_member$delegatee = member.delegatee) == null ? void 0 : _member$delegatee.address) === member.address || !member.delegatee ? null : member.delegatee.address,
    delegators: member.delegators.filter(function (delegator) {
      return delegator.address !== member.address;
    }).map(function (delegator) {
      return {
        address: delegator.address,
        balance: BigInt(delegator.balance)
      };
    })
  };
}
function computeProposalStatus$1(proposal) {
  var now = new Date();
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  // The proposal is executed so the status becomes EXECUTED
  // independently of the other conditions
  if (proposal.executed) {
    return ProposalStatus.EXECUTED;
  }
  // The proposal is not executed and the start date is in the future
  // so the status becomes PENDING
  if (startDate >= now) {
    return ProposalStatus.PENDING;
  }
  // The proposal is not executed and the start date is in the past.
  // Accordingly, we check if the proposal reached enough approval
  // (i.e., that the supportThreshold and minParticipation criteria are both met).
  // If approvalReached is true and the vote has ended (end date is in the past), it has succeeded.
  // This applies to normal mode and vote replacement mode.
  if (proposal.approvalReached && endDate <= now) {
    return ProposalStatus.SUCCEEDED;
  }
  // In early exeuction mode, we calculate if subsequent voting can change the result of the vote.
  // If not, the proposal is early executable and is therefore succeeded as well.
  if (proposal.earlyExecutable) {
    return ProposalStatus.SUCCEEDED;
  }
  // The proposal is not executed and the start date is in the past
  // and the approval threshold is not reached
  // If the end date is in the future this means that you can still vote
  // so the status becomes ACTIVE
  if (now < endDate) {
    return ProposalStatus.ACTIVE;
  }
  // If none of the other conditions are met the status becomes DEFEATED
  return ProposalStatus.DEFEATED;
}
function computeProposalStatusFilter$1(status) {
  var where = {};
  var now = Math.round(new Date().getTime() / 1000).toString();
  switch (status) {
    case ProposalStatus.PENDING:
      where = {
        startDate_gte: now
      };
      break;
    case ProposalStatus.ACTIVE:
      where = {
        startDate_lt: now,
        endDate_gte: now,
        executed: false
      };
      break;
    case ProposalStatus.EXECUTED:
      where = {
        executed: true
      };
      break;
    case ProposalStatus.SUCCEEDED:
      where = {
        or: [{
          approvalReached: true,
          endDate_lt: now
        }, {
          earlyExecutable: true
        }]
      };
      break;
    case ProposalStatus.DEFEATED:
      where = {
        potentiallyExecutable: false,
        endDate_lt: now,
        executed: false
      };
      break;
    default:
      throw new InvalidProposalStatusError();
  }
  return where;
}
/**
 * Checks if the given address is an ERC20 token
 * This function is not 100% accurate.
 * It just checks if the token has a balanceOf
 * function and a decimals function
 *
 * @export
 * @param {string} tokenAddress
 * @param {Signer} signer
 * @return {Promise<boolean>}
 */
function isERC20Token(_x, _x2) {
  return _isERC20Token.apply(this, arguments);
}
function _isERC20Token() {
  _isERC20Token = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tokenAddress, signer) {
    var contract;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          contract = new Contract(tokenAddress, abi, signer);
          _context.prev = 1;
          _context.next = 4;
          return Promise.all([contract.balanceOf(AddressZero), contract.decimals()]);
        case 4:
          return _context.abrupt("return", true);
        case 7:
          _context.prev = 7;
          _context.t0 = _context["catch"](1);
          return _context.abrupt("return", false);
        case 10:
        case "end":
          return _context.stop();
      }
    }, _callee, null, [[1, 7]]);
  }));
  return _isERC20Token.apply(this, arguments);
}

var AVAILABLE_FUNCTION_SIGNATURES$1 = [/*#__PURE__*/MajorityVotingBase__factory.createInterface().getFunction("updateVotingSettings").format("minimal"), /*#__PURE__*/IERC20MintableUpgradeable__factory.createInterface().getFunction("mint").format("minimal")];
// TODO:
// use abi from plugin metadata
var UPDATE_ABI$1 = {
  1: []
};
// TODO:
// use abi from plugin metadata
var INSTALLATION_ABI$1 = [{
  components: [{
    internalType: "enum MajorityVotingBase.VotingMode",
    name: "votingMode",
    type: "uint8",
    description: "A parameter to select the vote mode. In standard mode (0), early execution and vote replacement are disabled. In early execution mode (1), a proposal can be executed early before the end date if the vote outcome cannot mathematically change by more voters voting. In vote replacement mode (2), voters can change their vote multiple times and only the latest vote option is tallied."
  }, {
    internalType: "uint32",
    name: "supportThreshold",
    type: "uint32",
    description: "The support threshold value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`."
  }, {
    internalType: "uint32",
    name: "minParticipation",
    type: "uint32",
    description: "The minimum participation value. Its value has to be in the interval [0, 10^6] defined by `RATIO_BASE = 10**6`."
  }, {
    internalType: "uint64",
    name: "minDuration",
    type: "uint64",
    description: "The minimum duration of the proposal vote in seconds."
  }, {
    internalType: "uint256",
    name: "minProposerVotingPower",
    type: "uint256",
    description: "The minimum voting power required to create a proposal."
  }],
  internalType: "struct MajorityVotingBase.VotingSettings",
  name: "votingSettings",
  type: "tuple",
  description: "The voting settings that will be enforced when proposals are created."
}, {
  components: [{
    internalType: "address",
    name: "token",
    type: "address",
    description: "The token address. If this is `address(0)`, a new `GovernanceERC20` token is deployed. If not, the existing token is wrapped as an `GovernanceWrappedERC20`."
  }, {
    internalType: "string",
    name: "name",
    type: "string",
    description: "The token name. This parameter is only relevant if the token address is `address(0)`."
  }, {
    internalType: "string",
    name: "symbol",
    type: "string",
    description: "The token symbol. This parameter is only relevant if the token address is `address(0)`."
  }],
  internalType: "struct TokenVotingSetup.TokenSettings",
  name: "tokenSettings",
  type: "tuple",
  description: "The token settings that either specify an existing ERC-20 token (`token = address(0)`) or the name and symbol of a new `GovernanceERC20` token to be created."
}, {
  components: [{
    internalType: "address[]",
    name: "receivers",
    type: "address[]",
    description: "The receivers of the tokens."
  }, {
    internalType: "uint256[]",
    name: "amounts",
    type: "uint256[]",
    description: "The amounts of tokens to be minted for each receiver."
  }],
  internalType: "struct GovernanceERC20.MintSettings",
  name: "mintSettings",
  type: "tuple",
  description: "The token mint settings struct containing the `receivers` and `amounts`."
}];
var ERC165_INTERFACE_ID = /*#__PURE__*/getInterfaceId( /*#__PURE__*/new Interface(abi$3));
var GOVERNANCE_SUPPORTED_INTERFACE_IDS = [/*#__PURE__*/getInterfaceId( /*#__PURE__*/new Interface(abi$4)), /*#__PURE__*/getInterfaceId( /*#__PURE__*/new Interface(abi$5)), /*#__PURE__*/getInterfaceId( /*#__PURE__*/IGovernanceWrappedERC20__factory.createInterface())];

/**
 * Methods module the SDK TokenVoting Client
 */
var TokenVotingClientMethods = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClientMethods, _ClientCore);
  function TokenVotingClientMethods() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = TokenVotingClientMethods.prototype;
  /**
   * Creates a new proposal on the given TokenVoting plugin contract
   *
   * @param {CreateMajorityVotingProposalParams} params
   * @return {AsyncGenerator<ProposalCreationStepValue>}
   * @memberof TokenVotingClient
   */
  _proto.createProposal = function createProposal(params) {
    var _this = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var signer, tokenVotingContract, allowFailureMap, startTimestamp, endTimestamp, tx, receipt, tokenVotingContractInterface, log, parsedLog, proposalId;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = _this.web3.getConnectedSigner();
            tokenVotingContract = TokenVoting__factory.connect(params.pluginAddress, signer);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new SizeMismatchError("failSafeActions", "actions");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return _awaitAsyncGenerator(tokenVotingContract.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000), params.creatorVote || 0, params.executeOnPass || false));
          case 9:
            tx = _context.sent;
            _context.next = 12;
            return {
              key: ProposalCreationSteps.CREATING,
              txHash: tx.hash
            };
          case 12:
            _context.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            receipt = _context.sent;
            tokenVotingContractInterface = TokenVoting__factory.createInterface();
            log = findLog(receipt, tokenVotingContractInterface, "ProposalCreated");
            if (log) {
              _context.next = 19;
              break;
            }
            throw new ProposalCreationError();
          case 19:
            parsedLog = tokenVotingContractInterface.parseLog(log);
            proposalId = parsedLog.args["proposalId"];
            if (proposalId) {
              _context.next = 23;
              break;
            }
            throw new ProposalCreationError();
          case 23:
            _context.next = 25;
            return {
              key: ProposalCreationSteps.DONE,
              proposalId: encodeProposalId(params.pluginAddress, Number(proposalId))
            };
          case 25:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  }
  /**
   * Pins a metadata object into IPFS and retruns the generated hash
   *
   * @param {ProposalMetadata} params
   * @return {Promise<string>}
   * @memberof ClientMethods
   */;
  _proto.pinMetadata =
  /*#__PURE__*/
  function () {
    var _pinMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var cid;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.ipfs.add(JSON.stringify(params));
          case 3:
            cid = _context2.sent;
            _context2.next = 6;
            return this.ipfs.pin(cid);
          case 6:
            return _context2.abrupt("return", "ipfs://" + cid);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](0);
            throw new IpfsPinError(_context2.t0);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[0, 9]]);
    }));
    function pinMetadata(_x) {
      return _pinMetadata.apply(this, arguments);
    }
    return pinMetadata;
  }()
  /**
   * Cast a vote on the given proposal using the client's wallet. Depending on the proposal settings, an affirmative vote may execute the proposal's actions on the DAO.
   *
   * @param {VoteProposalParams} params
   * @param {VoteValues} vote
   * @return {AsyncGenerator<VoteProposalStepValue>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.voteProposal = function voteProposal(params) {
    var _this2 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var signer, _decodeProposalId, pluginAddress, id, tokenVotingContract, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = _this2.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, signer);
            _context3.next = 5;
            return _awaitAsyncGenerator(tokenVotingContract.vote(id, params.vote, false));
          case 5:
            tx = _context3.sent;
            _context3.next = 8;
            return {
              key: VoteProposalStep.VOTING,
              txHash: tx.hash
            };
          case 8:
            _context3.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context3.next = 12;
            return {
              key: VoteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }))();
  }
  /**
   * Executes the given proposal, provided that it has already passed
   *
   * @param {string} proposalId
   * @return {AsyncGenerator<ExecuteProposalStepValue>}
   * @memberof TokenVotingClient
   */;
  _proto.executeProposal = function executeProposal(proposalId) {
    var _this3 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var signer, _decodeProposalId2, pluginAddress, id, tokenVotingContract, tx;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            signer = _this3.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, signer);
            _context4.next = 5;
            return _awaitAsyncGenerator(tokenVotingContract.execute(id));
          case 5:
            tx = _context4.sent;
            _context4.next = 8;
            return {
              key: ExecuteProposalStep.EXECUTING,
              txHash: tx.hash
            };
          case 8:
            _context4.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context4.next = 12;
            return {
              key: ExecuteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }))();
  }
  /**
   * Prepares the installation of a token voting plugin in a given dao
   *
   * @param {TokenVotingPluginPrepareInstallationParams} params
   * @return {AsyncGenerator<PrepareInstallationStepValue>}
   * @memberof TokenVotingClientMethods
   */;
  _proto.prepareInstallation = function prepareInstallation(params) {
    var _this4 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var network, networkName, aragonNetwork;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return _awaitAsyncGenerator(_this4.web3.getProvider().getNetwork());
          case 2:
            network = _context5.sent;
            networkName = network.name;
            aragonNetwork = getNetworkNameByAlias(networkName);
            if (aragonNetwork) {
              _context5.next = 7;
              break;
            }
            throw new UnsupportedNetworkError(networkName);
          case 7:
            return _context5.delegateYield(_asyncGeneratorDelegate(_asyncIterator(prepareGenericInstallation(_this4.web3, {
              daoAddressOrEns: params.daoAddressOrEns,
              pluginRepo: _this4.web3.getAddress(NonFrameworkContractsNames.TOKEN_VOTING_REPO_PROXY),
              version: params.versionTag,
              installationAbi: INSTALLATION_ABI$1,
              installationParams: tokenVotingInitParamsToContract(params.settings),
              pluginSetupProcessorAddress: _this4.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR)
            }))), "t0", 8);
          case 8:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }))();
  }
  /**
   * Prepares the update of a token voting plugin in a given dao
   *
   * @param {TokenVotingPluginPrepareUpdateParams} params
   * @return {AsyncGenerator<PrepareUpdateStepValue>}
   * @memberof TokenVotingClientMethods
   */;
  _proto.prepareUpdate = function prepareUpdate(params) {
    var _this5 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.delegateYield(_asyncGeneratorDelegate(_asyncIterator(prepareGenericUpdate(_this5.web3, _this5.graphql, _extends({}, params, {
              pluginRepo: _this5.web3.getAddress(NonFrameworkContractsNames.TOKEN_VOTING_REPO_PROXY),
              updateAbi: UPDATE_ABI$1[params.newVersion.build] || params.updateAbi || [],
              pluginSetupProcessorAddress: _this5.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR)
            })))), "t0", 1);
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }))();
  };
  _proto.wrapTokens = function wrapTokens(params) {
    var _this6 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var signer, wrappedErc20Contract, account, tx;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            signer = _this6.web3.getConnectedSigner();
            if (isAddress(params.wrappedTokenAddress)) {
              _context7.next = 3;
              break;
            }
            throw new InvalidAddressError();
          case 3:
            wrappedErc20Contract = GovernanceWrappedERC20__factory.connect(params.wrappedTokenAddress, signer);
            _context7.next = 6;
            return _awaitAsyncGenerator(signer.getAddress());
          case 6:
            account = _context7.sent;
            _context7.next = 9;
            return _awaitAsyncGenerator(wrappedErc20Contract.depositFor(account, params.amount));
          case 9:
            tx = _context7.sent;
            _context7.next = 12;
            return {
              key: WrapTokensStep.WRAPPING,
              txHash: tx.hash
            };
          case 12:
            _context7.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            _context7.next = 16;
            return {
              key: WrapTokensStep.DONE
            };
          case 16:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }))();
  };
  _proto.unwrapTokens = function unwrapTokens(params) {
    var _this7 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var signer, wrappedErc20Contract, account, tx;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            signer = _this7.web3.getConnectedSigner();
            if (isAddress(params.wrappedTokenAddress)) {
              _context8.next = 3;
              break;
            }
            throw new InvalidAddressError();
          case 3:
            wrappedErc20Contract = GovernanceWrappedERC20__factory.connect(params.wrappedTokenAddress, signer);
            _context8.next = 6;
            return _awaitAsyncGenerator(signer.getAddress());
          case 6:
            account = _context8.sent;
            _context8.next = 9;
            return _awaitAsyncGenerator(wrappedErc20Contract.withdrawTo(account, params.amount));
          case 9:
            tx = _context8.sent;
            _context8.next = 12;
            return {
              key: UnwrapTokensStep.UNWRAPPING,
              txHash: tx.hash
            };
          case 12:
            _context8.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            _context8.next = 16;
            return {
              key: UnwrapTokensStep.DONE
            };
          case 16:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }))();
  }
  /**
   * Delegates all the signer's voting power to a delegatee
   *
   * @param {DelegateTokensParams} params
   * @return {AsyncGenerator<DelegateTokensStepValue>}
   * @memberof TokenVotingClientMethods
   */;
  _proto.delegateTokens = function delegateTokens(params) {
    var _this8 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      var signer, governanceErc20Contract, tx;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            signer = _this8.web3.getConnectedSigner();
            governanceErc20Contract = GovernanceERC20__factory.connect(params.tokenAddress, signer);
            _context9.next = 4;
            return _awaitAsyncGenerator(governanceErc20Contract.delegate(params.delegatee));
          case 4:
            tx = _context9.sent;
            _context9.next = 7;
            return {
              key: "delegating" /* DelegateTokensStep.DELEGATING */,
              txHash: tx.hash
            };
          case 7:
            _context9.next = 9;
            return _awaitAsyncGenerator(tx.wait());
          case 9:
            _context9.next = 11;
            return {
              key: "done" /* DelegateTokensStep.DONE */
            };
          case 11:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }))();
  }
  /**
   * Delegates all the signer's tokens back to itself
   *
   * @param {string} tokenAddress
   * @return {AsyncGenerator<UndelegateTokensStepValue>}
   * @memberof TokenVotingClientMethods
   */;
  _proto.undelegateTokens = function undelegateTokens(tokenAddress) {
    var _this9 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      var signer;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            signer = _this9.web3.getConnectedSigner();
            _context10.t0 = _asyncGeneratorDelegate;
            _context10.t1 = _asyncIterator;
            _context10.t2 = _this9;
            _context10.t3 = tokenAddress;
            _context10.next = 7;
            return _awaitAsyncGenerator(signer.getAddress());
          case 7:
            _context10.t4 = _context10.sent;
            _context10.t5 = {
              tokenAddress: _context10.t3,
              delegatee: _context10.t4
            };
            _context10.t6 = _context10.t2.delegateTokens.call(_context10.t2, _context10.t5);
            _context10.t7 = (0, _context10.t1)(_context10.t6);
            _context10.t8 = _awaitAsyncGenerator;
            return _context10.delegateYield((0, _context10.t0)(_context10.t7, _context10.t8), "t9", 13);
          case 13:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }))();
  }
  /**
   * Retrieves the current signer's delegatee for the given token
   *
   * @param {string} tokenAddress
   * @return {Promise<string | null>}
   * @memberof TokenVotingClientMethods
   */;
  _proto.getDelegatee =
  /*#__PURE__*/
  function () {
    var _getDelegatee = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(tokenAddress) {
      var signer, governanceErc20Contract, address, delegatee;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            governanceErc20Contract = GovernanceERC20__factory.connect(tokenAddress, signer);
            _context11.next = 4;
            return signer.getAddress();
          case 4:
            address = _context11.sent;
            _context11.next = 7;
            return governanceErc20Contract.delegates(address);
          case 7:
            delegatee = _context11.sent;
            return _context11.abrupt("return", address === delegatee ? null : delegatee);
          case 9:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this);
    }));
    function getDelegatee(_x2) {
      return _getDelegatee.apply(this, arguments);
    }
    return getDelegatee;
  }()
  /**
   * Checks if an user can vote in a proposal
   *
   * @param {CanVoteParams} params
   * @returns   {Promise<boolean>}
   */
  ;
  _proto.canVote =
  /*#__PURE__*/
  function () {
    var _canVote = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(params) {
      var provider, _decodeProposalId3, pluginAddress, id, tokenVotingContract;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            provider = this.web3.getProvider();
            if (isAddress(params.voterAddressOrEns)) {
              _context12.next = 3;
              break;
            }
            throw new InvalidAddressError();
          case 3:
            _decodeProposalId3 = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId3.pluginAddress, id = _decodeProposalId3.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, provider);
            return _context12.abrupt("return", tokenVotingContract.callStatic.canVote(id, params.voterAddressOrEns, params.vote));
          case 6:
          case "end":
            return _context12.stop();
        }
      }, _callee12, this);
    }));
    function canVote(_x3) {
      return _canVote.apply(this, arguments);
    }
    return canVote;
  }()
  /**
   * Checks whether the current proposal can be executed
   *
   * @param {string} proposalId
   * @return {Promise<boolean>}
   * @memberof TokenVotingClientMethods
   */
  ;
  _proto.canExecute =
  /*#__PURE__*/
  function () {
    var _canExecute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(proposalId) {
      var provider, _decodeProposalId4, pluginAddress, id, tokenVotingContract;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            provider = this.web3.getProvider();
            _decodeProposalId4 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId4.pluginAddress, id = _decodeProposalId4.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, provider);
            return _context13.abrupt("return", tokenVotingContract.canExecute(id));
          case 4:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this);
    }));
    function canExecute(_x4) {
      return _canExecute.apply(this, arguments);
    }
    return canExecute;
  }()
  /**
   * Returns the list of wallet addresses holding tokens from the underlying Token contract used by the plugin
   *
   * @param {MembersQueryParams} params
   *     - pluginAddress
   *     - blockNumber
   *     - limit = 10
   *     - skip = 0
   *     - direction = SortDirection.ASC
   *     - sortBy = MembersSortBy.ADDRESS
   * @return {Promise<string[]>}
   * @memberof TokenVotingClientMethods
   */
  ;
  _proto.getMembers =
  /*#__PURE__*/
  function () {
    var _getMembers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref) {
      var pluginAddress, blockNumber, _ref$limit, limit, _ref$skip, skip, _ref$direction, direction, _ref$sortBy, sortBy, query, params, name, _yield$this$graphql$r, tokenVotingMembers;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            pluginAddress = _ref.pluginAddress, blockNumber = _ref.blockNumber, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 10 : _ref$limit, _ref$skip = _ref.skip, skip = _ref$skip === void 0 ? 0 : _ref$skip, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? SortDirection.ASC : _ref$direction, _ref$sortBy = _ref.sortBy, sortBy = _ref$sortBy === void 0 ? TokenVotingMembersSortBy.VOTING_POWER : _ref$sortBy;
            if (isAddress(pluginAddress)) {
              _context14.next = 3;
              break;
            }
            throw new InvalidAddressError();
          case 3:
            query = QueryTokenVotingMembers;
            params = {
              where: {
                plugin: pluginAddress.toLowerCase()
              },
              block: blockNumber ? {
                number: blockNumber
              } : null,
              skip: skip,
              limit: limit,
              direction: direction,
              sortBy: sortBy
            };
            name = "TokenVoting members";
            _context14.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r = _context14.sent;
            tokenVotingMembers = _yield$this$graphql$r.tokenVotingMembers;
            return _context14.abrupt("return", tokenVotingMembers.map(function (member) {
              return toTokenVotingMember(member);
            }));
          case 11:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this);
    }));
    function getMembers(_x5) {
      return _getMembers.apply(this, arguments);
    }
    return getMembers;
  }()
  /**
   * Returns the details of the given proposal
   *
   * @param {string} proposalId
   * @return {Promise<TokenVotingProposal>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.getProposal =
  /*#__PURE__*/
  function () {
    var _getProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(proposalId) {
      var extendedProposalId, query, params, name, _yield$this$graphql$r2, tokenVotingProposal, metadataCid, metadataString, metadata;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            if (isProposalId(proposalId)) {
              _context15.next = 2;
              break;
            }
            throw new InvalidProposalIdError();
          case 2:
            extendedProposalId = getExtendedProposalId(proposalId);
            query = QueryTokenVotingProposal;
            params = {
              proposalId: extendedProposalId
            };
            name = "TokenVoting proposal";
            _context15.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r2 = _context15.sent;
            tokenVotingProposal = _yield$this$graphql$r2.tokenVotingProposal;
            if (tokenVotingProposal) {
              _context15.next = 14;
              break;
            }
            return _context15.abrupt("return", null);
          case 14:
            if (tokenVotingProposal.metadata) {
              _context15.next = 16;
              break;
            }
            return _context15.abrupt("return", toTokenVotingProposal(tokenVotingProposal, EMPTY_PROPOSAL_METADATA_LINK));
          case 16:
            _context15.prev = 16;
            metadataCid = resolveIpfsCid(tokenVotingProposal.metadata);
            _context15.next = 20;
            return this.ipfs.fetchString(metadataCid);
          case 20:
            metadataString = _context15.sent;
            metadata = JSON.parse(metadataString);
            return _context15.abrupt("return", toTokenVotingProposal(tokenVotingProposal, metadata));
          case 25:
            _context15.prev = 25;
            _context15.t0 = _context15["catch"](16);
            if (!(_context15.t0 instanceof InvalidCidError)) {
              _context15.next = 29;
              break;
            }
            return _context15.abrupt("return", toTokenVotingProposal(tokenVotingProposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
          case 29:
            return _context15.abrupt("return", toTokenVotingProposal(tokenVotingProposal, UNAVAILABLE_PROPOSAL_METADATA));
          case 30:
          case "end":
            return _context15.stop();
        }
      }, _callee15, this, [[16, 25]]);
    }));
    function getProposal(_x6) {
      return _getProposal.apply(this, arguments);
    }
    return getProposal;
  }()
  /**
   * Returns a list of proposals on the Plugin, filtered by the given criteria
   *
   * @param {ProposalQueryParams} params
   * @return {Promise<TokenVotingProposalListItem[]>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.getProposals =
  /*#__PURE__*/
  function () {
    var _getProposals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(_ref2) {
      var _this10 = this;
      var daoAddressOrEns, _ref2$limit, limit, status, _ref2$skip, skip, _ref2$direction, direction, _ref2$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r3, tokenVotingProposals;
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            daoAddressOrEns = _ref2.daoAddressOrEns, _ref2$limit = _ref2.limit, limit = _ref2$limit === void 0 ? 10 : _ref2$limit, status = _ref2.status, _ref2$skip = _ref2.skip, skip = _ref2$skip === void 0 ? 0 : _ref2$skip, _ref2$direction = _ref2.direction, direction = _ref2$direction === void 0 ? SortDirection.ASC : _ref2$direction, _ref2$sortBy = _ref2.sortBy, sortBy = _ref2$sortBy === void 0 ? ProposalSortBy.CREATED_AT : _ref2$sortBy;
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context17.next = 23;
              break;
            }
            if (isAddress(address)) {
              _context17.next = 22;
              break;
            }
            _context17.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context17.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context17.prev = 10;
            _context17.next = 13;
            return provider.resolveName(address);
          case 13:
            resolvedAddress = _context17.sent;
            if (resolvedAddress) {
              _context17.next = 16;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 16:
            address = resolvedAddress;
            _context17.next = 22;
            break;
          case 19:
            _context17.prev = 19;
            _context17.t0 = _context17["catch"](10);
            throw new InvalidAddressOrEnsError(_context17.t0);
          case 22:
            where = {
              dao: address.toLowerCase()
            };
          case 23:
            if (status) {
              where = _extends({}, where, computeProposalStatusFilter$1(status));
            }
            query = QueryTokenVotingProposals;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "TokenVoting proposals";
            _context17.next = 29;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 29:
            _yield$this$graphql$r3 = _context17.sent;
            tokenVotingProposals = _yield$this$graphql$r3.tokenVotingProposals;
            return _context17.abrupt("return", Promise.all(tokenVotingProposals.map( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(proposal) {
                var metadataCid, stringMetadata, metadata;
                return _regeneratorRuntime().wrap(function _callee16$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      if (proposal.metadata) {
                        _context16.next = 2;
                        break;
                      }
                      return _context16.abrupt("return", toTokenVotingProposalListItem(proposal, EMPTY_PROPOSAL_METADATA_LINK));
                    case 2:
                      _context16.prev = 2;
                      metadataCid = resolveIpfsCid(proposal.metadata); // Avoid blocking Promise.all if this individual fetch takes too long
                      _context16.next = 6;
                      return promiseWithTimeout(_this10.ipfs.fetchString(metadataCid), MULTI_FETCH_TIMEOUT);
                    case 6:
                      stringMetadata = _context16.sent;
                      metadata = JSON.parse(stringMetadata);
                      return _context16.abrupt("return", toTokenVotingProposalListItem(proposal, metadata));
                    case 11:
                      _context16.prev = 11;
                      _context16.t0 = _context16["catch"](2);
                      if (!(_context16.t0 instanceof InvalidCidError)) {
                        _context16.next = 15;
                        break;
                      }
                      return _context16.abrupt("return", toTokenVotingProposalListItem(proposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
                    case 15:
                      return _context16.abrupt("return", toTokenVotingProposalListItem(proposal, UNAVAILABLE_PROPOSAL_METADATA));
                    case 16:
                    case "end":
                      return _context16.stop();
                  }
                }, _callee16, null, [[2, 11]]);
              }));
              return function (_x8) {
                return _ref3.apply(this, arguments);
              };
            }())));
          case 32:
          case "end":
            return _context17.stop();
        }
      }, _callee17, this, [[10, 19]]);
    }));
    function getProposals(_x7) {
      return _getProposals.apply(this, arguments);
    }
    return getProposals;
  }()
  /**
   * Returns the settings of a plugin given the address of the plugin instance
   *
   * @param {string} pluginAddress
   * @param {number} blockNumber
   * @return {Promise<VotingSettings>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.getVotingSettings =
  /*#__PURE__*/
  function () {
    var _getVotingSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(pluginAddress, blockNumber) {
      var query, params, name, _yield$this$graphql$r4, tokenVotingPlugin;
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context18.next = 2;
              break;
            }
            throw new InvalidAddressError();
          case 2:
            query = QueryTokenVotingSettings;
            params = {
              address: pluginAddress.toLowerCase(),
              block: blockNumber ? {
                number: blockNumber
              } : null
            };
            name = "TokenVoting settings";
            _context18.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r4 = _context18.sent;
            tokenVotingPlugin = _yield$this$graphql$r4.tokenVotingPlugin;
            if (tokenVotingPlugin) {
              _context18.next = 11;
              break;
            }
            return _context18.abrupt("return", null);
          case 11:
            return _context18.abrupt("return", {
              minDuration: parseInt(tokenVotingPlugin.minDuration),
              supportThreshold: decodeRatio(BigInt(tokenVotingPlugin.supportThreshold), 6),
              minParticipation: decodeRatio(BigInt(tokenVotingPlugin.minParticipation), 6),
              minProposerVotingPower: BigInt(tokenVotingPlugin.minProposerVotingPower),
              votingMode: tokenVotingPlugin.votingMode
            });
          case 12:
          case "end":
            return _context18.stop();
        }
      }, _callee18, this);
    }));
    function getVotingSettings(_x9, _x10) {
      return _getVotingSettings.apply(this, arguments);
    }
    return getVotingSettings;
  }()
  /**
   * Returns the details of the token used in a specific plugin instance
   *
   * @param {string} pluginAddress
   * @return {Promise<Erc20TokenDetails | null>}
   * @memberof TokenVotingClient
   */
  ;
  _proto.getToken =
  /*#__PURE__*/
  function () {
    var _getToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(pluginAddress) {
      var query, params, name, _yield$this$graphql$r5, tokenVotingPlugin, token;
      return _regeneratorRuntime().wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context19.next = 2;
              break;
            }
            throw new InvalidAddressError();
          case 2:
            query = QueryTokenVotingPlugin;
            params = {
              address: pluginAddress.toLowerCase()
            };
            name = "TokenVoting token";
            _context19.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r5 = _context19.sent;
            tokenVotingPlugin = _yield$this$graphql$r5.tokenVotingPlugin;
            if (tokenVotingPlugin) {
              _context19.next = 11;
              break;
            }
            return _context19.abrupt("return", null);
          case 11:
            token = tokenVotingPlugin.token; // type erc20
            if (!(token.__typename === SubgraphContractType.ERC20)) {
              _context19.next = 16;
              break;
            }
            return _context19.abrupt("return", {
              address: token.id,
              name: token.name,
              symbol: token.symbol,
              decimals: token.decimals,
              type: TokenType.ERC20
            });
          case 16:
            if (!(token.__typename === SubgraphContractType.ERC721)) {
              _context19.next = 20;
              break;
            }
            return _context19.abrupt("return", {
              address: token.id,
              name: token.name,
              symbol: token.symbol,
              type: TokenType.ERC721
            });
          case 20:
            if (!(token.__typename === SubgraphContractType.ERC20_WRAPPER)) {
              _context19.next = 22;
              break;
            }
            return _context19.abrupt("return", {
              address: token.id,
              name: token.name,
              symbol: token.symbol,
              decimals: token.decimals,
              underlyingToken: {
                address: token.underlyingToken.id,
                name: token.underlyingToken.name,
                symbol: token.underlyingToken.symbol,
                decimals: token.underlyingToken.decimals,
                type: TokenType.ERC20
              },
              type: TokenType.ERC20
            });
          case 22:
            return _context19.abrupt("return", null);
          case 23:
          case "end":
            return _context19.stop();
        }
      }, _callee19, this);
    }));
    function getToken(_x11) {
      return _getToken.apply(this, arguments);
    }
    return getToken;
  }()
  /**
   * Checks if the given token is compatible with the TokenVoting plugin
   *
   * @param {string} tokenAddress
   * @return {Promise<TokenVotingTokenCompatibility>}
   * @memberof TokenVotingClientMethods
   */
  ;
  _proto.isTokenVotingCompatibleToken =
  /*#__PURE__*/
  function () {
    var _isTokenVotingCompatibleToken = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(tokenAddress) {
      var provider, contract, _iterator, _step, interfaceId, isSupported;
      return _regeneratorRuntime().wrap(function _callee20$(_context20) {
        while (1) switch (_context20.prev = _context20.next) {
          case 0:
            if (!(!isAddress(tokenAddress) || tokenAddress === AddressZero)) {
              _context20.next = 2;
              break;
            }
            throw new InvalidAddressError();
          case 2:
            provider = this.web3.getProvider(); // check if is a contract
            _context20.next = 5;
            return provider.getCode(tokenAddress);
          case 5:
            _context20.t0 = _context20.sent;
            if (!(_context20.t0 === "0x")) {
              _context20.next = 8;
              break;
            }
            throw new NotAContractError();
          case 8:
            contract = new Contract(tokenAddress, abi$3, provider);
            _context20.next = 11;
            return isERC20Token(tokenAddress, provider);
          case 11:
            if (_context20.sent) {
              _context20.next = 13;
              break;
            }
            return _context20.abrupt("return", TokenVotingTokenCompatibility.INCOMPATIBLE);
          case 13:
            _context20.prev = 13;
            _context20.next = 16;
            return contract.supportsInterface(ERC165_INTERFACE_ID);
          case 16:
            if (_context20.sent) {
              _context20.next = 18;
              break;
            }
            return _context20.abrupt("return", TokenVotingTokenCompatibility.NEEDS_WRAPPING);
          case 18:
            _iterator = _createForOfIteratorHelperLoose(GOVERNANCE_SUPPORTED_INTERFACE_IDS);
          case 19:
            if ((_step = _iterator()).done) {
              _context20.next = 28;
              break;
            }
            interfaceId = _step.value;
            _context20.next = 23;
            return contract.supportsInterface(interfaceId);
          case 23:
            isSupported = _context20.sent;
            if (!isSupported) {
              _context20.next = 26;
              break;
            }
            return _context20.abrupt("return", TokenVotingTokenCompatibility.COMPATIBLE);
          case 26:
            _context20.next = 19;
            break;
          case 28:
            return _context20.abrupt("return", TokenVotingTokenCompatibility.NEEDS_WRAPPING);
          case 31:
            _context20.prev = 31;
            _context20.t1 = _context20["catch"](13);
            return _context20.abrupt("return", TokenVotingTokenCompatibility.NEEDS_WRAPPING);
          case 34:
          case "end":
            return _context20.stop();
        }
      }, _callee20, this, [[13, 31]]);
    }));
    function isTokenVotingCompatibleToken(_x12) {
      return _isTokenVotingCompatibleToken.apply(this, arguments);
    }
    return isTokenVotingCompatibleToken;
  }()
  /**
   * Checks if a given address is a member of the tokenVoting contract.
   * @param params - The parameters for the isMember method.
   * @param params.pluginAddress - The address of the plugin.
   * @param params.address - The address to check.
   * @param params.blockNumber - The block number for specifying a specific block.
   * @returns {boolean} A boolean indicating whether the address is a member or not.
   */
  ;
  _proto.isMember =
  /*#__PURE__*/
  function () {
    var _isMember = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(params) {
      var query, name, _yield$this$graphql$r6, tokenVotingMember;
      return _regeneratorRuntime().wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            IsMemberSchema.strict().validateSync(params);
            query = QueryTokenVotingIsMember;
            name = "TokenVoting isMember";
            _context21.next = 5;
            return this.graphql.request({
              query: query,
              params: {
                id: params.pluginAddress.toLowerCase() + "_" + params.address.toLowerCase(),
                blockHeight: params.blockNumber ? {
                  number: params.blockNumber
                } : null
              },
              name: name
            });
          case 5:
            _yield$this$graphql$r6 = _context21.sent;
            tokenVotingMember = _yield$this$graphql$r6.tokenVotingMember;
            return _context21.abrupt("return", !!tokenVotingMember);
          case 8:
          case "end":
            return _context21.stop();
        }
      }, _callee21, this);
    }));
    function isMember(_x13) {
      return _isMember.apply(this, arguments);
    }
    return isMember;
  }();
  return TokenVotingClientMethods;
}(ClientCore);

/**
 * Encoding module the SDK TokenVoting Client
 */
var TokenVotingClientEncoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClientEncoding, _ClientCore);
  function TokenVotingClientEncoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {TokenVotingPluginInstall} params
   * @param {Networkish} network
   * @return {PluginInstallItem}
   * @memberof TokenVotingClientEncoding
   */
  TokenVotingClientEncoding.getPluginInstallItem = function getPluginInstallItem(params, network) {
    var _contracts$aragonNetw;
    var networkName = getNetwork(network).name;
    var aragonNetwork = getNetworkNameByAlias(networkName);
    if (!aragonNetwork) {
      throw new UnsupportedNetworkError(networkName);
    }
    var args = tokenVotingInitParamsToContract(params);
    var hexBytes = defaultAbiCoder.encode(getNamedTypesFromMetadata(INSTALLATION_ABI$1), args);
    var repoAddress = (_contracts$aragonNetw = contracts[aragonNetwork][SupportedVersions.V1_3_0]) == null || (_contracts$aragonNetw = _contracts$aragonNetw.TokenVotingRepoProxy) == null ? void 0 : _contracts$aragonNetw.address;
    if (!repoAddress) {
      throw new Error();
    }
    return {
      id: repoAddress,
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that updates the governance configuration
   *
   * @param {string} pluginAddress
   * @param {VotingSettings} params
   * @return {DaoAction}
   * @memberof TokenVotingClientEncoding
   */;
  var _proto = TokenVotingClientEncoding.prototype;
  _proto.updatePluginSettingsAction = function updatePluginSettingsAction(pluginAddress, params) {
    if (!isAddress(pluginAddress)) {
      throw new InvalidAddressError();
    }
    // TODO: check if to and value are correct
    return {
      to: pluginAddress,
      value: BigInt(0),
      data: encodeUpdateVotingSettingsAction(params)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that mints an amount of ERC-20 tokens to an address
   *
   * @param {string} minterAddress
   * @param {MintTokenParams} params
   * @return {DaoAction}
   * @memberof TokenVotingClientEncoding
   */;
  _proto.mintTokenAction = function mintTokenAction(minterAddress, params) {
    if (!isAddress(minterAddress) || !isAddress(params.address)) {
      throw new InvalidAddressError();
    }
    var votingInterface = IERC20MintableUpgradeable__factory.createInterface();
    var args = mintTokenParamsToContract(params);
    // get hex bytes
    var hexBytes = votingInterface.encodeFunctionData("mint", args);
    return {
      to: minterAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  };
  return TokenVotingClientEncoding;
}(ClientCore);

/**
 * Decoding module the SDK TokenVoting Client
 */
var TokenVotingClientDecoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClientDecoding, _ClientCore);
  function TokenVotingClientDecoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = TokenVotingClientDecoding.prototype;
  /**
   * Decodes a dao metadata from an encoded update metadata action
   *
   * @param {Uint8Array} data
   * @return {VotingSettings}
   * @memberof TokenVotingClientDecoding
   */
  _proto.updatePluginSettingsAction = function updatePluginSettingsAction(data) {
    return decodeUpdatePluginSettingsAction(data);
  }
  /**
   * Decodes the mint token params from an encoded mint token action
   *
   * @param {Uint8Array} data
   * @return {MintTokenParams}
   * @memberof TokenVotingClientDecoding
   */;
  _proto.mintTokenAction = function mintTokenAction(data) {
    var votingInterface = IERC20MintableUpgradeable__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = votingInterface.getFunction("mint");
    var result = votingInterface.decodeFunctionData(expectedfunction, hexBytes);
    return mintTokenParamsFromContract(result);
  }
  /**
   * Returns the decoded function info given the encoded data of an action
   *
   * @param {Uint8Array} data
   * @return {(InterfaceParams | null)}
   * @memberof TokenVotingClientDecoding
   */;
  _proto.findInterface = function findInterface(data) {
    try {
      var func = getFunctionFragment(data, AVAILABLE_FUNCTION_SIGNATURES$1);
      return {
        id: func.format("minimal"),
        functionName: func.name,
        hash: bytesToHex(data).substring(0, 10)
      };
    } catch (_unused) {
      return null;
    }
  };
  return TokenVotingClientDecoding;
}(ClientCore);

/**
 * Estimation module the SDK TokenVoting Client
 */
var TokenVotingClientEstimation = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClientEstimation, _ClientCore);
  function TokenVotingClientEstimation() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = TokenVotingClientEstimation.prototype;
  /**
   * Estimates the gas fee of creating a proposal on the plugin
   *
   * @param {CreateMajorityVotingProposalParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  _proto.createProposal =
  /*#__PURE__*/
  function () {
    var _createProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var provider, tokenVotingContract, allowFailureMap, startTimestamp, endTimestamp, estimatedGasFee;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            tokenVotingContract = TokenVoting__factory.connect(params.pluginAddress, provider);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new SizeMismatchError("failSafeActions", "actions");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return tokenVotingContract.estimateGas.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000), params.creatorVote || 0, params.executeOnPass || false);
          case 9:
            estimatedGasFee = _context.sent;
            return _context.abrupt("return", this.web3.getApproximateGasFee(estimatedGasFee.toBigInt()));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function createProposal(_x) {
      return _createProposal.apply(this, arguments);
    }
    return createProposal;
  }()
  /**
   * Estimates the gas fee of casting a vote on a proposal
   *
   * @param {VoteProposalParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  ;
  _proto.voteProposal =
  /*#__PURE__*/
  function () {
    var _voteProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var provider, _decodeProposalId, pluginAddress, id, tokenVotingContract, estimation;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, provider);
            _context2.next = 5;
            return tokenVotingContract.estimateGas.vote(id, params.vote, false);
          case 5:
            estimation = _context2.sent;
            return _context2.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function voteProposal(_x2) {
      return _voteProposal.apply(this, arguments);
    }
    return voteProposal;
  }()
  /**
   * Estimates the gas fee of executing a TokenVoting proposal
   *
   * @param {string} proposalId
   * @return {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  ;
  _proto.executeProposal =
  /*#__PURE__*/
  function () {
    var _executeProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(proposalId) {
      var provider, _decodeProposalId2, pluginAddress, id, tokenVotingContract, estimation;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            tokenVotingContract = TokenVoting__factory.connect(pluginAddress, provider);
            _context3.next = 5;
            return tokenVotingContract.estimateGas.execute(id);
          case 5:
            estimation = _context3.sent;
            return _context3.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function executeProposal(_x3) {
      return _executeProposal.apply(this, arguments);
    }
    return executeProposal;
  }()
  /**
   * Estimates the gas fee of delegating voting power to a delegatee
   *
   * @param {DelegateTokensParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  ;
  _proto.delegateTokens =
  /*#__PURE__*/
  function () {
    var _delegateTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params) {
      var provider, governanceErc20Contract, estimation;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            governanceErc20Contract = GovernanceERC20__factory.connect(params.tokenAddress, provider);
            _context4.next = 4;
            return governanceErc20Contract.estimateGas.delegate(params.delegatee);
          case 4:
            estimation = _context4.sent;
            return _context4.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 6:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function delegateTokens(_x4) {
      return _delegateTokens.apply(this, arguments);
    }
    return delegateTokens;
  }()
  /**
   * Estimates the gas fee of undelegating voting power
   *
   * @param {string} tokenAddress
   * @return {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  ;
  _proto.undelegateTokens =
  /*#__PURE__*/
  function () {
    var _undelegateTokens = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(tokenAddress) {
      var signer;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            signer = this.web3.getConnectedSigner();
            _context5.t0 = this;
            _context5.t1 = tokenAddress;
            _context5.next = 5;
            return signer.getAddress();
          case 5:
            _context5.t2 = _context5.sent;
            _context5.t3 = {
              tokenAddress: _context5.t1,
              delegatee: _context5.t2
            };
            return _context5.abrupt("return", _context5.t0.delegateTokens.call(_context5.t0, _context5.t3));
          case 8:
          case "end":
            return _context5.stop();
        }
      }, _callee5, this);
    }));
    function undelegateTokens(_x5) {
      return _undelegateTokens.apply(this, arguments);
    }
    return undelegateTokens;
  }()
  /**
   * Estimates the gas fee of preparing an update
   *
   * @param {TokenVotingPluginPrepareUpdateParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof TokenVotingClientEstimation
   */
  ;
  _proto.prepareUpdate =
  /*#__PURE__*/
  function () {
    var _prepareUpdate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(params) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return prepareGenericUpdateEstimation(this.web3, this.graphql, _extends({}, params, {
              pluginSetupProcessorAddress: this.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR),
              pluginRepo: this.web3.getAddress(NonFrameworkContractsNames.TOKEN_VOTING_REPO_PROXY)
            }));
          case 2:
            return _context6.abrupt("return", _context6.sent);
          case 3:
          case "end":
            return _context6.stop();
        }
      }, _callee6, this);
    }));
    function prepareUpdate(_x6) {
      return _prepareUpdate.apply(this, arguments);
    }
    return prepareUpdate;
  }();
  return TokenVotingClientEstimation;
}(ClientCore);

var _class$1;
/**
 * Provider a generic client with high level methods to manage and interact a Token Voting plugin installed in a DAO
 */
var TokenVotingClient = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(TokenVotingClient, _ClientCore);
  function TokenVotingClient(context) {
    var _this;
    _this = _ClientCore.call(this, context) || this;
    _this.methods = new TokenVotingClientMethods(context);
    _this.encoding = new TokenVotingClientEncoding(context);
    _this.decoding = new TokenVotingClientDecoding(context);
    _this.estimation = new TokenVotingClientEstimation(context);
    return _this;
  }
  return TokenVotingClient;
}(ClientCore);
_class$1 = TokenVotingClient;
_class$1.encoding = {
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {TokenVotingPluginInstall} params
   * @param {Networkish} [network="mainnet"]
   * @return {PluginInstallItem}
   * @memberof TokenVotingClient
   */
  getPluginInstallItem: function getPluginInstallItem(params, network) {
    return TokenVotingClientEncoding.getPluginInstallItem(params, network);
  }
};

var ApproveProposalStep;
(function (ApproveProposalStep) {
  ApproveProposalStep["APPROVING"] = "approving";
  ApproveProposalStep["DONE"] = "done";
})(ApproveProposalStep || (ApproveProposalStep = {}));

var _templateObject$2, _templateObject2$1;
var QueryMultisigProposal = /*#__PURE__*/gql(_templateObject$2 || (_templateObject$2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery MultisigProposal($proposalId: ID!) {\n  multisigProposal(id: $proposalId){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    createdAt\n    startDate\n    endDate\n    actions {\n      to\n      value\n      data\n    }\n    executionDate\n    executionBlockNumber\n    creationBlockNumber\n    plugin {\n      onlyListed\n    }\n    minApprovals\n    executionTxHash\n    executed\n    approvalReached\n    isSignaling\n    approvals(first: 1000){\n      approver{\n        address\n      }\n    }\n  }\n}\n"])));
var QueryMultisigProposals = /*#__PURE__*/gql(_templateObject2$1 || (_templateObject2$1 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery MultisigProposals($where: MultisigProposal_filter!, $limit:Int!, $skip: Int!, $direction: OrderDirection!, $sortBy: MultisigProposal_orderBy!) {\n  multisigProposals(where: $where, first: $limit, skip: $skip, orderDirection: $direction, orderBy: $sortBy){\n    id\n    dao {\n      id\n      subdomain\n    }\n    creator\n    metadata\n    executed\n    approvalReached\n    isSignaling\n    approvalCount\n    startDate\n    endDate\n    executionDate\n    executionBlockNumber\n    creationBlockNumber\n    approvals(first: 1000){\n      approver{\n        address\n      }\n    }\n    actions {\n      to\n      value\n      data\n    }\n    minApprovals\n    plugin{\n      onlyListed\n    }\n  }\n}\n"])));

var _templateObject$1;
var QueryMultisigVotingSettings = /*#__PURE__*/gql(_templateObject$1 || (_templateObject$1 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery MultisigVotingSettings($address: ID!, $block: Block_height) {\n    multisigPlugin(id: $address, block: $block){\n        minApprovals\n        onlyListed\n    }\n}\n"])));

var _templateObject, _templateObject2;
var QueryMultisigMembers = /*#__PURE__*/gql(_templateObject || (_templateObject = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery MultisigMembers($where: MultisigApprover_filter!, $block: Block_height, $limit: Int!, $skip: Int!, $sortBy: MultisigApprover_orderBy!, $direction: OrderDirection!) {\n  multisigApprovers(\n    where: $where\n    block: $block\n    first: $limit\n    skip: $skip\n    orderBy: $sortBy\n    orderDirection: $direction\n  ) {\n    address\n    isActive\n  }\n}\n"])));
var QueryMultisigIsMember = /*#__PURE__*/gql(_templateObject2 || (_templateObject2 = /*#__PURE__*/_taggedTemplateLiteralLoose(["\nquery MultisigIsMember($id: ID!, $block: Block_height) {\n  multisigApprover(\n    id: $id\n    block: $block\n  ) {\n    id\n  }\n}"])));

function toMultisigProposal(proposal, metadata) {
  var creationDate = new Date(parseInt(proposal.createdAt) * 1000);
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  var executionDate = proposal.executionDate ? new Date(parseInt(proposal.executionDate) * 1000) : null;
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary,
      description: metadata.description,
      resources: metadata.resources,
      media: metadata.media
    },
    metadataHash: proposal.metadata,
    settings: {
      onlyListed: proposal.plugin.onlyListed,
      minApprovals: proposal.minApprovals
    },
    creationBlockNumber: parseInt(proposal.creationBlockNumber) || 0,
    creationDate: creationDate,
    startDate: startDate,
    endDate: endDate,
    executionDate: executionDate,
    executionBlockNumber: parseInt(proposal.executionBlockNumber) || null,
    executionTxHash: proposal.executionTxHash || null,
    actions: proposal.actions.map(function (action) {
      return {
        data: hexToBytes(action.data),
        to: action.to,
        value: BigInt(action.value)
      };
    }),
    status: computeProposalStatus(proposal),
    approvals: proposal.approvals.map(function (a) {
      return a.approver.address;
    })
  };
}
function toMultisigProposalListItem(proposal, metadata) {
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  return {
    id: getCompactProposalId(proposal.id),
    dao: {
      address: proposal.dao.id,
      name: proposal.dao.subdomain
    },
    creatorAddress: proposal.creator,
    metadata: {
      title: metadata.title,
      summary: metadata.summary
    },
    metadataHash: proposal.metadata,
    approvals: proposal.approvals.map(function (a) {
      return a.approver.address;
    }),
    actions: proposal.actions.map(function (action) {
      return {
        data: hexToBytes(action.data),
        to: action.to,
        value: BigInt(action.value)
      };
    }),
    settings: {
      onlyListed: proposal.plugin.onlyListed,
      minApprovals: proposal.minApprovals
    },
    startDate: startDate,
    endDate: endDate,
    status: computeProposalStatus(proposal)
  };
}
function computeProposalStatus(proposal) {
  var now = new Date();
  var startDate = new Date(parseInt(proposal.startDate) * 1000);
  var endDate = new Date(parseInt(proposal.endDate) * 1000);
  // The proposal is executed so the status becomes EXECUTED
  // independently of the other conditions
  if (proposal.executed) {
    return ProposalStatus.EXECUTED;
  }
  // The proposal is not executed and the start date is in the future
  // so the status becomes PENDING
  if (startDate >= now) {
    return ProposalStatus.PENDING;
  }
  // The proposal is not executed and the start date is in the past
  // So we must check if the proposal reached the approval threshold
  // If it reached the approval threshold and it's a signaling proposal
  // the status becomes SUCCEEDED
  // If it reached the approval threshold and it's not a signaling proposal
  // the status becomes SUCCEEDED if if it hasn't reached the end date
  if (proposal.approvalReached) {
    if (proposal.isSignaling) {
      return ProposalStatus.SUCCEEDED;
    }
    if (now <= endDate) {
      return ProposalStatus.SUCCEEDED;
    }
  }
  // The proposal is not executed and the start date is in the past
  // and the approval threshold is not reached
  // If the end date is in the future this means that you can still vote
  // so the status becomes ACTIVE
  if (now <= endDate) {
    return ProposalStatus.ACTIVE;
  }
  // If none of the other conditions are met the status becomes DEFEATED
  return ProposalStatus.DEFEATED;
}
function computeProposalStatusFilter(status) {
  var where = {};
  var now = Math.round(new Date().getTime() / 1000).toString();
  switch (status) {
    case ProposalStatus.PENDING:
      where = {
        startDate_gte: now
      };
      break;
    case ProposalStatus.ACTIVE:
      where = {
        startDate_lt: now,
        endDate_gte: now,
        executed: false
      };
      break;
    case ProposalStatus.EXECUTED:
      where = {
        executed: true
      };
      break;
    case ProposalStatus.SUCCEEDED:
      where = {
        or: [{
          approvalReached: true,
          endDate_lt: now,
          isSignaling: false
        }, {
          approvalReached: true,
          isSignaling: true
        }]
      };
      break;
    case ProposalStatus.DEFEATED:
      where = {
        endDate_lt: now,
        executed: false
      };
      break;
    default:
      throw new InvalidProposalStatusError();
  }
  return where;
}

// @ts-ignore
// todo fix new contracts-ethers
// TODO update with function names
var AVAILABLE_FUNCTION_SIGNATURES = [/*#__PURE__*/Multisig__factory.createInterface().getFunction("addAddresses").format("minimal"), /*#__PURE__*/Multisig__factory.createInterface().getFunction("removeAddresses").format("minimal"), /*#__PURE__*/Multisig__factory.createInterface().getFunction("updateMultisigSettings").format("minimal")];
// TODO:
// use abi from plugin metadata
var UPDATE_ABI = {
  1: []
};
// TODO:
// use abi from plugin metadata
var INSTALLATION_ABI = [{
  internalType: "address[]",
  name: "members",
  type: "address[]",
  description: "The addresses of the initial members to be added."
}, {
  components: [{
    internalType: "bool",
    name: "onlyListed",
    type: "bool",
    description: "Whether only listed addresses can create a proposal or not."
  }, {
    internalType: "uint16",
    name: "minApprovals",
    type: "uint16",
    description: "The minimal number of approvals required for a proposal to pass."
  }],
  internalType: "struct Multisig.MultisigSettings",
  name: "multisigSettings",
  type: "tuple",
  description: "The inital multisig settings."
}];

/**
 * Methods module the SDK Address List Client
 */
var MultisigClientMethods = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClientMethods, _ClientCore);
  function MultisigClientMethods() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = MultisigClientMethods.prototype;
  /**
   * Creates a new proposal on the given multisig plugin contract
   *
   * @param {CreateMultisigProposalParams} params
   * @return {AsyncGenerator<ProposalCreationStepValue>}
   * @memberof MultisigClientMethods
   */
  _proto.createProposal = function createProposal(params) {
    var _this = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var signer, multisigContract, allowFailureMap, startTimestamp, endTimestamp, tx, receipt, multisigContractInterface, log, parsedLog, proposalId;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            signer = _this.web3.getConnectedSigner(); // TODO
            // implement a more sophisticated isFailingProposal function
            // if (isFailingProposal(params.actions)) {
            //   throw new AlwaysFailingProposalError();
            // }
            multisigContract = Multisig__factory.connect(params.pluginAddress, signer);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new SizeMismatchError("failSafeActions", "actions");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return _awaitAsyncGenerator(multisigContract.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, params.approve || false, params.tryExecution || false, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000)));
          case 9:
            tx = _context.sent;
            _context.next = 12;
            return {
              key: ProposalCreationSteps.CREATING,
              txHash: tx.hash
            };
          case 12:
            _context.next = 14;
            return _awaitAsyncGenerator(tx.wait());
          case 14:
            receipt = _context.sent;
            multisigContractInterface = Multisig__factory.createInterface();
            log = findLog(receipt, multisigContractInterface, "ProposalCreated");
            if (log) {
              _context.next = 19;
              break;
            }
            throw new ProposalCreationError();
          case 19:
            parsedLog = multisigContractInterface.parseLog(log);
            proposalId = parsedLog.args["proposalId"];
            if (proposalId) {
              _context.next = 23;
              break;
            }
            throw new ProposalCreationError();
          case 23:
            _context.next = 25;
            return {
              key: ProposalCreationSteps.DONE,
              proposalId: encodeProposalId(params.pluginAddress, Number(proposalId))
            };
          case 25:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  }
  /**
   * Pins a metadata object into IPFS and retruns the generated hash
   *
   * @param {ProposalMetadata} params
   * @return {Promise<string>}
   * @memberof MultisigClientMethods
   */;
  _proto.pinMetadata =
  /*#__PURE__*/
  function () {
    var _pinMetadata = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var cid;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return this.ipfs.add(JSON.stringify(params));
          case 3:
            cid = _context2.sent;
            _context2.next = 6;
            return this.ipfs.pin(cid);
          case 6:
            return _context2.abrupt("return", "ipfs://" + cid);
          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](0);
            throw new IpfsPinError(_context2.t0);
          case 12:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this, [[0, 9]]);
    }));
    function pinMetadata(_x) {
      return _pinMetadata.apply(this, arguments);
    }
    return pinMetadata;
  }()
  /**
   * Allow a wallet in the multisig give approval to a proposal
   *
   * @param {ApproveMultisigProposalParams} params
   * @return {AsyncGenerator<ApproveProposalStepValue>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.approveProposal = function approveProposal(params) {
    var _this2 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var signer, _decodeProposalId, pluginAddress, id, multisigContract, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            signer = _this2.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            multisigContract = Multisig__factory.connect(pluginAddress, signer);
            _context3.next = 5;
            return _awaitAsyncGenerator(multisigContract.approve(id, params.tryExecution));
          case 5:
            tx = _context3.sent;
            _context3.next = 8;
            return {
              key: ApproveProposalStep.APPROVING,
              txHash: tx.hash
            };
          case 8:
            _context3.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context3.next = 12;
            return {
              key: ApproveProposalStep.DONE
            };
          case 12:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }))();
  }
  /**
   * Allow a wallet in the multisig give approval to a proposal
   *
   * @param {string} proposalId
   * @return {AsyncGenerator<ExecuteMultisigProposalStepValue>}
   * @memberof MultisigClientMethods
   */;
  _proto.executeProposal = function executeProposal(proposalId) {
    var _this3 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var signer, _decodeProposalId2, pluginAddress, id, multisigContract, tx;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            signer = _this3.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            multisigContract = Multisig__factory.connect(pluginAddress, signer);
            _context4.next = 5;
            return _awaitAsyncGenerator(multisigContract.execute(id));
          case 5:
            tx = _context4.sent;
            _context4.next = 8;
            return {
              key: ExecuteProposalStep.EXECUTING,
              txHash: tx.hash
            };
          case 8:
            _context4.next = 10;
            return _awaitAsyncGenerator(tx.wait());
          case 10:
            _context4.next = 12;
            return {
              key: ExecuteProposalStep.DONE
            };
          case 12:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }))();
  }
  /**
   * Prepares the installation of a multisig plugin in a given dao
   *
   * @param {MultisigPluginPrepareInstallationParams} params
   * @return {AsyncGenerator<PrepareInstallationStepValue>}
   * @memberof MultisigClientMethods
   */;
  _proto.prepareInstallation = function prepareInstallation(params) {
    var _this4 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var network, networkName, aragonNetwork;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return _awaitAsyncGenerator(_this4.web3.getProvider().getNetwork());
          case 2:
            network = _context5.sent;
            networkName = network.name;
            aragonNetwork = getNetworkNameByAlias(networkName);
            if (aragonNetwork) {
              _context5.next = 7;
              break;
            }
            throw new UnsupportedNetworkError(networkName);
          case 7:
            return _context5.delegateYield(_asyncGeneratorDelegate(_asyncIterator(prepareGenericInstallation(_this4.web3, {
              daoAddressOrEns: params.daoAddressOrEns,
              pluginRepo: _this4.web3.getAddress(NonFrameworkContractsNames.MULTISIG_REPO_PROXY),
              version: params.versionTag,
              installationAbi: INSTALLATION_ABI,
              installationParams: [params.settings.members, [params.settings.votingSettings.onlyListed, params.settings.votingSettings.minApprovals]],
              pluginSetupProcessorAddress: _this4.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR)
            }))), "t0", 8);
          case 8:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }))();
  }
  /**
   * Prepares the update of a multisig plugin in a given dao
   *
   * @param {MultisigPluginPrepareUpdateParams} params
   * @return {AsyncGenerator<PrepareUpdateStepValue>}
   * @memberof MultisigClientMethods
   */;
  _proto.prepareUpdate = function prepareUpdate(params) {
    var _this5 = this;
    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.delegateYield(_asyncGeneratorDelegate(_asyncIterator(prepareGenericUpdate(_this5.web3, _this5.graphql, _extends({}, params, {
              pluginRepo: _this5.web3.getAddress(NonFrameworkContractsNames.MULTISIG_REPO_PROXY),
              updateAbi: UPDATE_ABI[params.newVersion.build] || params.updateAbi || [],
              pluginSetupProcessorAddress: _this5.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR)
            })))), "t0", 1);
          case 1:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }))();
  }
  /**
   * Checks whether the current proposal can be approved by the given address
   *
   * @param {string} addressOrEns
   * @return {Promise<boolean>}
   * @memberof MultisigClientMethods
   */;
  _proto.canApprove =
  /*#__PURE__*/
  function () {
    var _canApprove = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(params) {
      var provider, _decodeProposalId3, pluginAddress, id, multisigContract;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            provider = this.web3.getProvider();
            if (isAddress(params.approverAddressOrEns)) {
              _context7.next = 3;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 3:
            _decodeProposalId3 = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId3.pluginAddress, id = _decodeProposalId3.id;
            multisigContract = Multisig__factory.connect(pluginAddress, provider);
            return _context7.abrupt("return", multisigContract.canApprove(id, params.approverAddressOrEns));
          case 6:
          case "end":
            return _context7.stop();
        }
      }, _callee7, this);
    }));
    function canApprove(_x2) {
      return _canApprove.apply(this, arguments);
    }
    return canApprove;
  }()
  /**
   * Checks whether the current proposal can be executed
   *
   * @param {string} proposalId
   * @return {Promise<boolean>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.canExecute =
  /*#__PURE__*/
  function () {
    var _canExecute = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(proposalId) {
      var provider, _decodeProposalId4, pluginAddress, id, multisigContract;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            provider = this.web3.getProvider();
            _decodeProposalId4 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId4.pluginAddress, id = _decodeProposalId4.id;
            multisigContract = Multisig__factory.connect(pluginAddress, provider);
            return _context8.abrupt("return", multisigContract.canExecute(id));
          case 4:
          case "end":
            return _context8.stop();
        }
      }, _callee8, this);
    }));
    function canExecute(_x3) {
      return _canExecute.apply(this, arguments);
    }
    return canExecute;
  }()
  /**
   * Returns the voting settings
   *
   * @param {string} addressOrEns
   * @param {number} blockNumber
   * @return {Promise<MultisigVotingSettings>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.getVotingSettings =
  /*#__PURE__*/
  function () {
    var _getVotingSettings = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(pluginAddress, blockNumber) {
      var query, params, name, _yield$this$graphql$r, multisigPlugin;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            if (isAddress(pluginAddress)) {
              _context9.next = 2;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 2:
            query = QueryMultisigVotingSettings;
            params = {
              address: pluginAddress.toLowerCase(),
              block: blockNumber ? {
                number: blockNumber
              } : null
            };
            name = "Multisig settings";
            _context9.next = 7;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 7:
            _yield$this$graphql$r = _context9.sent;
            multisigPlugin = _yield$this$graphql$r.multisigPlugin;
            return _context9.abrupt("return", {
              onlyListed: multisigPlugin.onlyListed,
              minApprovals: multisigPlugin.minApprovals
            });
          case 10:
          case "end":
            return _context9.stop();
        }
      }, _callee9, this);
    }));
    function getVotingSettings(_x4, _x5) {
      return _getVotingSettings.apply(this, arguments);
    }
    return getVotingSettings;
  }()
  /**
   * returns the members of the multisig
   *
   * @param {MembersQueryParams} params
   *     - pluginAddress
   *     - blockNumber
   *     - limit = 10
   *     - skip = 0
   *     - direction = SortDirection.ASC
   *     - sortBy = MembersSortBy.ADDRESS
   * @return {Promise<string[]>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.getMembers =
  /*#__PURE__*/
  function () {
    var _getMembers = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_ref) {
      var pluginAddress, blockNumber, _ref$limit, limit, _ref$skip, skip, _ref$direction, direction, _ref$sortBy, sortBy, query, params, name, _yield$this$graphql$r2, multisigApprovers;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            pluginAddress = _ref.pluginAddress, blockNumber = _ref.blockNumber, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? 10 : _ref$limit, _ref$skip = _ref.skip, skip = _ref$skip === void 0 ? 0 : _ref$skip, _ref$direction = _ref.direction, direction = _ref$direction === void 0 ? SortDirection.ASC : _ref$direction, _ref$sortBy = _ref.sortBy, sortBy = _ref$sortBy === void 0 ? MembersSortBy.ADDRESS : _ref$sortBy;
            if (isAddress(pluginAddress)) {
              _context10.next = 3;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 3:
            query = QueryMultisigMembers;
            params = {
              where: {
                plugin: pluginAddress.toLowerCase()
              },
              block: blockNumber ? {
                number: blockNumber
              } : null,
              skip: skip,
              limit: limit,
              direction: direction,
              sortBy: sortBy
            };
            name = "Multisig members";
            _context10.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r2 = _context10.sent;
            multisigApprovers = _yield$this$graphql$r2.multisigApprovers;
            return _context10.abrupt("return", multisigApprovers.filter(function (member) {
              return member.isActive;
            }).map(function (member) {
              return member.address;
            }));
          case 11:
          case "end":
            return _context10.stop();
        }
      }, _callee10, this);
    }));
    function getMembers(_x6) {
      return _getMembers.apply(this, arguments);
    }
    return getMembers;
  }()
  /**
   * Returns the details of the given proposal
   *
   * @param {string} proposalId
   * @return {(Promise<MultisigProposal | null>)}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.getProposal =
  /*#__PURE__*/
  function () {
    var _getProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(proposalId) {
      var extendedProposalId, query, params, name, _yield$this$graphql$r3, multisigProposal, metadataCid, metadataString, metadata;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            if (isProposalId(proposalId)) {
              _context11.next = 2;
              break;
            }
            throw new InvalidProposalIdError();
          case 2:
            extendedProposalId = getExtendedProposalId(proposalId);
            query = QueryMultisigProposal;
            params = {
              proposalId: extendedProposalId
            };
            name = "Multisig proposal";
            _context11.next = 8;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 8:
            _yield$this$graphql$r3 = _context11.sent;
            multisigProposal = _yield$this$graphql$r3.multisigProposal;
            if (multisigProposal) {
              _context11.next = 14;
              break;
            }
            return _context11.abrupt("return", null);
          case 14:
            if (multisigProposal.metadata) {
              _context11.next = 16;
              break;
            }
            return _context11.abrupt("return", toMultisigProposal(multisigProposal, EMPTY_PROPOSAL_METADATA_LINK));
          case 16:
            _context11.prev = 16;
            metadataCid = resolveIpfsCid(multisigProposal.metadata);
            _context11.next = 20;
            return this.ipfs.fetchString(metadataCid);
          case 20:
            metadataString = _context11.sent;
            metadata = JSON.parse(metadataString);
            return _context11.abrupt("return", toMultisigProposal(multisigProposal, metadata));
          case 25:
            _context11.prev = 25;
            _context11.t0 = _context11["catch"](16);
            if (!(_context11.t0 instanceof InvalidCidError)) {
              _context11.next = 29;
              break;
            }
            return _context11.abrupt("return", toMultisigProposal(multisigProposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
          case 29:
            return _context11.abrupt("return", toMultisigProposal(multisigProposal, UNAVAILABLE_PROPOSAL_METADATA));
          case 30:
          case "end":
            return _context11.stop();
        }
      }, _callee11, this, [[16, 25]]);
    }));
    function getProposal(_x7) {
      return _getProposal.apply(this, arguments);
    }
    return getProposal;
  }()
  /**
   * Returns a list of proposals on the Plugin, filtered by the given criteria
   *
   * @param {ProposalQueryParams} params
   *       - daoAddressOrEns
   *       - limit = 10
   *       - status
   *       - skip = 0
   *       - direction = SortDirection.ASC
   *       - sortBy = ProposalSortBy.CREATED_AT
   * @return {Promise<MultisigProposalListItem[]>}
   * @memberof MultisigClientMethods
   */
  ;
  _proto.getProposals =
  /*#__PURE__*/
  function () {
    var _getProposals = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_ref2) {
      var _this6 = this;
      var daoAddressOrEns, _ref2$limit, limit, status, _ref2$skip, skip, _ref2$direction, direction, _ref2$sortBy, sortBy, where, address, provider, resolvedAddress, query, params, name, _yield$this$graphql$r4, multisigProposals;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            daoAddressOrEns = _ref2.daoAddressOrEns, _ref2$limit = _ref2.limit, limit = _ref2$limit === void 0 ? 10 : _ref2$limit, status = _ref2.status, _ref2$skip = _ref2.skip, skip = _ref2$skip === void 0 ? 0 : _ref2$skip, _ref2$direction = _ref2.direction, direction = _ref2$direction === void 0 ? SortDirection.ASC : _ref2$direction, _ref2$sortBy = _ref2.sortBy, sortBy = _ref2$sortBy === void 0 ? ProposalSortBy.CREATED_AT : _ref2$sortBy;
            where = {};
            address = daoAddressOrEns;
            if (!address) {
              _context13.next = 23;
              break;
            }
            if (isAddress(address)) {
              _context13.next = 22;
              break;
            }
            _context13.next = 7;
            return this.web3.ensureOnline();
          case 7:
            provider = this.web3.getProvider();
            if (provider) {
              _context13.next = 10;
              break;
            }
            throw new NoProviderError();
          case 10:
            _context13.prev = 10;
            _context13.next = 13;
            return provider.resolveName(address);
          case 13:
            resolvedAddress = _context13.sent;
            if (resolvedAddress) {
              _context13.next = 16;
              break;
            }
            throw new InvalidAddressOrEnsError();
          case 16:
            address = resolvedAddress;
            _context13.next = 22;
            break;
          case 19:
            _context13.prev = 19;
            _context13.t0 = _context13["catch"](10);
            throw new InvalidAddressOrEnsError(_context13.t0);
          case 22:
            where = {
              dao: address.toLowerCase()
            };
          case 23:
            if (status) {
              where = _extends({}, where, computeProposalStatusFilter(status));
            }
            query = QueryMultisigProposals;
            params = {
              where: where,
              limit: limit,
              skip: skip,
              direction: direction,
              sortBy: sortBy
            };
            name = "Multisig proposals";
            _context13.next = 29;
            return this.graphql.request({
              query: query,
              params: params,
              name: name
            });
          case 29:
            _yield$this$graphql$r4 = _context13.sent;
            multisigProposals = _yield$this$graphql$r4.multisigProposals;
            return _context13.abrupt("return", Promise.all(multisigProposals.map( /*#__PURE__*/function () {
              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(proposal) {
                var metadataCid, stringMetadata, metadata;
                return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                  while (1) switch (_context12.prev = _context12.next) {
                    case 0:
                      if (proposal.metadata) {
                        _context12.next = 2;
                        break;
                      }
                      return _context12.abrupt("return", toMultisigProposalListItem(proposal, EMPTY_PROPOSAL_METADATA_LINK));
                    case 2:
                      _context12.prev = 2;
                      metadataCid = resolveIpfsCid(proposal.metadata); // Avoid blocking Promise.all if this individual fetch takes too long
                      _context12.next = 6;
                      return promiseWithTimeout(_this6.ipfs.fetchString(metadataCid), MULTI_FETCH_TIMEOUT);
                    case 6:
                      stringMetadata = _context12.sent;
                      metadata = JSON.parse(stringMetadata);
                      return _context12.abrupt("return", toMultisigProposalListItem(proposal, metadata));
                    case 11:
                      _context12.prev = 11;
                      _context12.t0 = _context12["catch"](2);
                      if (!(_context12.t0 instanceof InvalidCidError)) {
                        _context12.next = 15;
                        break;
                      }
                      return _context12.abrupt("return", toMultisigProposalListItem(proposal, UNSUPPORTED_PROPOSAL_METADATA_LINK));
                    case 15:
                      return _context12.abrupt("return", toMultisigProposalListItem(proposal, UNAVAILABLE_PROPOSAL_METADATA));
                    case 16:
                    case "end":
                      return _context12.stop();
                  }
                }, _callee12, null, [[2, 11]]);
              }));
              return function (_x9) {
                return _ref3.apply(this, arguments);
              };
            }())));
          case 32:
          case "end":
            return _context13.stop();
        }
      }, _callee13, this, [[10, 19]]);
    }));
    function getProposals(_x8) {
      return _getProposals.apply(this, arguments);
    }
    return getProposals;
  }()
  /**
   * Checks if a given address is a member of the tokenVoting contract.
   * @param params - The parameters for the isMember method.
   * @param params.pluginAddress - The address of the plugin.
   * @param params.address - The address to check.
   * @param params.blockNumber - The block number for specifying a specific block.
   * @returns {boolean} A boolean indicating whether the address is a member or not.
   */
  ;
  _proto.isMember =
  /*#__PURE__*/
  function () {
    var _isMember = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(params) {
      var query, name, _yield$this$graphql$r5, multisigApprover;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            IsMemberSchema.strict().validateSync(params);
            query = QueryMultisigIsMember;
            name = "multisig isMember";
            _context14.next = 5;
            return this.graphql.request({
              query: query,
              params: {
                id: params.pluginAddress.toLowerCase() + "_" + params.address.toLowerCase(),
                blockHeight: params.blockNumber ? {
                  number: params.blockNumber
                } : null
              },
              name: name
            });
          case 5:
            _yield$this$graphql$r5 = _context14.sent;
            multisigApprover = _yield$this$graphql$r5.multisigApprover;
            return _context14.abrupt("return", !!multisigApprover);
          case 8:
          case "end":
            return _context14.stop();
        }
      }, _callee14, this);
    }));
    function isMember(_x10) {
      return _isMember.apply(this, arguments);
    }
    return isMember;
  }();
  return MultisigClientMethods;
}(ClientCore);

/**
 * Encoding module for the SDK Multisig Client
 */
var MultisigClientEncoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClientEncoding, _ClientCore);
  function MultisigClientEncoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {MultisigPluginInstallParams} params
   * @param {Networkish} network
   *
   * @return {PluginInstallItem}
   * @memberof MultisigClientEncoding
   */
  MultisigClientEncoding.getPluginInstallItem = function getPluginInstallItem(params, network) {
    var _contracts$aragonNetw;
    var networkName = getNetwork(network).name;
    var aragonNetwork = getNetworkNameByAlias(networkName);
    if (!aragonNetwork) {
      throw new UnsupportedNetworkError(networkName);
    }
    var hexBytes = defaultAbiCoder.encode(getNamedTypesFromMetadata(INSTALLATION_ABI), [params.members, [params.votingSettings.onlyListed, params.votingSettings.minApprovals]]);
    var repoAddress = (_contracts$aragonNetw = contracts[aragonNetwork][SupportedVersions.V1_3_0]) == null || (_contracts$aragonNetw = _contracts$aragonNetw.MultisigRepoProxy) == null ? void 0 : _contracts$aragonNetw.address;
    if (!repoAddress) {
      throw new Error("AddresslistVotingRepoProxy address not found");
    }
    return {
      // this case will return "" when the version 1.3.0 of the contracts is not deployed
      // in the specified network
      id: repoAddress,
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that updates the governance configuration
   *
   * @param {AddAddressesParams} params
   * @return {DaoAction[]}
   * @memberof MultisigClientEncoding
   */;
  var _proto = MultisigClientEncoding.prototype;
  _proto.addAddressesAction = function addAddressesAction(params) {
    if (!isAddress(params.pluginAddress)) {
      throw new InvalidAddressError();
    }
    // TODO yup validation
    for (var _iterator = _createForOfIteratorHelperLoose(params.members), _step; !(_step = _iterator()).done;) {
      var member = _step.value;
      if (!isAddress(member)) {
        throw new InvalidAddressError();
      }
    }
    var multisigInterface = Multisig__factory.createInterface();
    // get hex bytes
    var hexBytes = multisigInterface.encodeFunctionData("addAddresses", [params.members]);
    return {
      to: params.pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal that adds addresses to address list
   *
   * @param {RemoveAddressesParams} params
   * @return {DaoAction[]}
   * @memberof MultisigClientEncoding
   */;
  _proto.removeAddressesAction = function removeAddressesAction(params) {
    if (!isAddress(params.pluginAddress)) {
      throw new InvalidAddressError();
    }
    // TODO yup validation
    for (var _iterator2 = _createForOfIteratorHelperLoose(params.members), _step2; !(_step2 = _iterator2()).done;) {
      var member = _step2.value;
      if (!isAddress(member)) {
        throw new InvalidAddressError();
      }
    }
    var multisigInterface = Multisig__factory.createInterface();
    // get hex bytes
    var hexBytes = multisigInterface.encodeFunctionData("removeAddresses", [params.members]);
    return {
      to: params.pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  }
  /**
   * Computes the parameters to be given when creating a proposal updates multisig settings
   *
   * @param {UpdateMultisigVotingSettingsParams} params
   * @return {DaoAction}
   * @memberof MultisigClientEncoding
   */;
  _proto.updateMultisigVotingSettings = function updateMultisigVotingSettings(params) {
    if (!isAddress(params.pluginAddress)) {
      throw new InvalidAddressError();
    }
    var multisigInterface = Multisig__factory.createInterface();
    // get hex bytes
    var hexBytes = multisigInterface.encodeFunctionData("updateMultisigSettings", [params.votingSettings]);
    return {
      to: params.pluginAddress,
      value: BigInt(0),
      data: hexToBytes(hexBytes)
    };
  };
  return MultisigClientEncoding;
}(ClientCore);

/**
 * Decoding module for the SDK AddressList Client
 */
var MultisigClientDecoding = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClientDecoding, _ClientCore);
  function MultisigClientDecoding() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = MultisigClientDecoding.prototype;
  /**
   * Decodes a list of addresses from an encoded add members action
   *
   * @param {Uint8Array} data
   * @return {string[]}
   * @memberof MultisigClientDecoding
   */
  _proto.addAddressesAction = function addAddressesAction(data) {
    var multisigInterface = Multisig__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = multisigInterface.getFunction("addAddresses");
    var result = multisigInterface.decodeFunctionData(expectedfunction, hexBytes);
    return result[0];
  }
  /**
   * Decodes a list of addresses from an encoded remove members action
   *
   * @param {Uint8Array} data
   * @return {string[]}
   * @memberof MultisigClientDecoding
   */;
  _proto.removeAddressesAction = function removeAddressesAction(data) {
    var multisigInterface = Multisig__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = multisigInterface.getFunction("removeAddresses");
    var result = multisigInterface.decodeFunctionData(expectedfunction, hexBytes);
    return result[0];
  }
  /**
   * Decodes a list of min approvals from an encoded update min approval action
   *
   * @param {Uint8Array} data
   * @return {MultisigVotingSettings}
   * @memberof MultisigClientDecoding
   */;
  _proto.updateMultisigVotingSettings = function updateMultisigVotingSettings(data) {
    var multisigInterface = Multisig__factory.createInterface();
    var hexBytes = bytesToHex(data);
    var expectedfunction = multisigInterface.getFunction("updateMultisigSettings");
    var result = multisigInterface.decodeFunctionData(expectedfunction, hexBytes);
    return {
      minApprovals: result[0].minApprovals,
      onlyListed: result[0].onlyListed
    };
  }
  /**
   * Returns the decoded function info given the encoded data of an action
   *
   * @param {Uint8Array} data
   * @return {(InterfaceParams | null)}
   * @memberof MultisigClientDecoding
   */;
  _proto.findInterface = function findInterface(data) {
    try {
      var func = getFunctionFragment(data, AVAILABLE_FUNCTION_SIGNATURES);
      return {
        id: func.format("minimal"),
        functionName: func.name,
        hash: bytesToHex(data).substring(0, 10)
      };
    } catch (_unused) {
      return null;
    }
  };
  return MultisigClientDecoding;
}(ClientCore);

/**
 * Estimation module the SDK Address List Client
 */
var MultisigClientEstimation = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClientEstimation, _ClientCore);
  function MultisigClientEstimation() {
    return _ClientCore.apply(this, arguments) || this;
  }
  var _proto = MultisigClientEstimation.prototype;
  /**
   * Estimates the gas fee of creating a proposal on the plugin
   *
   * @param {CreateMultisigProposalParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof MultisigClientEstimation
   */
  _proto.createProposal =
  /*#__PURE__*/
  function () {
    var _createProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {
      var _params$failSafeActio, _params$actions, _params$startDate, _params$endDate;
      var provider, multisigContract, allowFailureMap, startTimestamp, endTimestamp, estimation;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            multisigContract = Multisig__factory.connect(params.pluginAddress, provider);
            if (!((_params$failSafeActio = params.failSafeActions) != null && _params$failSafeActio.length && params.failSafeActions.length !== ((_params$actions = params.actions) == null ? void 0 : _params$actions.length))) {
              _context.next = 4;
              break;
            }
            throw new SizeMismatchError("failSafeActions", "actions");
          case 4:
            allowFailureMap = boolArrayToBitmap(params.failSafeActions);
            startTimestamp = ((_params$startDate = params.startDate) == null ? void 0 : _params$startDate.getTime()) || 0;
            endTimestamp = ((_params$endDate = params.endDate) == null ? void 0 : _params$endDate.getTime()) || 0;
            _context.next = 9;
            return multisigContract.estimateGas.createProposal(toUtf8Bytes(params.metadataUri), params.actions || [], allowFailureMap, params.approve || false, params.tryExecution || true, Math.round(startTimestamp / 1000), Math.round(endTimestamp / 1000));
          case 9:
            estimation = _context.sent;
            return _context.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee, this);
    }));
    function createProposal(_x) {
      return _createProposal.apply(this, arguments);
    }
    return createProposal;
  }()
  /**
   * Estimates the gas fee of approving a proposal
   *
   * @param {ApproveMultisigProposalParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof MultisigClientEstimation
   */
  ;
  _proto.approveProposal =
  /*#__PURE__*/
  function () {
    var _approveProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {
      var provider, _decodeProposalId, pluginAddress, id, multisigContract, estimation;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            _decodeProposalId = decodeProposalId(params.proposalId), pluginAddress = _decodeProposalId.pluginAddress, id = _decodeProposalId.id;
            multisigContract = Multisig__factory.connect(pluginAddress, provider);
            _context2.next = 5;
            return multisigContract.estimateGas.approve(id, params.tryExecution);
          case 5:
            estimation = _context2.sent;
            return _context2.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2, this);
    }));
    function approveProposal(_x2) {
      return _approveProposal.apply(this, arguments);
    }
    return approveProposal;
  }()
  /**
   * Estimates the gas fee of executing a proposal
   *
   * @param {string} proposalId
   * @return {Promise<GasFeeEstimation>}
   * @memberof MultisigClientEstimation
   */
  ;
  _proto.executeProposal =
  /*#__PURE__*/
  function () {
    var _executeProposal = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(proposalId) {
      var provider, _decodeProposalId2, pluginAddress, id, multisigContract, estimation;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            provider = this.web3.getConnectedSigner();
            _decodeProposalId2 = decodeProposalId(proposalId), pluginAddress = _decodeProposalId2.pluginAddress, id = _decodeProposalId2.id;
            multisigContract = Multisig__factory.connect(pluginAddress, provider);
            _context3.next = 5;
            return multisigContract.estimateGas.execute(id);
          case 5:
            estimation = _context3.sent;
            return _context3.abrupt("return", this.web3.getApproximateGasFee(estimation.toBigInt()));
          case 7:
          case "end":
            return _context3.stop();
        }
      }, _callee3, this);
    }));
    function executeProposal(_x3) {
      return _executeProposal.apply(this, arguments);
    }
    return executeProposal;
  }()
  /**
   * Estimates the gas fee of preparing an update
   *
   * @param {MultisigPluginPrepareUpdateParams} params
   * @return {Promise<GasFeeEstimation>}
   * @memberof MultisigClientEstimation
   */
  ;
  _proto.prepareUpdate =
  /*#__PURE__*/
  function () {
    var _prepareUpdate = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(params) {
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return prepareGenericUpdateEstimation(this.web3, this.graphql, _extends({}, params, {
              pluginSetupProcessorAddress: this.web3.getAddress(FrameworkContractsNames.PLUGIN_SETUP_PROCESSOR),
              pluginRepo: this.web3.getAddress(NonFrameworkContractsNames.MULTISIG_REPO_PROXY)
            }));
          case 2:
            return _context4.abrupt("return", _context4.sent);
          case 3:
          case "end":
            return _context4.stop();
        }
      }, _callee4, this);
    }));
    function prepareUpdate(_x4) {
      return _prepareUpdate.apply(this, arguments);
    }
    return prepareUpdate;
  }();
  return MultisigClientEstimation;
}(ClientCore);

var _class;
/**
 * Provider a generic client with high level methods to manage and interact an Address List Voting plugin installed in a DAO
 */
var MultisigClient = /*#__PURE__*/function (_ClientCore) {
  _inheritsLoose(MultisigClient, _ClientCore);
  function MultisigClient(context) {
    var _this;
    _this = _ClientCore.call(this, context) || this;
    _this.methods = new MultisigClientMethods(context);
    _this.encoding = new MultisigClientEncoding(context);
    _this.decoding = new MultisigClientDecoding(context);
    _this.estimation = new MultisigClientEstimation(context);
    return _this;
  }
  return MultisigClient;
}(ClientCore);
_class = MultisigClient;
_class.encoding = {
  /**
   * Computes the parameters to be given when creating the DAO,
   * so that the plugin is configured
   *
   * @param {MultisigPluginInstallParams} params
   * @param {Networkish} [network="mainnet"]
   * @return {PluginInstallItem}
   * @memberof MultisigClient
   */
  getPluginInstallItem: function getPluginInstallItem(params, network) {
    return MultisigClientEncoding.getPluginInstallItem(params, network);
  }
};

export { AddresslistVotingClient, ApproveProposalStep, AssetBalanceSortBy, Client, DaoCreationSteps, DaoDepositSteps, DaoRole, DaoSortBy, DaoUpdateProposalInvalidityCause, ExecuteProposalStep, MembersSortBy, MultisigClient, PluginPreparationSortBy, PluginPreparationType, PluginSortBy, PluginUpdateProposalInValidityCause, ProposalCreationSteps, ProposalSettingsErrorCause, ProposalSortBy, SetAllowanceSteps, SubgraphVoteValues, SubgraphVoteValuesMap, TokenVotingClient, TransferSortBy, TransferType, UnwrapTokensStep, VoteProposalStep, VoteValues, VotingMode, WrapTokensStep, applyInstallatonParamsFromContract, decodeUpdatePluginSettingsAction, encodeUpdateVotingSettingsAction, isFailingProposal, unwrapProposalParams, votingModeFromContracts, votingModeToContracts, votingSettingsToContract };
//# sourceMappingURL=sdk-client.esm.js.map
