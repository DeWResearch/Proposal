import { ApproveMultisigProposalParams, ApproveProposalStepValue, CanApproveParams, CreateMultisigProposalParams, MultisigPluginPrepareInstallationParams, MultisigPluginPrepareUpdateParams, MultisigProposal, MultisigProposalListItem, MultisigVotingSettings } from "../../types";
import { ExecuteProposalStepValue, MembersQueryParams, ProposalCreationStepValue, ProposalQueryParams } from "../../../client-common";
import { IMultisigClientMethods } from "../interfaces";
import { ClientCore, IsMemberParams, PrepareInstallationStepValue, PrepareUpdateStepValue, ProposalMetadata } from "@aragon/sdk-client-common";
/**
 * Methods module the SDK Address List Client
 */
export declare class MultisigClientMethods extends ClientCore implements IMultisigClientMethods {
    /**
     * Creates a new proposal on the given multisig plugin contract
     *
     * @param {CreateMultisigProposalParams} params
     * @return {AsyncGenerator<ProposalCreationStepValue>}
     * @memberof MultisigClientMethods
     */
    createProposal(params: CreateMultisigProposalParams): AsyncGenerator<ProposalCreationStepValue>;
    /**
     * Pins a metadata object into IPFS and retruns the generated hash
     *
     * @param {ProposalMetadata} params
     * @return {Promise<string>}
     * @memberof MultisigClientMethods
     */
    pinMetadata(params: ProposalMetadata): Promise<string>;
    /**
     * Allow a wallet in the multisig give approval to a proposal
     *
     * @param {ApproveMultisigProposalParams} params
     * @return {AsyncGenerator<ApproveProposalStepValue>}
     * @memberof MultisigClientMethods
     */
    approveProposal(params: ApproveMultisigProposalParams): AsyncGenerator<ApproveProposalStepValue>;
    /**
     * Allow a wallet in the multisig give approval to a proposal
     *
     * @param {string} proposalId
     * @return {AsyncGenerator<ExecuteMultisigProposalStepValue>}
     * @memberof MultisigClientMethods
     */
    executeProposal(proposalId: string): AsyncGenerator<ExecuteProposalStepValue>;
    /**
     * Prepares the installation of a multisig plugin in a given dao
     *
     * @param {MultisigPluginPrepareInstallationParams} params
     * @return {AsyncGenerator<PrepareInstallationStepValue>}
     * @memberof MultisigClientMethods
     */
    prepareInstallation(params: MultisigPluginPrepareInstallationParams): AsyncGenerator<PrepareInstallationStepValue>;
    /**
     * Prepares the update of a multisig plugin in a given dao
     *
     * @param {MultisigPluginPrepareUpdateParams} params
     * @return {AsyncGenerator<PrepareUpdateStepValue>}
     * @memberof MultisigClientMethods
     */
    prepareUpdate(params: MultisigPluginPrepareUpdateParams): AsyncGenerator<PrepareUpdateStepValue>;
    /**
     * Checks whether the current proposal can be approved by the given address
     *
     * @param {string} addressOrEns
     * @return {Promise<boolean>}
     * @memberof MultisigClientMethods
     */
    canApprove(params: CanApproveParams): Promise<boolean>;
    /**
     * Checks whether the current proposal can be executed
     *
     * @param {string} proposalId
     * @return {Promise<boolean>}
     * @memberof MultisigClientMethods
     */
    canExecute(proposalId: string): Promise<boolean>;
    /**
     * Returns the voting settings
     *
     * @param {string} addressOrEns
     * @param {number} blockNumber
     * @return {Promise<MultisigVotingSettings>}
     * @memberof MultisigClientMethods
     */
    getVotingSettings(pluginAddress: string, blockNumber?: number): Promise<MultisigVotingSettings>;
    /**
     * returns the members of the multisig
     *
     * @param {MembersQueryParams} params
     *     - pluginAddress
     *     - blockNumber
     *     - limit = 10
     *     - skip = 0
     *     - direction = SortDirection.ASC
     *     - sortBy = MembersSortBy.ADDRESS
     * @return {Promise<string[]>}
     * @memberof MultisigClientMethods
     */
    getMembers({ pluginAddress, blockNumber, limit, skip, direction, sortBy, }: MembersQueryParams): Promise<string[]>;
    /**
     * Returns the details of the given proposal
     *
     * @param {string} proposalId
     * @return {(Promise<MultisigProposal | null>)}
     * @memberof MultisigClientMethods
     */
    getProposal(proposalId: string): Promise<MultisigProposal | null>;
    /**
     * Returns a list of proposals on the Plugin, filtered by the given criteria
     *
     * @param {ProposalQueryParams} params
     *       - daoAddressOrEns
     *       - limit = 10
     *       - status
     *       - skip = 0
     *       - direction = SortDirection.ASC
     *       - sortBy = ProposalSortBy.CREATED_AT
     * @return {Promise<MultisigProposalListItem[]>}
     * @memberof MultisigClientMethods
     */
    getProposals({ daoAddressOrEns, limit, status, skip, direction, sortBy, }: ProposalQueryParams): Promise<MultisigProposalListItem[]>;
    /**
     * Checks if a given address is a member of the tokenVoting contract.
     * @param params - The parameters for the isMember method.
     * @param params.pluginAddress - The address of the plugin.
     * @param params.address - The address to check.
     * @param params.blockNumber - The block number for specifying a specific block.
     * @returns {boolean} A boolean indicating whether the address is a member or not.
     */
    isMember(params: IsMemberParams): Promise<boolean>;
}
